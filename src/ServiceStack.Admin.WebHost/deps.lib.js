"bundle";
System.registerDynamic('npm:react-dom@15.4.1/lib/ARIADOMPropertyConfig.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = {
    Properties: {
      // Global States and Properties
      'aria-current': 0, // state
      'aria-details': 0,
      'aria-disabled': 0, // state
      'aria-hidden': 0, // state
      'aria-invalid': 0, // state
      'aria-keyshortcuts': 0,
      'aria-label': 0,
      'aria-roledescription': 0,
      // Widget Attributes
      'aria-autocomplete': 0,
      'aria-checked': 0,
      'aria-expanded': 0,
      'aria-haspopup': 0,
      'aria-level': 0,
      'aria-modal': 0,
      'aria-multiline': 0,
      'aria-multiselectable': 0,
      'aria-orientation': 0,
      'aria-placeholder': 0,
      'aria-pressed': 0,
      'aria-readonly': 0,
      'aria-required': 0,
      'aria-selected': 0,
      'aria-sort': 0,
      'aria-valuemax': 0,
      'aria-valuemin': 0,
      'aria-valuenow': 0,
      'aria-valuetext': 0,
      // Live Region Attributes
      'aria-atomic': 0,
      'aria-busy': 0,
      'aria-live': 0,
      'aria-relevant': 0,
      // Drag-and-Drop Attributes
      'aria-dropeffect': 0,
      'aria-grabbed': 0,
      // Relationship Attributes
      'aria-activedescendant': 0,
      'aria-colcount': 0,
      'aria-colindex': 0,
      'aria-colspan': 0,
      'aria-controls': 0,
      'aria-describedby': 0,
      'aria-errormessage': 0,
      'aria-flowto': 0,
      'aria-labelledby': 0,
      'aria-owns': 0,
      'aria-posinset': 0,
      'aria-rowcount': 0,
      'aria-rowindex': 0,
      'aria-rowspan': 0,
      'aria-setsize': 0
    },
    DOMAttributeNames: {},
    DOMPropertyNames: {}
  };

  module.exports = ARIADOMPropertyConfig;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/FallbackCompositionState.js', ['object-assign', './PooledClass', './getTextContentAccessor', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var PooledClass = $__require('./PooledClass');

  var getTextContentAccessor = $__require('./getTextContentAccessor');

  /**
   * This helper class stores information about text content of a target node,
   * allowing comparison of content before and after a given event.
   *
   * Identify the node where selection currently begins, then observe
   * both its text content and its current position in the DOM. Since the
   * browser may natively replace the target node during composition, we can
   * use its position to find its replacement.
   *
   * @param {DOMEventTarget} root
   */
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }

  _assign(FallbackCompositionState.prototype, {
    destructor: function () {
      this._root = null;
      this._startText = null;
      this._fallbackText = null;
    },

    /**
     * Get current text of input.
     *
     * @return {string}
     */
    getText: function () {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },

    /**
     * Determine the differing substring between the initially stored
     * text content and the current content.
     *
     * @return {string}
     */
    getData: function () {
      if (this._fallbackText) {
        return this._fallbackText;
      }

      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;

      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }

      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }

      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });

  PooledClass.addPoolingTo(FallbackCompositionState);

  module.exports = FallbackCompositionState;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticCompositionEvent.js', ['./SyntheticEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  /**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
   */
  var CompositionEventInterface = {
    data: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

  module.exports = SyntheticCompositionEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticInputEvent.js', ['./SyntheticEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  /**
   * @interface Event
   * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
   *      /#events-inputevents
   */
  var InputEventInterface = {
    data: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

  module.exports = SyntheticInputEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/BeforeInputEventPlugin.js', ['./EventPropagators', 'fbjs/lib/ExecutionEnvironment', './FallbackCompositionState', './SyntheticCompositionEvent', './SyntheticInputEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var FallbackCompositionState = $__require('./FallbackCompositionState');
  var SyntheticCompositionEvent = $__require('./SyntheticCompositionEvent');
  var SyntheticInputEvent = $__require('./SyntheticInputEvent');

  var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
  var START_KEYCODE = 229;

  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }

  // Webkit offers a very useful `textInput` event that can be used to
  // directly represent `beforeInput`. The IE `textinput` event is not as
  // useful, so we don't use it.
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

  // In IE9+, we have access to composition events, but the data supplied
  // by the native compositionend event may be incorrect. Japanese ideographic
  // spaces, for instance (\u3000) are not recorded correctly.
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

  /**
   * Opera <= 12 includes TextEvent in window, but does not fire
   * text input events. Rely on keypress instead.
   */
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }

  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

  // Events and their corresponding property names.
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: 'onBeforeInput',
        captured: 'onBeforeInputCapture'
      },
      dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionEnd',
        captured: 'onCompositionEndCapture'
      },
      dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionStart',
        captured: 'onCompositionStartCapture'
      },
      dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionUpdate',
        captured: 'onCompositionUpdateCapture'
      },
      dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    }
  };

  // Track whether we've ever handled a keypress on the space key.
  var hasSpaceKeypress = false;

  /**
   * Return whether a native keypress event is assumed to be a command.
   * This is required because Firefox fires `keypress` events for key commands
   * (cut, copy, select-all, etc.) even though no character is inserted.
   */
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
    !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }

  /**
   * Translate native top level events into event types.
   *
   * @param {string} topLevelType
   * @return {object}
   */
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case 'topCompositionStart':
        return eventTypes.compositionStart;
      case 'topCompositionEnd':
        return eventTypes.compositionEnd;
      case 'topCompositionUpdate':
        return eventTypes.compositionUpdate;
    }
  }

  /**
   * Does our fallback best-guess model think this event signifies that
   * composition has begun?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
  }

  /**
   * Does our fallback mode think that this event is the end of composition?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topKeyUp':
        // Command keys insert or clear IME input.
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case 'topKeyDown':
        // Expect IME keyCode on each keydown. If we get any other
        // code we must have exited earlier.
        return nativeEvent.keyCode !== START_KEYCODE;
      case 'topKeyPress':
      case 'topMouseDown':
      case 'topBlur':
        // Events are not possible without cancelling IME.
        return true;
      default:
        return false;
    }
  }

  /**
   * Google Input Tools provides composition data via a CustomEvent,
   * with the `data` property populated in the `detail` object. If this
   * is available on the event object, use it. If not, this is a plain
   * composition event and we have nothing special to extract.
   *
   * @param {object} nativeEvent
   * @return {?string}
   */
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }

  // Track the current IME composition fallback object, if any.
  var currentComposition = null;

  /**
   * @return {?object} A SyntheticCompositionEvent.
   */
  function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;

    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }

    if (!eventType) {
      return null;
    }

    if (useFallbackCompositionData) {
      // The current composition is stored statically and must not be
      // overwritten while composition continues.
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }

    var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }

    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The string corresponding to this `beforeInput` event.
   */
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topCompositionEnd':
        return getDataFromCustomEvent(nativeEvent);
      case 'topKeyPress':
        /**
         * If native `textInput` events are available, our goal is to make
         * use of them. However, there is a special case: the spacebar key.
         * In Webkit, preventing default on a spacebar `textInput` event
         * cancels character insertion, but it *also* causes the browser
         * to fall back to its default spacebar behavior of scrolling the
         * page.
         *
         * Tracking at:
         * https://code.google.com/p/chromium/issues/detail?id=355103
         *
         * To avoid this issue, use the keypress event as if no `textInput`
         * event is available.
         */
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }

        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;

      case 'topTextInput':
        // Record the characters to be added to the DOM.
        var chars = nativeEvent.data;

        // If it's a spacebar character, assume that we have already handled
        // it at the keypress level and bail immediately. Android Chrome
        // doesn't give us keycodes, so we need to blacklist it.
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }

        return chars;

      default:
        // For other native event types, do nothing.
        return null;
    }
  }

  /**
   * For browsers that do not provide the `textInput` event, extract the
   * appropriate string to use for SyntheticInputEvent.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The fallback string for this `beforeInput` event.
   */
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    // If we are currently composing (IME) and using a fallback to do so,
    // try to extract the composed characters from the fallback object.
    // If composition event is available, we extract a string only at
    // compositionevent, otherwise extract it at fallback events.
    if (currentComposition) {
      if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }

    switch (topLevelType) {
      case 'topPaste':
        // If a paste event occurs after a keypress, throw out the input
        // chars. Paste events should not lead to BeforeInput events.
        return null;
      case 'topKeyPress':
        /**
         * As of v27, Firefox may fire keypress events even when no character
         * will be inserted. A few possibilities:
         *
         * - `which` is `0`. Arrow keys, Esc key, etc.
         *
         * - `which` is the pressed key code, but no char is available.
         *   Ex: 'AltGr + d` in Polish. There is no modified character for
         *   this key combination and no character is inserted into the
         *   document, but FF fires the keypress for char code `100` anyway.
         *   No `input` event will occur.
         *
         * - `which` is the pressed key code, but a command combination is
         *   being used. Ex: `Cmd+C`. No character is inserted, and no
         *   `input` event will occur.
         */
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case 'topCompositionEnd':
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }

  /**
   * Extract a SyntheticInputEvent for `beforeInput`, based on either native
   * `textInput` or fallback behavior.
   *
   * @return {?object} A SyntheticInputEvent.
   */
  function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var chars;

    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }

    // If no characters are being inserted, no BeforeInput event should
    // be fired.
    if (!chars) {
      return null;
    }

    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

  /**
   * Create an `onBeforeInput` event to match
   * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
   *
   * This event plugin is based on the native `textInput` event
   * available in Chrome, Safari, Opera, and IE. This event fires after
   * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
   *
   * `beforeInput` is spec'd but not implemented in any browsers, and
   * the `input` event does not provide any useful information about what has
   * actually been added, contrary to the spec. Thus, `textInput` is the best
   * available event to identify the characters that have actually been inserted
   * into the target node.
   *
   * This plugin is also responsible for emitting `composition` events, thus
   * allowing us to share composition fallback code for both `beforeInput` and
   * `composition` event types.
   */
  var BeforeInputEventPlugin = {

    eventTypes: eventTypes,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
    }
  };

  module.exports = BeforeInputEventPlugin;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ChangeEventPlugin.js', ['./EventPluginHub', './EventPropagators', 'fbjs/lib/ExecutionEnvironment', './ReactDOMComponentTree', './ReactUpdates', './SyntheticEvent', './getEventTarget', './isEventSupported', './isTextInputElement', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');
  var SyntheticEvent = $__require('./SyntheticEvent');

  var getEventTarget = $__require('./getEventTarget');
  var isEventSupported = $__require('./isEventSupported');
  var isTextInputElement = $__require('./isTextInputElement');

  var eventTypes = {
    change: {
      phasedRegistrationNames: {
        bubbled: 'onChange',
        captured: 'onChangeCapture'
      },
      dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
    }
  };

  /**
   * For IE shims
   */
  var activeElement = null;
  var activeElementInst = null;
  var activeElementValue = null;
  var activeElementValueProp = null;

  /**
   * SECTION: handle `change` event
   */
  function shouldUseChangeEvent(elem) {
    var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
  }

  var doesChangeEventBubble = false;
  if (ExecutionEnvironment.canUseDOM) {
    // See `handleChange` comment below
    doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
  }

  function manualDispatchChangeEvent(nativeEvent) {
    var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
    EventPropagators.accumulateTwoPhaseDispatches(event);

    // If change and propertychange bubbled, we'd just bind to it like all the
    // other events and have it go through ReactBrowserEventEmitter. Since it
    // doesn't, we manually listen for the events and so we have to enqueue and
    // process the abstract event manually.
    //
    // Batching is necessary here in order to ensure that all event handlers run
    // before the next rerender (including event handlers attached to ancestor
    // elements instead of directly on the input). Without this, controlled
    // components don't work properly in conjunction with event bubbling because
    // the component is rerendered and the value reverted before all the event
    // handlers can run. See https://github.com/facebook/react/issues/708.
    ReactUpdates.batchedUpdates(runEventInBatch, event);
  }

  function runEventInBatch(event) {
    EventPluginHub.enqueueEvents(event);
    EventPluginHub.processEventQueue(false);
  }

  function startWatchingForChangeEventIE8(target, targetInst) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElement.attachEvent('onchange', manualDispatchChangeEvent);
  }

  function stopWatchingForChangeEventIE8() {
    if (!activeElement) {
      return;
    }
    activeElement.detachEvent('onchange', manualDispatchChangeEvent);
    activeElement = null;
    activeElementInst = null;
  }

  function getTargetInstForChangeEvent(topLevelType, targetInst) {
    if (topLevelType === 'topChange') {
      return targetInst;
    }
  }
  function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
    if (topLevelType === 'topFocus') {
      // stopWatching() should be a noop here but we call it just in case we
      // missed a blur event somehow.
      stopWatchingForChangeEventIE8();
      startWatchingForChangeEventIE8(target, targetInst);
    } else if (topLevelType === 'topBlur') {
      stopWatchingForChangeEventIE8();
    }
  }

  /**
   * SECTION: handle `input` event
   */
  var isInputEventSupported = false;
  if (ExecutionEnvironment.canUseDOM) {
    // IE9 claims to support the input event but fails to trigger it when
    // deleting text, so we ignore its input events.
    // IE10+ fire input events to often, such when a placeholder
    // changes or when an input with a placeholder is focused.
    isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
  }

  /**
   * (For IE <=11) Replacement getter/setter for the `value` property that gets
   * set on the active element.
   */
  var newValueProp = {
    get: function () {
      return activeElementValueProp.get.call(this);
    },
    set: function (val) {
      // Cast to a string so we can do equality checks.
      activeElementValue = '' + val;
      activeElementValueProp.set.call(this, val);
    }
  };

  /**
   * (For IE <=11) Starts tracking propertychange events on the passed-in element
   * and override the value property so that we can distinguish user events from
   * value changes in JS.
   */
  function startWatchingForValueChange(target, targetInst) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElementValue = target.value;
    activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

    // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
    // on DOM elements
    Object.defineProperty(activeElement, 'value', newValueProp);
    if (activeElement.attachEvent) {
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    } else {
      activeElement.addEventListener('propertychange', handlePropertyChange, false);
    }
  }

  /**
   * (For IE <=11) Removes the event listeners from the currently-tracked element,
   * if any exists.
   */
  function stopWatchingForValueChange() {
    if (!activeElement) {
      return;
    }

    // delete restores the original property definition
    delete activeElement.value;

    if (activeElement.detachEvent) {
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
    } else {
      activeElement.removeEventListener('propertychange', handlePropertyChange, false);
    }

    activeElement = null;
    activeElementInst = null;
    activeElementValue = null;
    activeElementValueProp = null;
  }

  /**
   * (For IE <=11) Handles a propertychange event, sending a `change` event if
   * the value of the active element has changed.
   */
  function handlePropertyChange(nativeEvent) {
    if (nativeEvent.propertyName !== 'value') {
      return;
    }
    var value = nativeEvent.srcElement.value;
    if (value === activeElementValue) {
      return;
    }
    activeElementValue = value;

    manualDispatchChangeEvent(nativeEvent);
  }

  /**
   * If a `change` event should be fired, returns the target's ID.
   */
  function getTargetInstForInputEvent(topLevelType, targetInst) {
    if (topLevelType === 'topInput') {
      // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
      // what we want so fall through here and trigger an abstract event
      return targetInst;
    }
  }

  function handleEventsForInputEventIE(topLevelType, target, targetInst) {
    if (topLevelType === 'topFocus') {
      // In IE8, we can capture almost all .value changes by adding a
      // propertychange handler and looking for events with propertyName
      // equal to 'value'
      // In IE9-11, propertychange fires for most input events but is buggy and
      // doesn't fire when text is deleted, but conveniently, selectionchange
      // appears to fire in all of the remaining cases so we catch those and
      // forward the event if the value has changed
      // In either case, we don't want to call the event handler if the value
      // is changed from JS so we redefine a setter for `.value` that updates
      // our activeElementValue variable, allowing us to ignore those changes
      //
      // stopWatching() should be a noop here but we call it just in case we
      // missed a blur event somehow.
      stopWatchingForValueChange();
      startWatchingForValueChange(target, targetInst);
    } else if (topLevelType === 'topBlur') {
      stopWatchingForValueChange();
    }
  }

  // For IE8 and IE9.
  function getTargetInstForInputEventIE(topLevelType, targetInst) {
    if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
      // On the selectionchange event, the target is just document which isn't
      // helpful for us so just check activeElement instead.
      //
      // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
      // propertychange on the first input event after setting `value` from a
      // script and fires only keydown, keypress, keyup. Catching keyup usually
      // gets it and catching keydown lets us fire an event for the first
      // keystroke if user does a key repeat (it'll be a little delayed: right
      // before the second keystroke). Other input methods (e.g., paste) seem to
      // fire selectionchange normally.
      if (activeElement && activeElement.value !== activeElementValue) {
        activeElementValue = activeElement.value;
        return activeElementInst;
      }
    }
  }

  /**
   * SECTION: handle `click` event
   */
  function shouldUseClickEvent(elem) {
    // Use the `click` event to detect changes to checkbox and radio inputs.
    // This approach works across all browsers, whereas `change` does not fire
    // until `blur` in IE8.
    return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
  }

  function getTargetInstForClickEvent(topLevelType, targetInst) {
    if (topLevelType === 'topClick') {
      return targetInst;
    }
  }

  /**
   * This plugin creates an `onChange` event that normalizes change events
   * across form elements. This event fires at a time when it's possible to
   * change the element's value without seeing a flicker.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - select
   */
  var ChangeEventPlugin = {

    eventTypes: eventTypes,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

      var getTargetInstFunc, handleEventFunc;
      if (shouldUseChangeEvent(targetNode)) {
        if (doesChangeEventBubble) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else {
          handleEventFunc = handleEventsForChangeEventIE8;
        }
      } else if (isTextInputElement(targetNode)) {
        if (isInputEventSupported) {
          getTargetInstFunc = getTargetInstForInputEvent;
        } else {
          getTargetInstFunc = getTargetInstForInputEventIE;
          handleEventFunc = handleEventsForInputEventIE;
        }
      } else if (shouldUseClickEvent(targetNode)) {
        getTargetInstFunc = getTargetInstForClickEvent;
      }

      if (getTargetInstFunc) {
        var inst = getTargetInstFunc(topLevelType, targetInst);
        if (inst) {
          var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
          event.type = 'change';
          EventPropagators.accumulateTwoPhaseDispatches(event);
          return event;
        }
      }

      if (handleEventFunc) {
        handleEventFunc(topLevelType, targetNode, targetInst);
      }
    }

  };

  module.exports = ChangeEventPlugin;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DefaultEventPluginOrder.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Module that is injectable into `EventPluginHub`, that specifies a
   * deterministic ordering of `EventPlugin`s. A convenient way to reason about
   * plugins, without having to package every one of them. This is better than
   * having plugins be ordered in the same order that they are injected because
   * that ordering would be influenced by the packaging order.
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
   * preventing default on events is convenient in `SimpleEventPlugin` handlers.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

  module.exports = DefaultEventPluginOrder;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/EnterLeaveEventPlugin.js', ['./EventPropagators', './ReactDOMComponentTree', './SyntheticMouseEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('./EventPropagators');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');

  var eventTypes = {
    mouseEnter: {
      registrationName: 'onMouseEnter',
      dependencies: ['topMouseOut', 'topMouseOver']
    },
    mouseLeave: {
      registrationName: 'onMouseLeave',
      dependencies: ['topMouseOut', 'topMouseOver']
    }
  };

  var EnterLeaveEventPlugin = {

    eventTypes: eventTypes,

    /**
     * For almost every interaction we care about, there will be both a top-level
     * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
     * we do not extract duplicate events. However, moving the mouse into the
     * browser from outside will not fire a `mouseout` event. In this case, we use
     * the `mouseover` top-level event.
     */
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
        // Must not be a mouse in or mouse out - ignoring.
        return null;
      }

      var win;
      if (nativeEventTarget.window === nativeEventTarget) {
        // `nativeEventTarget` is probably a window object.
        win = nativeEventTarget;
      } else {
        // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
        var doc = nativeEventTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }

      var from;
      var to;
      if (topLevelType === 'topMouseOut') {
        from = targetInst;
        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
        to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
      } else {
        // Moving to a node from outside the window.
        from = null;
        to = targetInst;
      }

      if (from === to) {
        // Nothing pertains to our managed components.
        return null;
      }

      var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
      var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = fromNode;
      leave.relatedTarget = toNode;

      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = toNode;
      enter.relatedTarget = fromNode;

      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

      return [leave, enter];
    }

  };

  module.exports = EnterLeaveEventPlugin;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/HTMLDOMPropertyConfig.js', ['./DOMProperty', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');

  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
    Properties: {
      /**
       * Standard Properties
       */
      accept: 0,
      acceptCharset: 0,
      accessKey: 0,
      action: 0,
      allowFullScreen: HAS_BOOLEAN_VALUE,
      allowTransparency: 0,
      alt: 0,
      // specifies target context for links with `preload` type
      as: 0,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: 0,
      // autoFocus is polyfilled/normalized by AutoFocusUtils
      // autoFocus: HAS_BOOLEAN_VALUE,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: HAS_BOOLEAN_VALUE,
      cellPadding: 0,
      cellSpacing: 0,
      charSet: 0,
      challenge: 0,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      cite: 0,
      classID: 0,
      className: 0,
      cols: HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: 0,
      content: 0,
      contentEditable: 0,
      contextMenu: 0,
      controls: HAS_BOOLEAN_VALUE,
      coords: 0,
      crossOrigin: 0,
      data: 0, // For `<object />` acts as `src`.
      dateTime: 0,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      dir: 0,
      disabled: HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: 0,
      encType: 0,
      form: 0,
      formAction: 0,
      formEncType: 0,
      formMethod: 0,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: 0,
      frameBorder: 0,
      headers: 0,
      height: 0,
      hidden: HAS_BOOLEAN_VALUE,
      high: 0,
      href: 0,
      hrefLang: 0,
      htmlFor: 0,
      httpEquiv: 0,
      icon: 0,
      id: 0,
      inputMode: 0,
      integrity: 0,
      is: 0,
      keyParams: 0,
      keyType: 0,
      kind: 0,
      label: 0,
      lang: 0,
      list: 0,
      loop: HAS_BOOLEAN_VALUE,
      low: 0,
      manifest: 0,
      marginHeight: 0,
      marginWidth: 0,
      max: 0,
      maxLength: 0,
      media: 0,
      mediaGroup: 0,
      method: 0,
      min: 0,
      minLength: 0,
      // Caution; `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`.
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: 0,
      nonce: 0,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: 0,
      pattern: 0,
      placeholder: 0,
      playsInline: HAS_BOOLEAN_VALUE,
      poster: 0,
      preload: 0,
      profile: 0,
      radioGroup: 0,
      readOnly: HAS_BOOLEAN_VALUE,
      referrerPolicy: 0,
      rel: 0,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      role: 0,
      rows: HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: HAS_NUMERIC_VALUE,
      sandbox: 0,
      scope: 0,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: 0,
      seamless: HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: 0,
      size: HAS_POSITIVE_NUMERIC_VALUE,
      sizes: 0,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: 0,
      src: 0,
      srcDoc: 0,
      srcLang: 0,
      srcSet: 0,
      start: HAS_NUMERIC_VALUE,
      step: 0,
      style: 0,
      summary: 0,
      tabIndex: 0,
      target: 0,
      title: 0,
      // Setting .type throws on non-<input> tags
      type: 0,
      useMap: 0,
      value: 0,
      width: 0,
      wmode: 0,
      wrap: 0,

      /**
       * RDFa Properties
       */
      about: 0,
      datatype: 0,
      inlist: 0,
      prefix: 0,
      // property is also supported for OpenGraph in meta tags.
      property: 0,
      resource: 0,
      'typeof': 0,
      vocab: 0,

      /**
       * Non-standard Properties
       */
      // autoCapitalize and autoCorrect are supported in Mobile Safari for
      // keyboard hints.
      autoCapitalize: 0,
      autoCorrect: 0,
      // autoSave allows WebKit/Blink to persist values of input fields on page reloads
      autoSave: 0,
      // color is for Safari mask-icon link
      color: 0,
      // itemProp, itemScope, itemType are for
      // Microdata support. See http://schema.org/docs/gs.html
      itemProp: 0,
      itemScope: HAS_BOOLEAN_VALUE,
      itemType: 0,
      // itemID and itemRef are for Microdata support as well but
      // only specified in the WHATWG spec document. See
      // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
      itemID: 0,
      itemRef: 0,
      // results show looking glass icon and recent searches on input
      // search fields in WebKit/Blink
      results: 0,
      // IE-only attribute that specifies security restrictions on an iframe
      // as an alternative to the sandbox attribute on IE<10
      security: 0,
      // IE-only attribute that controls focus behavior
      unselectable: 0
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {}
  };

  module.exports = HTMLDOMPropertyConfig;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMIDOperations.js', ['./DOMChildrenOperations', './ReactDOMComponentTree', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');

  /**
   * Operations used to process updates to DOM nodes.
   */
  var ReactDOMIDOperations = {

    /**
     * Updates a component's children by processing a series of updates.
     *
     * @param {array<object>} updates List of update configurations.
     * @internal
     */
    dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
      var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
      DOMChildrenOperations.processUpdates(node, updates);
    }
  };

  module.exports = ReactDOMIDOperations;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactComponentBrowserEnvironment.js', ['./DOMChildrenOperations', './ReactDOMIDOperations', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var ReactDOMIDOperations = $__require('./ReactDOMIDOperations');

  /**
   * Abstracts away all functionality of the reconciler that requires knowledge of
   * the browser context. TODO: These callers should be refactored to avoid the
   * need for this injection.
   */
  var ReactComponentBrowserEnvironment = {

    processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

    replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

  };

  module.exports = ReactComponentBrowserEnvironment;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/AutoFocusUtils.js', ['./ReactDOMComponentTree', 'fbjs/lib/focusNode', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');

  var focusNode = $__require('fbjs/lib/focusNode');

  var AutoFocusUtils = {
    focusDOMComponent: function () {
      focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
    }
  };

  module.exports = AutoFocusUtils;
  return module.exports;
});
System.registerDynamic("npm:fbjs@0.8.6/lib/camelize.js", ["process"], true, function ($__require, exports, module) {
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  var _hyphenPattern = /-(.)/g;

  /**
   * Camelcases a hyphenated string, for example:
   *
   *   > camelize('background-color')
   *   < "backgroundColor"
   *
   * @param {string} string
   * @return {string}
   */
  function camelize(string) {
    return string.replace(_hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }

  module.exports = camelize;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/camelizeStyleName.js', ['./camelize', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var camelize = $__require('./camelize');

  var msPattern = /^-ms-/;

  /**
   * Camelcases a hyphenated CSS property name, for example:
   *
   *   > camelizeStyleName('background-color')
   *   < "backgroundColor"
   *   > camelizeStyleName('-moz-transition')
   *   < "MozTransition"
   *   > camelizeStyleName('-ms-transition')
   *   < "msTransition"
   *
   * As Andi Smith suggests
   * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
   * is converted to lowercase `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }

  module.exports = camelizeStyleName;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/CSSProperty.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * CSS properties which accept numbers but are not in units of "px".
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridColumn: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,

    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

  // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
  // infinite loop, because it iterates over the newly added props too.
  Object.keys(isUnitlessNumber).forEach(function (prop) {
    prefixes.forEach(function (prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });

  /**
   * Most style properties can be unset by doing .style[prop] = '' but IE8
   * doesn't like doing that with shorthand properties so for the properties that
   * IE8 breaks on, which are listed here, we instead unset each of the
   * individual properties. See http://bugs.jquery.com/ticket/12385.
   * The 4-value 'clock' properties like margin, padding, border-width seem to
   * behave without any problems. Curiously, list-style works too without any
   * special prodding.
   */
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };

  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };

  module.exports = CSSProperty;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/dangerousStyleValue.js', ['./CSSProperty', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var CSSProperty = $__require('./CSSProperty');
  var warning = $__require('fbjs/lib/warning');

  var isUnitlessNumber = CSSProperty.isUnitlessNumber;
  var styleWarnings = {};

  /**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @param {ReactDOMComponent} component
   * @return {string} Normalized style value with dimensions applied.
   */
  function dangerousStyleValue(name, value, component) {
    // Note that we've removed escapeTextForBrowser() calls here since the
    // whole string will be escaped when the attribute is injected into
    // the markup. If you provide unsafe user data here they can inject
    // arbitrary CSS which may be problematic (I couldn't repro this):
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
    // This is not an XSS hole but instead a potential CSS injection issue
    // which has lead to a greater discussion about how we're going to
    // trust URLs moving forward. See #2115901

    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }

    var isNonNumeric = isNaN(value);
    if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
      return '' + value; // cast to string
    }

    if (typeof value === 'string') {
      if ('production' !== 'production') {
        // Allow '0' to pass through without warning. 0 is already special and
        // doesn't require units, so we don't need to warn about it.
        if (component && value !== '0') {
          var owner = component._currentElement._owner;
          var ownerName = owner ? owner.getName() : null;
          if (ownerName && !styleWarnings[ownerName]) {
            styleWarnings[ownerName] = {};
          }
          var warned = false;
          if (ownerName) {
            var warnings = styleWarnings[ownerName];
            warned = warnings[name];
            if (!warned) {
              warnings[name] = true;
            }
          }
          if (!warned) {
            'production' !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
          }
        }
      }
      value = value.trim();
    }
    return value + 'px';
  }

  module.exports = dangerousStyleValue;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/hyphenate.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _uppercasePattern = /([A-Z])/g;

  /**
   * Hyphenates a camelcased string, for example:
   *
   *   > hyphenate('backgroundColor')
   *   < "background-color"
   *
   * For CSS style names, use `hyphenateStyleName` instead which works properly
   * with all vendor prefixes, including `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }

  module.exports = hyphenate;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/hyphenateStyleName.js', ['./hyphenate', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var hyphenate = $__require('./hyphenate');

  var msPattern = /^ms-/;

  /**
   * Hyphenates a camelcased CSS property name, for example:
   *
   *   > hyphenateStyleName('backgroundColor')
   *   < "background-color"
   *   > hyphenateStyleName('MozTransition')
   *   < "-moz-transition"
   *   > hyphenateStyleName('msTransition')
   *   < "-ms-transition"
   *
   * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
   * is converted to `-ms-`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }

  module.exports = hyphenateStyleName;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/memoizeStringOnly.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   * @typechecks static-only
   */

  'use strict';

  /**
   * Memoizes the return value of a function that accepts one string argument.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function memoizeStringOnly(callback) {
    var cache = {};
    return function (string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }

  module.exports = memoizeStringOnly;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/CSSPropertyOperations.js', ['./CSSProperty', 'fbjs/lib/ExecutionEnvironment', './ReactInstrumentation', 'fbjs/lib/camelizeStyleName', './dangerousStyleValue', 'fbjs/lib/hyphenateStyleName', 'fbjs/lib/memoizeStringOnly', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var CSSProperty = $__require('./CSSProperty');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactInstrumentation = $__require('./ReactInstrumentation');

  var camelizeStyleName = $__require('fbjs/lib/camelizeStyleName');
  var dangerousStyleValue = $__require('./dangerousStyleValue');
  var hyphenateStyleName = $__require('fbjs/lib/hyphenateStyleName');
  var memoizeStringOnly = $__require('fbjs/lib/memoizeStringOnly');
  var warning = $__require('fbjs/lib/warning');

  var processStyleName = memoizeStringOnly(function (styleName) {
    return hyphenateStyleName(styleName);
  });

  var hasShorthandPropertyBug = false;
  var styleFloatAccessor = 'cssFloat';
  if (ExecutionEnvironment.canUseDOM) {
    var tempStyle = document.createElement('div').style;
    try {
      // IE8 throws "Invalid argument." if resetting shorthand style properties.
      tempStyle.font = '';
    } catch (e) {
      hasShorthandPropertyBug = true;
    }
    // IE8 only supports accessing cssFloat (standard) as styleFloat
    if (document.documentElement.style.cssFloat === undefined) {
      styleFloatAccessor = 'styleFloat';
    }
  }

  if ('production' !== 'production') {
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

    // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;

    var warnedStyleNames = {};
    var warnedStyleValues = {};
    var warnedForNaNValue = false;

    var warnHyphenatedStyleName = function (name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }

      warnedStyleNames[name] = true;
      'production' !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
    };

    var warnBadVendoredStyleName = function (name, owner) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }

      warnedStyleNames[name] = true;
      'production' !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
    };

    var warnStyleValueWithSemicolon = function (name, value, owner) {
      if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
        return;
      }

      warnedStyleValues[value] = true;
      'production' !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
    };

    var warnStyleValueIsNaN = function (name, value, owner) {
      if (warnedForNaNValue) {
        return;
      }

      warnedForNaNValue = true;
      'production' !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
    };

    var checkRenderMessage = function (owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    };

    /**
     * @param {string} name
     * @param {*} value
     * @param {ReactDOMComponent} component
     */
    var warnValidStyle = function (name, value, component) {
      var owner;
      if (component) {
        owner = component._currentElement._owner;
      }
      if (name.indexOf('-') > -1) {
        warnHyphenatedStyleName(name, owner);
      } else if (badVendoredStyleNamePattern.test(name)) {
        warnBadVendoredStyleName(name, owner);
      } else if (badStyleValueWithSemicolonPattern.test(value)) {
        warnStyleValueWithSemicolon(name, value, owner);
      }

      if (typeof value === 'number' && isNaN(value)) {
        warnStyleValueIsNaN(name, value, owner);
      }
    };
  }

  /**
   * Operations for dealing with CSS properties.
   */
  var CSSPropertyOperations = {

    /**
     * Serializes a mapping of style properties for use as inline styles:
     *
     *   > createMarkupForStyles({width: '200px', height: 0})
     *   "width:200px;height:0;"
     *
     * Undefined values are ignored so that declarative programming is easier.
     * The result should be HTML-escaped before insertion into the DOM.
     *
     * @param {object} styles
     * @param {ReactDOMComponent} component
     * @return {?string}
     */
    createMarkupForStyles: function (styles, component) {
      var serialized = '';
      for (var styleName in styles) {
        if (!styles.hasOwnProperty(styleName)) {
          continue;
        }
        var styleValue = styles[styleName];
        if ('production' !== 'production') {
          warnValidStyle(styleName, styleValue, component);
        }
        if (styleValue != null) {
          serialized += processStyleName(styleName) + ':';
          serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
        }
      }
      return serialized || null;
    },

    /**
     * Sets the value for multiple styles on a node.  If a value is specified as
     * '' (empty string), the corresponding style property will be unset.
     *
     * @param {DOMElement} node
     * @param {object} styles
     * @param {ReactDOMComponent} component
     */
    setValueForStyles: function (node, styles, component) {
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: component._debugID,
          type: 'update styles',
          payload: styles
        });
      }

      var style = node.style;
      for (var styleName in styles) {
        if (!styles.hasOwnProperty(styleName)) {
          continue;
        }
        if ('production' !== 'production') {
          warnValidStyle(styleName, styles[styleName], component);
        }
        var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
        if (styleName === 'float' || styleName === 'cssFloat') {
          styleName = styleFloatAccessor;
        }
        if (styleValue) {
          style[styleName] = styleValue;
        } else {
          var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
          if (expansion) {
            // Shorthand property that IE8 won't like unsetting, so unset each
            // component to placate it
            for (var individualStyleName in expansion) {
              style[individualStyleName] = '';
            }
          } else {
            style[styleName] = '';
          }
        }
      }
    }

  };

  module.exports = CSSPropertyOperations;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/quoteAttributeValueForBrowser.js', ['./escapeTextContentForBrowser', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');

  /**
   * Escapes attribute value to prevent scripting attacks.
   *
   * @param {*} value Value to escape.
   * @return {string} An escaped string.
   */
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }

  module.exports = quoteAttributeValueForBrowser;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DOMPropertyOperations.js', ['./DOMProperty', './ReactDOMComponentTree', './ReactInstrumentation', './quoteAttributeValueForBrowser', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstrumentation = $__require('./ReactInstrumentation');

  var quoteAttributeValueForBrowser = $__require('./quoteAttributeValueForBrowser');
  var warning = $__require('fbjs/lib/warning');

  var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
  var illegalAttributeNameCache = {};
  var validatedAttributeNameCache = {};

  function isAttributeNameSafe(attributeName) {
    if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
      return true;
    }
    if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
      return false;
    }
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
      validatedAttributeNameCache[attributeName] = true;
      return true;
    }
    illegalAttributeNameCache[attributeName] = true;
    'production' !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
    return false;
  }

  function shouldIgnoreValue(propertyInfo, value) {
    return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
  }

  /**
   * Operations for dealing with DOM properties.
   */
  var DOMPropertyOperations = {

    /**
     * Creates markup for the ID property.
     *
     * @param {string} id Unescaped ID.
     * @return {string} Markup string.
     */
    createMarkupForID: function (id) {
      return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
    },

    setAttributeForID: function (node, id) {
      node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
    },

    createMarkupForRoot: function () {
      return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
    },

    setAttributeForRoot: function (node) {
      node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
    },

    /**
     * Creates markup for a property.
     *
     * @param {string} name
     * @param {*} value
     * @return {?string} Markup string, or null if the property was invalid.
     */
    createMarkupForProperty: function (name, value) {
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        if (shouldIgnoreValue(propertyInfo, value)) {
          return '';
        }
        var attributeName = propertyInfo.attributeName;
        if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          return attributeName + '=""';
        }
        return attributeName + '=' + quoteAttributeValueForBrowser(value);
      } else if (DOMProperty.isCustomAttribute(name)) {
        if (value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      }
      return null;
    },

    /**
     * Creates markup for a custom property.
     *
     * @param {string} name
     * @param {*} value
     * @return {string} Markup string, or empty string if the property was invalid.
     */
    createMarkupForCustomAttribute: function (name, value) {
      if (!isAttributeNameSafe(name) || value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    },

    /**
     * Sets the value for a property on a node.
     *
     * @param {DOMElement} node
     * @param {string} name
     * @param {*} value
     */
    setValueForProperty: function (node, name, value) {
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        var mutationMethod = propertyInfo.mutationMethod;
        if (mutationMethod) {
          mutationMethod(node, value);
        } else if (shouldIgnoreValue(propertyInfo, value)) {
          this.deleteValueForProperty(node, name);
          return;
        } else if (propertyInfo.mustUseProperty) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propertyInfo.propertyName] = value;
        } else {
          var attributeName = propertyInfo.attributeName;
          var namespace = propertyInfo.attributeNamespace;
          // `setAttribute` with objects becomes only `[object]` in IE8/9,
          // ('' + value) makes it output the correct toString()-value.
          if (namespace) {
            node.setAttributeNS(namespace, attributeName, '' + value);
          } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            node.setAttribute(attributeName, '');
          } else {
            node.setAttribute(attributeName, '' + value);
          }
        }
      } else if (DOMProperty.isCustomAttribute(name)) {
        DOMPropertyOperations.setValueForAttribute(node, name, value);
        return;
      }

      if ('production' !== 'production') {
        var payload = {};
        payload[name] = value;
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
          type: 'update attribute',
          payload: payload
        });
      }
    },

    setValueForAttribute: function (node, name, value) {
      if (!isAttributeNameSafe(name)) {
        return;
      }
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }

      if ('production' !== 'production') {
        var payload = {};
        payload[name] = value;
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
          type: 'update attribute',
          payload: payload
        });
      }
    },

    /**
     * Deletes an attributes from a node.
     *
     * @param {DOMElement} node
     * @param {string} name
     */
    deleteValueForAttribute: function (node, name) {
      node.removeAttribute(name);
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
          type: 'remove attribute',
          payload: name
        });
      }
    },

    /**
     * Deletes the value for a property on a node.
     *
     * @param {DOMElement} node
     * @param {string} name
     */
    deleteValueForProperty: function (node, name) {
      var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
      if (propertyInfo) {
        var mutationMethod = propertyInfo.mutationMethod;
        if (mutationMethod) {
          mutationMethod(node, undefined);
        } else if (propertyInfo.mustUseProperty) {
          var propName = propertyInfo.propertyName;
          if (propertyInfo.hasBooleanValue) {
            node[propName] = false;
          } else {
            node[propName] = '';
          }
        } else {
          node.removeAttribute(propertyInfo.attributeName);
        }
      } else if (DOMProperty.isCustomAttribute(name)) {
        node.removeAttribute(name);
      }

      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
          type: 'remove attribute',
          payload: name
        });
      }
    }

  };

  module.exports = DOMPropertyOperations;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMInput.js', ['./reactProdInvariant', 'object-assign', './DOMPropertyOperations', './LinkedValueUtils', './ReactDOMComponentTree', './ReactUpdates', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var DOMPropertyOperations = $__require('./DOMPropertyOperations');
  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var didWarnValueLink = false;
  var didWarnCheckedLink = false;
  var didWarnValueDefaultValue = false;
  var didWarnCheckedDefaultChecked = false;
  var didWarnControlledToUncontrolled = false;
  var didWarnUncontrolledToControlled = false;

  function forceUpdateIfMounted() {
    if (this._rootNodeID) {
      // DOM component is still mounted; update
      ReactDOMInput.updateWrapper(this);
    }
  }

  function isControlled(props) {
    var usesChecked = props.type === 'checkbox' || props.type === 'radio';
    return usesChecked ? props.checked != null : props.value != null;
  }

  /**
   * Implements an <input> host component that allows setting these optional
   * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
   *
   * If `checked` or `value` are not supplied (or null/undefined), user actions
   * that affect the checked state or value will trigger updates to the element.
   *
   * If they are supplied (and not null/undefined), the rendered element will not
   * trigger updates to the element. Instead, the props must change in order for
   * the rendered element to be updated.
   *
   * The rendered element will be initialized as unchecked (or `defaultChecked`)
   * with an empty value (or `defaultValue`).
   *
   * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
   */
  var ReactDOMInput = {
    getHostProps: function (inst, props) {
      var value = LinkedValueUtils.getValue(props);
      var checked = LinkedValueUtils.getChecked(props);

      var hostProps = _assign({
        // Make sure we set .type before any other properties (setting .value
        // before .type means .value is lost in IE11 and below)
        type: undefined,
        // Make sure we set .step before .value (setting .value before .step
        // means .value is rounded on mount, based upon step precision)
        step: undefined,
        // Make sure we set .min & .max before .value (to ensure proper order
        // in corner cases such as min or max deriving from value, e.g. Issue #7170)
        min: undefined,
        max: undefined
      }, props, {
        defaultChecked: undefined,
        defaultValue: undefined,
        value: value != null ? value : inst._wrapperState.initialValue,
        checked: checked != null ? checked : inst._wrapperState.initialChecked,
        onChange: inst._wrapperState.onChange
      });

      return hostProps;
    },

    mountWrapper: function (inst, props) {
      if ('production' !== 'production') {
        LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

        var owner = inst._currentElement._owner;

        if (props.valueLink !== undefined && !didWarnValueLink) {
          'production' !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnValueLink = true;
        }
        if (props.checkedLink !== undefined && !didWarnCheckedLink) {
          'production' !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnCheckedLink = true;
        }
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
          'production' !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnCheckedDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
          'production' !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnValueDefaultValue = true;
        }
      }

      var defaultValue = props.defaultValue;
      inst._wrapperState = {
        initialChecked: props.checked != null ? props.checked : props.defaultChecked,
        initialValue: props.value != null ? props.value : defaultValue,
        listeners: null,
        onChange: _handleChange.bind(inst)
      };

      if ('production' !== 'production') {
        inst._wrapperState.controlled = isControlled(props);
      }
    },

    updateWrapper: function (inst) {
      var props = inst._currentElement.props;

      if ('production' !== 'production') {
        var controlled = isControlled(props);
        var owner = inst._currentElement._owner;

        if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
          'production' !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnUncontrolledToControlled = true;
        }
        if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
          'production' !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
          didWarnControlledToUncontrolled = true;
        }
      }

      // TODO: Shouldn't this be getChecked(props)?
      var checked = props.checked;
      if (checked != null) {
        DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
      }

      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {

        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        var newValue = '' + value;

        // To avoid side effects (such as losing text selection), only set value if changed
        if (newValue !== node.value) {
          node.value = newValue;
        }
      } else {
        if (props.value == null && props.defaultValue != null) {
          node.defaultValue = '' + props.defaultValue;
        }
        if (props.checked == null && props.defaultChecked != null) {
          node.defaultChecked = !!props.defaultChecked;
        }
      }
    },

    postMountWrapper: function (inst) {
      var props = inst._currentElement.props;

      // This is in postMount because we need access to the DOM node, which is not
      // available until after the component has mounted.
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);

      // Detach value from defaultValue. We won't do anything if we're working on
      // submit or reset inputs as those values & defaultValues are linked. They
      // are not resetable nodes so this operation doesn't matter and actually
      // removes browser-default values (eg "Submit Query") when no value is
      // provided.

      switch (props.type) {
        case 'submit':
        case 'reset':
          break;
        case 'color':
        case 'date':
        case 'datetime':
        case 'datetime-local':
        case 'month':
        case 'time':
        case 'week':
          // This fixes the no-show issue on iOS Safari and Android Chrome:
          // https://github.com/facebook/react/issues/7233
          node.value = '';
          node.value = node.defaultValue;
          break;
        default:
          node.value = node.value;
          break;
      }

      // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
      // this is needed to work around a chrome bug where setting defaultChecked
      // will sometimes influence the value of checked (even after detachment).
      // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
      // We need to temporarily unset name to avoid disrupting radio button groups.
      var name = node.name;
      if (name !== '') {
        node.name = '';
      }
      node.defaultChecked = !node.defaultChecked;
      node.defaultChecked = !node.defaultChecked;
      if (name !== '') {
        node.name = name;
      }
    }
  };

  function _handleChange(event) {
    var props = this._currentElement.props;

    var returnValue = LinkedValueUtils.executeOnChange(props, event);

    // Here we use asap to wait until all updates have propagated, which
    // is important when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    ReactUpdates.asap(forceUpdateIfMounted, this);

    var name = props.name;
    if (props.type === 'radio' && name != null) {
      var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0; i < group.length; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
          continue;
        }
        // This will throw if radio buttons rendered by different copies of React
        // and the same name are rendered into the same form (same as #1939).
        // That's probably okay; we don't support it just as we don't support
        // mixing React radio buttons with non-React ones.
        var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
        !otherInstance ? 'production' !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
        // If this is a controlled radio button group, forcing the input that
        // was previously checked to update will cause it to be come re-checked
        // as appropriate.
        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
      }
    }

    return returnValue;
  }

  module.exports = ReactDOMInput;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMOption.js', ['object-assign', 'react/lib/React', './ReactDOMComponentTree', './ReactDOMSelect', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var React = $__require('react/lib/React');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMSelect = $__require('./ReactDOMSelect');

  var warning = $__require('fbjs/lib/warning');
  var didWarnInvalidOptionChildren = false;

  function flattenChildren(children) {
    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    React.Children.forEach(children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else if (!didWarnInvalidOptionChildren) {
        didWarnInvalidOptionChildren = true;
        'production' !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
      }
    });

    return content;
  }

  /**
   * Implements an <option> host component that warns when `selected` is set.
   */
  var ReactDOMOption = {
    mountWrapper: function (inst, props, hostParent) {
      // TODO (yungsters): Remove support for `selected` in <option>.
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
      }

      // Look up whether this option is 'selected'
      var selectValue = null;
      if (hostParent != null) {
        var selectParent = hostParent;

        if (selectParent._tag === 'optgroup') {
          selectParent = selectParent._hostParent;
        }

        if (selectParent != null && selectParent._tag === 'select') {
          selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
        }
      }

      // If the value is null (e.g., no specified value or after initial mount)
      // or missing (e.g., for <datalist>), we don't change props.selected
      var selected = null;
      if (selectValue != null) {
        var value;
        if (props.value != null) {
          value = props.value + '';
        } else {
          value = flattenChildren(props.children);
        }
        selected = false;
        if (Array.isArray(selectValue)) {
          // multiple
          for (var i = 0; i < selectValue.length; i++) {
            if ('' + selectValue[i] === value) {
              selected = true;
              break;
            }
          }
        } else {
          selected = '' + selectValue === value;
        }
      }

      inst._wrapperState = { selected: selected };
    },

    postMountWrapper: function (inst) {
      // value="" should make a value attribute (#6219)
      var props = inst._currentElement.props;
      if (props.value != null) {
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        node.setAttribute('value', props.value);
      }
    },

    getHostProps: function (inst, props) {
      var hostProps = _assign({ selected: undefined, children: undefined }, props);

      // Read state only from initial mount because <select> updates value
      // manually; we need the initial state only for server rendering
      if (inst._wrapperState.selected != null) {
        hostProps.selected = inst._wrapperState.selected;
      }

      var content = flattenChildren(props.children);

      if (content) {
        hostProps.children = content;
      }

      return hostProps;
    }

  };

  module.exports = ReactDOMOption;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMSelect.js', ['object-assign', './LinkedValueUtils', './ReactDOMComponentTree', './ReactUpdates', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');

  var warning = $__require('fbjs/lib/warning');

  var didWarnValueLink = false;
  var didWarnValueDefaultValue = false;

  function updateOptionsIfPendingUpdateAndMounted() {
    if (this._rootNodeID && this._wrapperState.pendingUpdate) {
      this._wrapperState.pendingUpdate = false;

      var props = this._currentElement.props;
      var value = LinkedValueUtils.getValue(props);

      if (value != null) {
        updateOptions(this, Boolean(props.multiple), value);
      }
    }
  }

  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }

  var valuePropNames = ['value', 'defaultValue'];

  /**
   * Validation function for `value` and `defaultValue`.
   * @private
   */
  function checkSelectPropTypes(inst, props) {
    var owner = inst._currentElement._owner;
    LinkedValueUtils.checkPropTypes('select', props, owner);

    if (props.valueLink !== undefined && !didWarnValueLink) {
      'production' !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
      didWarnValueLink = true;
    }

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];
      if (props[propName] == null) {
        continue;
      }
      var isArray = Array.isArray(props[propName]);
      if (props.multiple && !isArray) {
        'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
      } else if (!props.multiple && isArray) {
        'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
      }
    }
  }

  /**
   * @param {ReactDOMComponent} inst
   * @param {boolean} multiple
   * @param {*} propValue A stringable (with `multiple`, a list of stringables).
   * @private
   */
  function updateOptions(inst, multiple, propValue) {
    var selectedValue, i;
    var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

    if (multiple) {
      selectedValue = {};
      for (i = 0; i < propValue.length; i++) {
        selectedValue['' + propValue[i]] = true;
      }
      for (i = 0; i < options.length; i++) {
        var selected = selectedValue.hasOwnProperty(options[i].value);
        if (options[i].selected !== selected) {
          options[i].selected = selected;
        }
      }
    } else {
      // Do not set `select.value` as exact behavior isn't consistent across all
      // browsers for all cases.
      selectedValue = '' + propValue;
      for (i = 0; i < options.length; i++) {
        if (options[i].value === selectedValue) {
          options[i].selected = true;
          return;
        }
      }
      if (options.length) {
        options[0].selected = true;
      }
    }
  }

  /**
   * Implements a <select> host component that allows optionally setting the
   * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
   * stringable. If `multiple` is true, the prop must be an array of stringables.
   *
   * If `value` is not supplied (or null/undefined), user actions that change the
   * selected option will trigger updates to the rendered options.
   *
   * If it is supplied (and not null/undefined), the rendered options will not
   * update in response to user actions. Instead, the `value` prop must change in
   * order for the rendered options to update.
   *
   * If `defaultValue` is provided, any options with the supplied values will be
   * selected.
   */
  var ReactDOMSelect = {
    getHostProps: function (inst, props) {
      return _assign({}, props, {
        onChange: inst._wrapperState.onChange,
        value: undefined
      });
    },

    mountWrapper: function (inst, props) {
      if ('production' !== 'production') {
        checkSelectPropTypes(inst, props);
      }

      var value = LinkedValueUtils.getValue(props);
      inst._wrapperState = {
        pendingUpdate: false,
        initialValue: value != null ? value : props.defaultValue,
        listeners: null,
        onChange: _handleChange.bind(inst),
        wasMultiple: Boolean(props.multiple)
      };

      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        'production' !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValueDefaultValue = true;
      }
    },

    getSelectValueContext: function (inst) {
      // ReactDOMOption looks at this initial value so the initial generated
      // markup has correct `selected` attributes
      return inst._wrapperState.initialValue;
    },

    postUpdateWrapper: function (inst) {
      var props = inst._currentElement.props;

      // After the initial mount, we control selected-ness manually so don't pass
      // this value down
      inst._wrapperState.initialValue = undefined;

      var wasMultiple = inst._wrapperState.wasMultiple;
      inst._wrapperState.wasMultiple = Boolean(props.multiple);

      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        inst._wrapperState.pendingUpdate = false;
        updateOptions(inst, Boolean(props.multiple), value);
      } else if (wasMultiple !== Boolean(props.multiple)) {
        // For simplicity, reapply `defaultValue` if `multiple` is toggled.
        if (props.defaultValue != null) {
          updateOptions(inst, Boolean(props.multiple), props.defaultValue);
        } else {
          // Revert the select back to its default unselected state.
          updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
        }
      }
    }
  };

  function _handleChange(event) {
    var props = this._currentElement.props;
    var returnValue = LinkedValueUtils.executeOnChange(props, event);

    if (this._rootNodeID) {
      this._wrapperState.pendingUpdate = true;
    }
    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
    return returnValue;
  }

  module.exports = ReactDOMSelect;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/LinkedValueUtils.js', ['./reactProdInvariant', 'react/lib/React', './ReactPropTypesSecret', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var React = $__require('react/lib/React');
  var ReactPropTypesSecret = $__require('./ReactPropTypesSecret');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var hasReadOnlyValue = {
    'button': true,
    'checkbox': true,
    'image': true,
    'hidden': true,
    'radio': true,
    'reset': true,
    'submit': true
  };

  function _assertSingleLink(inputProps) {
    !(inputProps.checkedLink == null || inputProps.valueLink == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
  }
  function _assertValueLink(inputProps) {
    _assertSingleLink(inputProps);
    !(inputProps.value == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
  }

  function _assertCheckedLink(inputProps) {
    _assertSingleLink(inputProps);
    !(inputProps.checked == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
  }

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    onChange: React.PropTypes.func
  };

  var loggedTypeFailures = {};
  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  var LinkedValueUtils = {
    checkPropTypes: function (tagName, props, owner) {
      for (var propName in propTypes) {
        if (propTypes.hasOwnProperty(propName)) {
          var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var addendum = getDeclarationErrorAddendum(owner);
          'production' !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
        }
      }
    },

    /**
     * @param {object} inputProps Props for form component
     * @return {*} current value of the input either from value prop or link.
     */
    getValue: function (inputProps) {
      if (inputProps.valueLink) {
        _assertValueLink(inputProps);
        return inputProps.valueLink.value;
      }
      return inputProps.value;
    },

    /**
     * @param {object} inputProps Props for form component
     * @return {*} current checked status of the input either from checked prop
     *             or link.
     */
    getChecked: function (inputProps) {
      if (inputProps.checkedLink) {
        _assertCheckedLink(inputProps);
        return inputProps.checkedLink.value;
      }
      return inputProps.checked;
    },

    /**
     * @param {object} inputProps Props for form component
     * @param {SyntheticEvent} event change event to handle
     */
    executeOnChange: function (inputProps, event) {
      if (inputProps.valueLink) {
        _assertValueLink(inputProps);
        return inputProps.valueLink.requestChange(event.target.value);
      } else if (inputProps.checkedLink) {
        _assertCheckedLink(inputProps);
        return inputProps.checkedLink.requestChange(event.target.checked);
      } else if (inputProps.onChange) {
        return inputProps.onChange.call(undefined, event);
      }
    }
  };

  module.exports = LinkedValueUtils;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMTextarea.js', ['./reactProdInvariant', 'object-assign', './LinkedValueUtils', './ReactDOMComponentTree', './ReactUpdates', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var LinkedValueUtils = $__require('./LinkedValueUtils');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var didWarnValueLink = false;
  var didWarnValDefaultVal = false;

  function forceUpdateIfMounted() {
    if (this._rootNodeID) {
      // DOM component is still mounted; update
      ReactDOMTextarea.updateWrapper(this);
    }
  }

  /**
   * Implements a <textarea> host component that allows setting `value`, and
   * `defaultValue`. This differs from the traditional DOM API because value is
   * usually set as PCDATA children.
   *
   * If `value` is not supplied (or null/undefined), user actions that affect the
   * value will trigger updates to the element.
   *
   * If `value` is supplied (and not null/undefined), the rendered element will
   * not trigger updates to the element. Instead, the `value` prop must change in
   * order for the rendered element to be updated.
   *
   * The rendered element will be initialized with an empty value, the prop
   * `defaultValue` if specified, or the children content (deprecated).
   */
  var ReactDOMTextarea = {
    getHostProps: function (inst, props) {
      !(props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

      // Always set children to the same thing. In IE9, the selection range will
      // get reset if `textContent` is mutated.  We could add a check in setTextContent
      // to only set the value if/when the value differs from the node value (which would
      // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
      // The value can be a boolean or object so that's why it's forced to be a string.
      var hostProps = _assign({}, props, {
        value: undefined,
        defaultValue: undefined,
        children: '' + inst._wrapperState.initialValue,
        onChange: inst._wrapperState.onChange
      });

      return hostProps;
    },

    mountWrapper: function (inst, props) {
      if ('production' !== 'production') {
        LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
        if (props.valueLink !== undefined && !didWarnValueLink) {
          'production' !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
          didWarnValueLink = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
          'production' !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
          didWarnValDefaultVal = true;
        }
      }

      var value = LinkedValueUtils.getValue(props);
      var initialValue = value;

      // Only bother fetching default value if we're going to use it
      if (value == null) {
        var defaultValue = props.defaultValue;
        // TODO (yungsters): Remove support for children content in <textarea>.
        var children = props.children;
        if (children != null) {
          if ('production' !== 'production') {
            'production' !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
          }
          !(defaultValue == null) ? 'production' !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
          if (Array.isArray(children)) {
            !(children.length <= 1) ? 'production' !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
            children = children[0];
          }

          defaultValue = '' + children;
        }
        if (defaultValue == null) {
          defaultValue = '';
        }
        initialValue = defaultValue;
      }

      inst._wrapperState = {
        initialValue: '' + initialValue,
        listeners: null,
        onChange: _handleChange.bind(inst)
      };
    },

    updateWrapper: function (inst) {
      var props = inst._currentElement.props;

      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      var value = LinkedValueUtils.getValue(props);
      if (value != null) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        var newValue = '' + value;

        // To avoid side effects (such as losing text selection), only set value if changed
        if (newValue !== node.value) {
          node.value = newValue;
        }
        if (props.defaultValue == null) {
          node.defaultValue = newValue;
        }
      }
      if (props.defaultValue != null) {
        node.defaultValue = props.defaultValue;
      }
    },

    postMountWrapper: function (inst) {
      // This is in postMount because we need access to the DOM node, which is not
      // available until after the component has mounted.
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);

      // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
      node.value = node.textContent; // Detach value from defaultValue
    }
  };

  function _handleChange(event) {
    var props = this._currentElement.props;
    var returnValue = LinkedValueUtils.executeOnChange(props, event);
    ReactUpdates.asap(forceUpdateIfMounted, this);
    return returnValue;
  }

  module.exports = ReactDOMTextarea;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactChildReconciler.js', ['./ReactReconciler', './instantiateReactComponent', './KeyEscapeUtils', './shouldUpdateReactComponent', './traverseAllChildren', 'fbjs/lib/warning', 'react/lib/ReactComponentTreeHook', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactReconciler = $__require('./ReactReconciler');

  var instantiateReactComponent = $__require('./instantiateReactComponent');
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var traverseAllChildren = $__require('./traverseAllChildren');
  var warning = $__require('fbjs/lib/warning');

  var ReactComponentTreeHook;

  if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
    // Temporary hack.
    // Inline requires don't work well with Jest:
    // https://github.com/facebook/react/issues/7240
    // Remove the inline requires when we don't need them anymore:
    // https://github.com/facebook/react/pull/7178
    ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
  }

  function instantiateChild(childInstances, child, name, selfDebugID) {
    // We found a component instance.
    var keyUnique = childInstances[name] === undefined;
    if ('production' !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
      }
      if (!keyUnique) {
        'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (child != null && keyUnique) {
      childInstances[name] = instantiateReactComponent(child, true);
    }
  }

  /**
   * ReactChildReconciler provides helpers for initializing or updating a set of
   * children. Its output is suitable for passing it onto ReactMultiChild which
   * does diffed reordering and insertion.
   */
  var ReactChildReconciler = {
    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildNodes Nested child maps.
     * @return {?object} A set of child instances.
     * @internal
     */
    instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
    ) {
      if (nestedChildNodes == null) {
        return null;
      }
      var childInstances = {};

      if ('production' !== 'production') {
        traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
          return instantiateChild(childInsts, child, name, selfDebugID);
        }, childInstances);
      } else {
        traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
      }
      return childInstances;
    },

    /**
     * Updates the rendered children and returns a new set of children.
     *
     * @param {?object} prevChildren Previously initialized set of children.
     * @param {?object} nextChildren Flat child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @param {object} context
     * @return {?object} A new set of child instances.
     * @internal
     */
    updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
    ) {
      // We currently don't have a way to track moves here but if we use iterators
      // instead of for..in we can zip the iterators and check if an item has
      // moved.
      // TODO: If nothing has changed, return the prevChildren object so that we
      // can quickly bailout if nothing has changed.
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      var prevChild;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        prevChild = prevChildren && prevChildren[name];
        var prevElement = prevChild && prevChild._currentElement;
        var nextElement = nextChildren[name];
        if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
          ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
          nextChildren[name] = prevChild;
        } else {
          if (prevChild) {
            removedNodes[name] = ReactReconciler.getHostNode(prevChild);
            ReactReconciler.unmountComponent(prevChild, false);
          }
          // The child must be instantiated before it's mounted.
          var nextChildInstance = instantiateReactComponent(nextElement, true);
          nextChildren[name] = nextChildInstance;
          // Creating mount image now ensures refs are resolved in right order
          // (see https://github.com/facebook/react/pull/7101 for explanation).
          var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
          mountImages.push(nextChildMountImage);
        }
      }
      // Unmount children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          prevChild = prevChildren[name];
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @param {?object} renderedChildren Previously initialized set of children.
     * @internal
     */
    unmountChildren: function (renderedChildren, safely) {
      for (var name in renderedChildren) {
        if (renderedChildren.hasOwnProperty(name)) {
          var renderedChild = renderedChildren[name];
          ReactReconciler.unmountComponent(renderedChild, safely);
        }
      }
    }

  };

  module.exports = ReactChildReconciler;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactElementSymbol.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getIteratorFn.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/KeyEscapeUtils.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/traverseAllChildren.js', ['./reactProdInvariant', 'react/lib/ReactCurrentOwner', './ReactElementSymbol', './getIteratorFn', 'fbjs/lib/invariant', './KeyEscapeUtils', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var REACT_ELEMENT_TYPE = $__require('./ReactElementSymbol');

  var getIteratorFn = $__require('./getIteratorFn');
  var invariant = $__require('fbjs/lib/invariant');
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var warning = $__require('fbjs/lib/warning');

  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';

  /**
   * This is inlined from ReactElement since this file is shared between
   * isomorphic and renderers. We could extract this to a
   *
   */

  /**
   * TODO: Test that a single child and an array with one item have the same key
   * pattern.
   */

  var didWarnAboutMaps = false;

  /**
   * Generate a key string that identifies a component within a set.
   *
   * @param {*} component A component that could contain a manual key.
   * @param {number} index Index that is used if a manual key is not provided.
   * @return {string}
   */
  function getComponentKey(component, index) {
    // Do some typechecking here since we call this blindly. We want to ensure
    // that we don't block potential future ES APIs.
    if (component && typeof component === 'object' && component.key != null) {
      // Explicit key
      return KeyEscapeUtils.escape(component.key);
    }
    // Implicit key determined by the index in the set
    return index.toString(36);
  }

  /**
   * @param {?*} children Children tree container.
   * @param {!string} nameSoFar Name of the key path so far.
   * @param {!function} callback Callback to invoke with each child found.
   * @param {?*} traverseContext Used to pass information throughout the traversal
   * process.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
    var type = typeof children;

    if (type === 'undefined' || type === 'boolean') {
      // All of the above are perceived as null.
      children = null;
    }

    if (children === null || type === 'string' || type === 'number' ||
    // The following is inlined from ReactElement. This means we can optimize
    // some checks. React Fiber also inlines this logic for similar purposes.
    type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
      callback(traverseContext, children,
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows.
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
      return 1;
    }

    var child;
    var nextName;
    var subtreeCount = 0; // Count of children found in the current subtree.
    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        nextName = nextNamePrefix + getComponentKey(child, i);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else {
      var iteratorFn = getIteratorFn(children);
      if (iteratorFn) {
        var iterator = iteratorFn.call(children);
        var step;
        if (iteratorFn !== children.entries) {
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          if ('production' !== 'production') {
            var mapsAsChildrenAddendum = '';
            if (ReactCurrentOwner.current) {
              var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
              if (mapsAsChildrenOwnerName) {
                mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
              }
            }
            'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
            didWarnAboutMaps = true;
          }
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              child = entry[1];
              nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          }
        }
      } else if (type === 'object') {
        var addendum = '';
        if ('production' !== 'production') {
          addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
          if (children._isReactElement) {
            addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
          }
          if (ReactCurrentOwner.current) {
            var name = ReactCurrentOwner.current.getName();
            if (name) {
              addendum += ' Check the render method of `' + name + '`.';
            }
          }
        }
        var childrenString = String(children);
        !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
      }
    }

    return subtreeCount;
  }

  /**
   * Traverses children that are typically specified as `props.children`, but
   * might also be specified through attributes:
   *
   * - `traverseAllChildren(this.props.children, ...)`
   * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
   *
   * The `traverseContext` is an optional argument that is passed through the
   * entire traversal. It can be used to store accumulations or anything else that
   * the callback might find relevant.
   *
   * @param {?*} children Children tree object.
   * @param {!function} callback To invoke upon traversing each child.
   * @param {?*} traverseContext Context for traversal.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildren(children, callback, traverseContext) {
    if (children == null) {
      return 0;
    }

    return traverseAllChildrenImpl(children, '', callback, traverseContext);
  }

  module.exports = traverseAllChildren;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/flattenChildren.js', ['./KeyEscapeUtils', './traverseAllChildren', 'fbjs/lib/warning', 'react/lib/ReactComponentTreeHook', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var traverseAllChildren = $__require('./traverseAllChildren');
  var warning = $__require('fbjs/lib/warning');

  var ReactComponentTreeHook;

  if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
    // Temporary hack.
    // Inline requires don't work well with Jest:
    // https://github.com/facebook/react/issues/7240
    // Remove the inline requires when we don't need them anymore:
    // https://github.com/facebook/react/pull/7178
    ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
  }

  /**
   * @param {function} traverseContext Context passed through traversal.
   * @param {?ReactComponent} child React child component.
   * @param {!string} name String name of key path to child.
   * @param {number=} selfDebugID Optional debugID of the current internal instance.
   */
  function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
    // We found a component instance.
    if (traverseContext && typeof traverseContext === 'object') {
      var result = traverseContext;
      var keyUnique = result[name] === undefined;
      if ('production' !== 'production') {
        if (!ReactComponentTreeHook) {
          ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
        }
        if (!keyUnique) {
          'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
        }
      }
      if (keyUnique && child != null) {
        result[name] = child;
      }
    }
  }

  /**
   * Flattens children that are typically specified as `props.children`. Any null
   * children will not be included in the resulting object.
   * @return {!object} flattened children keyed by name.
   */
  function flattenChildren(children, selfDebugID) {
    if (children == null) {
      return children;
    }
    var result = {};

    if ('production' !== 'production') {
      traverseAllChildren(children, function (traverseContext, child, name) {
        return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
      }, result);
    } else {
      traverseAllChildren(children, flattenSingleChildIntoContext, result);
    }
    return result;
  }

  module.exports = flattenChildren;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactMultiChild.js', ['./reactProdInvariant', './ReactComponentEnvironment', './ReactInstanceMap', './ReactInstrumentation', 'react/lib/ReactCurrentOwner', './ReactReconciler', './ReactChildReconciler', 'fbjs/lib/emptyFunction', './flattenChildren', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');

  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactChildReconciler = $__require('./ReactChildReconciler');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var flattenChildren = $__require('./flattenChildren');
  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Make an update for markup to be rendered and inserted at a supplied index.
   *
   * @param {string} markup Markup that renders into an element.
   * @param {number} toIndex Destination index.
   * @private
   */
  function makeInsertMarkup(markup, afterNode, toIndex) {
    // NOTE: Null values reduce hidden classes.
    return {
      type: 'INSERT_MARKUP',
      content: markup,
      fromIndex: null,
      fromNode: null,
      toIndex: toIndex,
      afterNode: afterNode
    };
  }

  /**
   * Make an update for moving an existing element to another index.
   *
   * @param {number} fromIndex Source index of the existing element.
   * @param {number} toIndex Destination index of the element.
   * @private
   */
  function makeMove(child, afterNode, toIndex) {
    // NOTE: Null values reduce hidden classes.
    return {
      type: 'MOVE_EXISTING',
      content: null,
      fromIndex: child._mountIndex,
      fromNode: ReactReconciler.getHostNode(child),
      toIndex: toIndex,
      afterNode: afterNode
    };
  }

  /**
   * Make an update for removing an element at an index.
   *
   * @param {number} fromIndex Index of the element to remove.
   * @private
   */
  function makeRemove(child, node) {
    // NOTE: Null values reduce hidden classes.
    return {
      type: 'REMOVE_NODE',
      content: null,
      fromIndex: child._mountIndex,
      fromNode: node,
      toIndex: null,
      afterNode: null
    };
  }

  /**
   * Make an update for setting the markup of a node.
   *
   * @param {string} markup Markup that renders into an element.
   * @private
   */
  function makeSetMarkup(markup) {
    // NOTE: Null values reduce hidden classes.
    return {
      type: 'SET_MARKUP',
      content: markup,
      fromIndex: null,
      fromNode: null,
      toIndex: null,
      afterNode: null
    };
  }

  /**
   * Make an update for setting the text content.
   *
   * @param {string} textContent Text content to set.
   * @private
   */
  function makeTextContent(textContent) {
    // NOTE: Null values reduce hidden classes.
    return {
      type: 'TEXT_CONTENT',
      content: textContent,
      fromIndex: null,
      fromNode: null,
      toIndex: null,
      afterNode: null
    };
  }

  /**
   * Push an update, if any, onto the queue. Creates a new queue if none is
   * passed and always returns the queue. Mutative.
   */
  function enqueue(queue, update) {
    if (update) {
      queue = queue || [];
      queue.push(update);
    }
    return queue;
  }

  /**
   * Processes any enqueued updates.
   *
   * @private
   */
  function processQueue(inst, updateQueue) {
    ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
  }

  var setChildrenForInstrumentation = emptyFunction;
  if ('production' !== 'production') {
    var getDebugID = function (inst) {
      if (!inst._debugID) {
        // Check for ART-like instances. TODO: This is silly/gross.
        var internal;
        if (internal = ReactInstanceMap.get(inst)) {
          inst = internal;
        }
      }
      return inst._debugID;
    };
    setChildrenForInstrumentation = function (children) {
      var debugID = getDebugID(this);
      // TODO: React Native empty components are also multichild.
      // This means they still get into this method but don't have _debugID.
      if (debugID !== 0) {
        ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
          return children[key]._debugID;
        }) : []);
      }
    };
  }

  /**
   * ReactMultiChild are capable of reconciling multiple children.
   *
   * @class ReactMultiChild
   * @internal
   */
  var ReactMultiChild = {

    /**
     * Provides common functionality for components that must reconcile multiple
     * children. This is used by `ReactDOMComponent` to mount, update, and
     * unmount child components.
     *
     * @lends {ReactMultiChild.prototype}
     */
    Mixin: {

      _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
        if ('production' !== 'production') {
          var selfDebugID = getDebugID(this);
          if (this._currentElement) {
            try {
              ReactCurrentOwner.current = this._currentElement._owner;
              return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
            } finally {
              ReactCurrentOwner.current = null;
            }
          }
        }
        return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
      },

      _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
        var nextChildren;
        var selfDebugID = 0;
        if ('production' !== 'production') {
          selfDebugID = getDebugID(this);
          if (this._currentElement) {
            try {
              ReactCurrentOwner.current = this._currentElement._owner;
              nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
            } finally {
              ReactCurrentOwner.current = null;
            }
            ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
            return nextChildren;
          }
        }
        nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
        ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
        return nextChildren;
      },

      /**
       * Generates a "mount image" for each of the supplied children. In the case
       * of `ReactDOMComponent`, a mount image is a string of markup.
       *
       * @param {?object} nestedChildren Nested child maps.
       * @return {array} An array of mounted representations.
       * @internal
       */
      mountChildren: function (nestedChildren, transaction, context) {
        var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
        this._renderedChildren = children;

        var mountImages = [];
        var index = 0;
        for (var name in children) {
          if (children.hasOwnProperty(name)) {
            var child = children[name];
            var selfDebugID = 0;
            if ('production' !== 'production') {
              selfDebugID = getDebugID(this);
            }
            var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
            child._mountIndex = index++;
            mountImages.push(mountImage);
          }
        }

        if ('production' !== 'production') {
          setChildrenForInstrumentation.call(this, children);
        }

        return mountImages;
      },

      /**
       * Replaces any rendered children with a text content string.
       *
       * @param {string} nextContent String of content.
       * @internal
       */
      updateTextContent: function (nextContent) {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren, false);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
          }
        }
        // Set new text content.
        var updates = [makeTextContent(nextContent)];
        processQueue(this, updates);
      },

      /**
       * Replaces any rendered children with a markup string.
       *
       * @param {string} nextMarkup String of markup.
       * @internal
       */
      updateMarkup: function (nextMarkup) {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren, false);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
          }
        }
        var updates = [makeSetMarkup(nextMarkup)];
        processQueue(this, updates);
      },

      /**
       * Updates the rendered children with new children.
       *
       * @param {?object} nextNestedChildrenElements Nested child element maps.
       * @param {ReactReconcileTransaction} transaction
       * @internal
       */
      updateChildren: function (nextNestedChildrenElements, transaction, context) {
        // Hook used by React ART
        this._updateChildren(nextNestedChildrenElements, transaction, context);
      },

      /**
       * @param {?object} nextNestedChildrenElements Nested child element maps.
       * @param {ReactReconcileTransaction} transaction
       * @final
       * @protected
       */
      _updateChildren: function (nextNestedChildrenElements, transaction, context) {
        var prevChildren = this._renderedChildren;
        var removedNodes = {};
        var mountImages = [];
        var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
        if (!nextChildren && !prevChildren) {
          return;
        }
        var updates = null;
        var name;
        // `nextIndex` will increment for each child in `nextChildren`, but
        // `lastIndex` will be the last index visited in `prevChildren`.
        var nextIndex = 0;
        var lastIndex = 0;
        // `nextMountIndex` will increment for each newly mounted child.
        var nextMountIndex = 0;
        var lastPlacedNode = null;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          var prevChild = prevChildren && prevChildren[name];
          var nextChild = nextChildren[name];
          if (prevChild === nextChild) {
            updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            prevChild._mountIndex = nextIndex;
          } else {
            if (prevChild) {
              // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              // The `removedNodes` loop below will actually remove the child.
            }
            // The child must be instantiated before it's mounted.
            updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
            nextMountIndex++;
          }
          nextIndex++;
          lastPlacedNode = ReactReconciler.getHostNode(nextChild);
        }
        // Remove children that are no longer present.
        for (name in removedNodes) {
          if (removedNodes.hasOwnProperty(name)) {
            updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
          }
        }
        if (updates) {
          processQueue(this, updates);
        }
        this._renderedChildren = nextChildren;

        if ('production' !== 'production') {
          setChildrenForInstrumentation.call(this, nextChildren);
        }
      },

      /**
       * Unmounts all rendered children. This should be used to clean up children
       * when this component is unmounted. It does not actually perform any
       * backend operations.
       *
       * @internal
       */
      unmountChildren: function (safely) {
        var renderedChildren = this._renderedChildren;
        ReactChildReconciler.unmountChildren(renderedChildren, safely);
        this._renderedChildren = null;
      },

      /**
       * Moves a child component to the supplied index.
       *
       * @param {ReactComponent} child Component to move.
       * @param {number} toIndex Destination index of the element.
       * @param {number} lastIndex Last index visited of the siblings of `child`.
       * @protected
       */
      moveChild: function (child, afterNode, toIndex, lastIndex) {
        // If the index of `child` is less than `lastIndex`, then it needs to
        // be moved. Otherwise, we do not need to move it because a child will be
        // inserted or moved before `child`.
        if (child._mountIndex < lastIndex) {
          return makeMove(child, afterNode, toIndex);
        }
      },

      /**
       * Creates a child component.
       *
       * @param {ReactComponent} child Component to create.
       * @param {string} mountImage Markup to insert.
       * @protected
       */
      createChild: function (child, afterNode, mountImage) {
        return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
      },

      /**
       * Removes a child component.
       *
       * @param {ReactComponent} child Child to remove.
       * @protected
       */
      removeChild: function (child, node) {
        return makeRemove(child, node);
      },

      /**
       * Mounts a child with the supplied name.
       *
       * NOTE: This is part of `updateChildren` and is here for readability.
       *
       * @param {ReactComponent} child Component to mount.
       * @param {string} name Name of the child.
       * @param {number} index Index at which to insert the child.
       * @param {ReactReconcileTransaction} transaction
       * @private
       */
      _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
        child._mountIndex = index;
        return this.createChild(child, afterNode, mountImage);
      },

      /**
       * Unmounts a rendered child.
       *
       * NOTE: This is part of `updateChildren` and is here for readability.
       *
       * @param {ReactComponent} child Component to unmount.
       * @private
       */
      _unmountChild: function (child, node) {
        var update = this.removeChild(child, node);
        child._mountIndex = null;
        return update;
      }

    }

  };

  module.exports = ReactMultiChild;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactServerUpdateQueue.js', ['./ReactUpdateQueue', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var ReactUpdateQueue = $__require('./ReactUpdateQueue');

  var warning = $__require('fbjs/lib/warning');

  function warnNoop(publicInstance, callerName) {
    if ('production' !== 'production') {
      var constructor = publicInstance.constructor;
      'production' !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
    }
  }

  /**
   * This is the update queue used for server rendering.
   * It delegates to ReactUpdateQueue while server rendering is in progress and
   * switches to ReactNoopUpdateQueue after the transaction has completed.
   * @class ReactServerUpdateQueue
   * @param {Transaction} transaction
   */

  var ReactServerUpdateQueue = function () {
    function ReactServerUpdateQueue(transaction) {
      _classCallCheck(this, ReactServerUpdateQueue);

      this.transaction = transaction;
    }

    /**
     * Checks whether or not this composite component is mounted.
     * @param {ReactClass} publicInstance The instance we want to test.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */

    ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
      return false;
    };

    /**
     * Enqueue a callback that will be executed after all the pending updates
     * have processed.
     *
     * @param {ReactClass} publicInstance The instance to use as `this` context.
     * @param {?function} callback Called after state is updated.
     * @internal
     */

    ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
      }
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @internal
     */

    ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueForceUpdate(publicInstance);
      } else {
        warnNoop(publicInstance, 'forceUpdate');
      }
    };

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object|function} completeState Next state.
     * @internal
     */

    ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
      } else {
        warnNoop(publicInstance, 'replaceState');
      }
    };

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object|function} partialState Next partial state to be merged with state.
     * @internal
     */

    ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
      if (this.transaction.isInTransaction()) {
        ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
      } else {
        warnNoop(publicInstance, 'setState');
      }
    };

    return ReactServerUpdateQueue;
  }();

  module.exports = ReactServerUpdateQueue;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactServerRenderingTransaction.js', ['object-assign', './PooledClass', './Transaction', './ReactInstrumentation', './ReactServerUpdateQueue', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var PooledClass = $__require('./PooledClass');
  var Transaction = $__require('./Transaction');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactServerUpdateQueue = $__require('./ReactServerUpdateQueue');

  /**
   * Executed within the scope of the `Transaction` instance. Consider these as
   * being member methods, but with an implied ordering while being isolated from
   * each other.
   */
  var TRANSACTION_WRAPPERS = [];

  if ('production' !== 'production') {
    TRANSACTION_WRAPPERS.push({
      initialize: ReactInstrumentation.debugTool.onBeginFlush,
      close: ReactInstrumentation.debugTool.onEndFlush
    });
  }

  var noopCallbackQueue = {
    enqueue: function () {}
  };

  /**
   * @class ReactServerRenderingTransaction
   * @param {boolean} renderToStaticMarkup
   */
  function ReactServerRenderingTransaction(renderToStaticMarkup) {
    this.reinitializeTransaction();
    this.renderToStaticMarkup = renderToStaticMarkup;
    this.useCreateElement = false;
    this.updateQueue = new ReactServerUpdateQueue(this);
  }

  var Mixin = {
    /**
     * @see Transaction
     * @abstract
     * @final
     * @return {array} Empty list of operation wrap procedures.
     */
    getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    },

    /**
     * @return {object} The queue to collect `onDOMReady` callbacks with.
     */
    getReactMountReady: function () {
      return noopCallbackQueue;
    },

    /**
     * @return {object} The queue to collect React async events.
     */
    getUpdateQueue: function () {
      return this.updateQueue;
    },

    /**
     * `PooledClass` looks for this, and will invoke this before allowing this
     * instance to be reused.
     */
    destructor: function () {},

    checkpoint: function () {},

    rollback: function () {}
  };

  _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

  PooledClass.addPoolingTo(ReactServerRenderingTransaction);

  module.exports = ReactServerRenderingTransaction;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMComponent.js', ['./reactProdInvariant', 'object-assign', './AutoFocusUtils', './CSSPropertyOperations', './DOMLazyTree', './DOMNamespaces', './DOMProperty', './DOMPropertyOperations', './EventPluginHub', './EventPluginRegistry', './ReactBrowserEventEmitter', './ReactDOMComponentFlags', './ReactDOMComponentTree', './ReactDOMInput', './ReactDOMOption', './ReactDOMSelect', './ReactDOMTextarea', './ReactInstrumentation', './ReactMultiChild', './ReactServerRenderingTransaction', 'fbjs/lib/emptyFunction', './escapeTextContentForBrowser', 'fbjs/lib/invariant', './isEventSupported', 'fbjs/lib/shallowEqual', './validateDOMNesting', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /* global hasOwnProperty:true */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var AutoFocusUtils = $__require('./AutoFocusUtils');
  var CSSPropertyOperations = $__require('./CSSPropertyOperations');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var DOMNamespaces = $__require('./DOMNamespaces');
  var DOMProperty = $__require('./DOMProperty');
  var DOMPropertyOperations = $__require('./DOMPropertyOperations');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactDOMComponentFlags = $__require('./ReactDOMComponentFlags');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMInput = $__require('./ReactDOMInput');
  var ReactDOMOption = $__require('./ReactDOMOption');
  var ReactDOMSelect = $__require('./ReactDOMSelect');
  var ReactDOMTextarea = $__require('./ReactDOMTextarea');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactMultiChild = $__require('./ReactMultiChild');
  var ReactServerRenderingTransaction = $__require('./ReactServerRenderingTransaction');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var invariant = $__require('fbjs/lib/invariant');
  var isEventSupported = $__require('./isEventSupported');
  var shallowEqual = $__require('fbjs/lib/shallowEqual');
  var validateDOMNesting = $__require('./validateDOMNesting');
  var warning = $__require('fbjs/lib/warning');

  var Flags = ReactDOMComponentFlags;
  var deleteListener = EventPluginHub.deleteListener;
  var getNode = ReactDOMComponentTree.getNodeFromInstance;
  var listenTo = ReactBrowserEventEmitter.listenTo;
  var registrationNameModules = EventPluginRegistry.registrationNameModules;

  // For quickly matching children type, to test if can be treated as content.
  var CONTENT_TYPES = { 'string': true, 'number': true };

  var STYLE = 'style';
  var HTML = '__html';
  var RESERVED_PROPS = {
    children: null,
    dangerouslySetInnerHTML: null,
    suppressContentEditableWarning: null
  };

  // Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
  var DOC_FRAGMENT_TYPE = 11;

  function getDeclarationErrorAddendum(internalInstance) {
    if (internalInstance) {
      var owner = internalInstance._currentElement._owner || null;
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' This DOM node was rendered by `' + name + '`.';
        }
      }
    }
    return '';
  }

  function friendlyStringify(obj) {
    if (typeof obj === 'object') {
      if (Array.isArray(obj)) {
        return '[' + obj.map(friendlyStringify).join(', ') + ']';
      } else {
        var pairs = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
            pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
          }
        }
        return '{' + pairs.join(', ') + '}';
      }
    } else if (typeof obj === 'string') {
      return JSON.stringify(obj);
    } else if (typeof obj === 'function') {
      return '[function object]';
    }
    // Differs from JSON.stringify in that undefined because undefined and that
    // inf and nan don't become null
    return String(obj);
  }

  var styleMutationWarning = {};

  function checkAndWarnForMutatedStyle(style1, style2, component) {
    if (style1 == null || style2 == null) {
      return;
    }
    if (shallowEqual(style1, style2)) {
      return;
    }

    var componentName = component._tag;
    var owner = component._currentElement._owner;
    var ownerName;
    if (owner) {
      ownerName = owner.getName();
    }

    var hash = ownerName + '|' + componentName;

    if (styleMutationWarning.hasOwnProperty(hash)) {
      return;
    }

    styleMutationWarning[hash] = true;

    'production' !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
  }

  /**
   * @param {object} component
   * @param {?object} props
   */
  function assertValidProps(component, props) {
    if (!props) {
      return;
    }
    // Note the use of `==` which checks for null or undefined.
    if (voidElementTags[component._tag]) {
      !(props.children == null && props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
    }
    if (props.dangerouslySetInnerHTML != null) {
      !(props.children == null) ? 'production' !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
      !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? 'production' !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
    }
    if ('production' !== 'production') {
      'production' !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
      'production' !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
      'production' !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
    }
    !(props.style == null || typeof props.style === 'object') ? 'production' !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
  }

  function enqueuePutListener(inst, registrationName, listener, transaction) {
    if (transaction instanceof ReactServerRenderingTransaction) {
      return;
    }
    if ('production' !== 'production') {
      // IE8 has no API for event capturing and the `onScroll` event doesn't
      // bubble.
      'production' !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
    }
    var containerInfo = inst._hostContainerInfo;
    var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
    var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
    listenTo(registrationName, doc);
    transaction.getReactMountReady().enqueue(putListener, {
      inst: inst,
      registrationName: registrationName,
      listener: listener
    });
  }

  function putListener() {
    var listenerToPut = this;
    EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
  }

  function inputPostMount() {
    var inst = this;
    ReactDOMInput.postMountWrapper(inst);
  }

  function textareaPostMount() {
    var inst = this;
    ReactDOMTextarea.postMountWrapper(inst);
  }

  function optionPostMount() {
    var inst = this;
    ReactDOMOption.postMountWrapper(inst);
  }

  var setAndValidateContentChildDev = emptyFunction;
  if ('production' !== 'production') {
    setAndValidateContentChildDev = function (content) {
      var hasExistingContent = this._contentDebugID != null;
      var debugID = this._debugID;
      // This ID represents the inlined child that has no backing instance:
      var contentDebugID = -debugID;

      if (content == null) {
        if (hasExistingContent) {
          ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
        }
        this._contentDebugID = null;
        return;
      }

      validateDOMNesting(null, String(content), this, this._ancestorInfo);
      this._contentDebugID = contentDebugID;
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
        ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
      } else {
        ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
        ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
        ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
      }
    };
  }

  // There are so many media events, it makes sense to just
  // maintain a list rather than create a `trapBubbledEvent` for each
  var mediaEvents = {
    topAbort: 'abort',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topLoadedData: 'loadeddata',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTimeUpdate: 'timeupdate',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting'
  };

  function trapBubbledEventsLocal() {
    var inst = this;
    // If a component renders to null or if another component fatals and causes
    // the state of the tree to be corrupted, `node` here can be null.
    !inst._rootNodeID ? 'production' !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
    var node = getNode(inst);
    !node ? 'production' !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

    switch (inst._tag) {
      case 'iframe':
      case 'object':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
        break;
      case 'video':
      case 'audio':

        inst._wrapperState.listeners = [];
        // Create listener for each media event
        for (var event in mediaEvents) {
          if (mediaEvents.hasOwnProperty(event)) {
            inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
          }
        }
        break;
      case 'source':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
        break;
      case 'img':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
        break;
      case 'form':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
        break;
      case 'input':
      case 'select':
      case 'textarea':
        inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
        break;
    }
  }

  function postUpdateSelectWrapper() {
    ReactDOMSelect.postUpdateWrapper(this);
  }

  // For HTML, certain tags should omit their close tag. We keep a whitelist for
  // those special-case tags.

  var omittedCloseTags = {
    'area': true,
    'base': true,
    'br': true,
    'col': true,
    'embed': true,
    'hr': true,
    'img': true,
    'input': true,
    'keygen': true,
    'link': true,
    'meta': true,
    'param': true,
    'source': true,
    'track': true,
    'wbr': true
  };

  var newlineEatingTags = {
    'listing': true,
    'pre': true,
    'textarea': true
  };

  // For HTML, certain tags cannot have children. This has the same purpose as
  // `omittedCloseTags` except that `menuitem` should still have its closing tag.

  var voidElementTags = _assign({
    'menuitem': true
  }, omittedCloseTags);

  // We accept any tag to be rendered but since this gets injected into arbitrary
  // HTML, we want to make sure that it's a safe tag.
  // http://www.w3.org/TR/REC-xml/#NT-Name

  var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
  var validatedTagCache = {};
  var hasOwnProperty = {}.hasOwnProperty;

  function validateDangerousTag(tag) {
    if (!hasOwnProperty.call(validatedTagCache, tag)) {
      !VALID_TAG_REGEX.test(tag) ? 'production' !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
      validatedTagCache[tag] = true;
    }
  }

  function isCustomComponent(tagName, props) {
    return tagName.indexOf('-') >= 0 || props.is != null;
  }

  var globalIdCounter = 1;

  /**
   * Creates a new React class that is idempotent and capable of containing other
   * React components. It accepts event listeners and DOM properties that are
   * valid according to `DOMProperty`.
   *
   *  - Event listeners: `onClick`, `onMouseDown`, etc.
   *  - DOM properties: `className`, `name`, `title`, etc.
   *
   * The `style` property functions differently from the DOM API. It accepts an
   * object mapping of style properties to values.
   *
   * @constructor ReactDOMComponent
   * @extends ReactMultiChild
   */
  function ReactDOMComponent(element) {
    var tag = element.type;
    validateDangerousTag(tag);
    this._currentElement = element;
    this._tag = tag.toLowerCase();
    this._namespaceURI = null;
    this._renderedChildren = null;
    this._previousStyle = null;
    this._previousStyleCopy = null;
    this._hostNode = null;
    this._hostParent = null;
    this._rootNodeID = 0;
    this._domID = 0;
    this._hostContainerInfo = null;
    this._wrapperState = null;
    this._topLevelWrapper = null;
    this._flags = 0;
    if ('production' !== 'production') {
      this._ancestorInfo = null;
      setAndValidateContentChildDev.call(this, null);
    }
  }

  ReactDOMComponent.displayName = 'ReactDOMComponent';

  ReactDOMComponent.Mixin = {

    /**
     * Generates root tag markup then recurses. This method has side effects and
     * is not idempotent.
     *
     * @internal
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {?ReactDOMComponent} the parent component instance
     * @param {?object} info about the host container
     * @param {object} context
     * @return {string} The computed markup.
     */
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      this._rootNodeID = globalIdCounter++;
      this._domID = hostContainerInfo._idCounter++;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;

      var props = this._currentElement.props;

      switch (this._tag) {
        case 'audio':
        case 'form':
        case 'iframe':
        case 'img':
        case 'link':
        case 'object':
        case 'source':
        case 'video':
          this._wrapperState = {
            listeners: null
          };
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'input':
          ReactDOMInput.mountWrapper(this, props, hostParent);
          props = ReactDOMInput.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'option':
          ReactDOMOption.mountWrapper(this, props, hostParent);
          props = ReactDOMOption.getHostProps(this, props);
          break;
        case 'select':
          ReactDOMSelect.mountWrapper(this, props, hostParent);
          props = ReactDOMSelect.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
        case 'textarea':
          ReactDOMTextarea.mountWrapper(this, props, hostParent);
          props = ReactDOMTextarea.getHostProps(this, props);
          transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
          break;
      }

      assertValidProps(this, props);

      // We create tags in the namespace of their parent container, except HTML
      // tags get no namespace.
      var namespaceURI;
      var parentTag;
      if (hostParent != null) {
        namespaceURI = hostParent._namespaceURI;
        parentTag = hostParent._tag;
      } else if (hostContainerInfo._tag) {
        namespaceURI = hostContainerInfo._namespaceURI;
        parentTag = hostContainerInfo._tag;
      }
      if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
        namespaceURI = DOMNamespaces.html;
      }
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'svg') {
          namespaceURI = DOMNamespaces.svg;
        } else if (this._tag === 'math') {
          namespaceURI = DOMNamespaces.mathml;
        }
      }
      this._namespaceURI = namespaceURI;

      if ('production' !== 'production') {
        var parentInfo;
        if (hostParent != null) {
          parentInfo = hostParent._ancestorInfo;
        } else if (hostContainerInfo._tag) {
          parentInfo = hostContainerInfo._ancestorInfo;
        }
        if (parentInfo) {
          // parentInfo should always be present except for the top-level
          // component when server rendering
          validateDOMNesting(this._tag, null, this, parentInfo);
        }
        this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
      }

      var mountImage;
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var el;
        if (namespaceURI === DOMNamespaces.html) {
          if (this._tag === 'script') {
            // Create the script via .innerHTML so its "parser-inserted" flag is
            // set to true and it does not execute
            var div = ownerDocument.createElement('div');
            var type = this._currentElement.type;
            div.innerHTML = '<' + type + '></' + type + '>';
            el = div.removeChild(div.firstChild);
          } else if (props.is) {
            el = ownerDocument.createElement(this._currentElement.type, props.is);
          } else {
            // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
            // See discussion in https://github.com/facebook/react/pull/6896
            // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
            el = ownerDocument.createElement(this._currentElement.type);
          }
        } else {
          el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
        }
        ReactDOMComponentTree.precacheNode(this, el);
        this._flags |= Flags.hasCachedChildNodes;
        if (!this._hostParent) {
          DOMPropertyOperations.setAttributeForRoot(el);
        }
        this._updateDOMProperties(null, props, transaction);
        var lazyTree = DOMLazyTree(el);
        this._createInitialChildren(transaction, props, context, lazyTree);
        mountImage = lazyTree;
      } else {
        var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
        var tagContent = this._createContentMarkup(transaction, props, context);
        if (!tagContent && omittedCloseTags[this._tag]) {
          mountImage = tagOpen + '/>';
        } else {
          mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
        }
      }

      switch (this._tag) {
        case 'input':
          transaction.getReactMountReady().enqueue(inputPostMount, this);
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'textarea':
          transaction.getReactMountReady().enqueue(textareaPostMount, this);
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'select':
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'button':
          if (props.autoFocus) {
            transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
          }
          break;
        case 'option':
          transaction.getReactMountReady().enqueue(optionPostMount, this);
          break;
      }

      return mountImage;
    },

    /**
     * Creates markup for the open tag and all attributes.
     *
     * This method has side effects because events get registered.
     *
     * Iterating over object properties is faster than iterating over arrays.
     * @see http://jsperf.com/obj-vs-arr-iteration
     *
     * @private
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {object} props
     * @return {string} Markup of opening tag.
     */
    _createOpenTagMarkupAndPutListeners: function (transaction, props) {
      var ret = '<' + this._currentElement.type;

      for (var propKey in props) {
        if (!props.hasOwnProperty(propKey)) {
          continue;
        }
        var propValue = props[propKey];
        if (propValue == null) {
          continue;
        }
        if (registrationNameModules.hasOwnProperty(propKey)) {
          if (propValue) {
            enqueuePutListener(this, propKey, propValue, transaction);
          }
        } else {
          if (propKey === STYLE) {
            if (propValue) {
              if ('production' !== 'production') {
                // See `_updateDOMProperties`. style block
                this._previousStyle = propValue;
              }
              propValue = this._previousStyleCopy = _assign({}, props.style);
            }
            propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
          }
          var markup = null;
          if (this._tag != null && isCustomComponent(this._tag, props)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
            }
          } else {
            markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
          }
          if (markup) {
            ret += ' ' + markup;
          }
        }
      }

      // For static pages, no need to put React ID and checksum. Saves lots of
      // bytes.
      if (transaction.renderToStaticMarkup) {
        return ret;
      }

      if (!this._hostParent) {
        ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
      }
      ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
      return ret;
    },

    /**
     * Creates markup for the content between the tags.
     *
     * @private
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {object} props
     * @param {object} context
     * @return {string} Content markup.
     */
    _createContentMarkup: function (transaction, props, context) {
      var ret = '';

      // Intentional use of != to avoid catching zero/false.
      var innerHTML = props.dangerouslySetInnerHTML;
      if (innerHTML != null) {
        if (innerHTML.__html != null) {
          ret = innerHTML.__html;
        }
      } else {
        var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
        var childrenToUse = contentToUse != null ? null : props.children;
        if (contentToUse != null) {
          // TODO: Validate that text is allowed as a child of this node
          ret = escapeTextContentForBrowser(contentToUse);
          if ('production' !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
        } else if (childrenToUse != null) {
          var mountImages = this.mountChildren(childrenToUse, transaction, context);
          ret = mountImages.join('');
        }
      }
      if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
        // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        return '\n' + ret;
      } else {
        return ret;
      }
    },

    _createInitialChildren: function (transaction, props, context, lazyTree) {
      // Intentional use of != to avoid catching zero/false.
      var innerHTML = props.dangerouslySetInnerHTML;
      if (innerHTML != null) {
        if (innerHTML.__html != null) {
          DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
        }
      } else {
        var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
        var childrenToUse = contentToUse != null ? null : props.children;
        if (contentToUse != null) {
          // TODO: Validate that text is allowed as a child of this node
          if ('production' !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        } else if (childrenToUse != null) {
          var mountImages = this.mountChildren(childrenToUse, transaction, context);
          for (var i = 0; i < mountImages.length; i++) {
            DOMLazyTree.queueChild(lazyTree, mountImages[i]);
          }
        }
      }
    },

    /**
     * Receives a next element and updates the component.
     *
     * @internal
     * @param {ReactElement} nextElement
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {object} context
     */
    receiveComponent: function (nextElement, transaction, context) {
      var prevElement = this._currentElement;
      this._currentElement = nextElement;
      this.updateComponent(transaction, prevElement, nextElement, context);
    },

    /**
     * Updates a DOM component after it has already been allocated and
     * attached to the DOM. Reconciles the root DOM node, then recurses.
     *
     * @param {ReactReconcileTransaction} transaction
     * @param {ReactElement} prevElement
     * @param {ReactElement} nextElement
     * @internal
     * @overridable
     */
    updateComponent: function (transaction, prevElement, nextElement, context) {
      var lastProps = prevElement.props;
      var nextProps = this._currentElement.props;

      switch (this._tag) {
        case 'input':
          lastProps = ReactDOMInput.getHostProps(this, lastProps);
          nextProps = ReactDOMInput.getHostProps(this, nextProps);
          break;
        case 'option':
          lastProps = ReactDOMOption.getHostProps(this, lastProps);
          nextProps = ReactDOMOption.getHostProps(this, nextProps);
          break;
        case 'select':
          lastProps = ReactDOMSelect.getHostProps(this, lastProps);
          nextProps = ReactDOMSelect.getHostProps(this, nextProps);
          break;
        case 'textarea':
          lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
          nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
          break;
      }

      assertValidProps(this, nextProps);
      this._updateDOMProperties(lastProps, nextProps, transaction);
      this._updateDOMChildren(lastProps, nextProps, transaction, context);

      switch (this._tag) {
        case 'input':
          // Update the wrapper around inputs *after* updating props. This has to
          // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
          // raise warnings and prevent the new value from being assigned.
          ReactDOMInput.updateWrapper(this);
          break;
        case 'textarea':
          ReactDOMTextarea.updateWrapper(this);
          break;
        case 'select':
          // <select> value update needs to occur after <option> children
          // reconciliation
          transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
          break;
      }
    },

    /**
     * Reconciles the properties by detecting differences in property values and
     * updating the DOM as necessary. This function is probably the single most
     * critical path for performance optimization.
     *
     * TODO: Benchmark whether checking for changed values in memory actually
     *       improves performance (especially statically positioned elements).
     * TODO: Benchmark the effects of putting this at the top since 99% of props
     *       do not change for a given reconciliation.
     * TODO: Benchmark areas that can be improved with caching.
     *
     * @private
     * @param {object} lastProps
     * @param {object} nextProps
     * @param {?DOMElement} node
     */
    _updateDOMProperties: function (lastProps, nextProps, transaction) {
      var propKey;
      var styleName;
      var styleUpdates;
      for (propKey in lastProps) {
        if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
          continue;
        }
        if (propKey === STYLE) {
          var lastStyle = this._previousStyleCopy;
          for (styleName in lastStyle) {
            if (lastStyle.hasOwnProperty(styleName)) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          this._previousStyleCopy = null;
        } else if (registrationNameModules.hasOwnProperty(propKey)) {
          if (lastProps[propKey]) {
            // Only call deleteListener if there was a listener previously or
            // else willDeleteListener gets called when there wasn't actually a
            // listener (e.g., onClick={null})
            deleteListener(this, propKey);
          }
        } else if (isCustomComponent(this._tag, lastProps)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
          }
        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
          DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
        }
      }
      for (propKey in nextProps) {
        var nextProp = nextProps[propKey];
        var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
        if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
          continue;
        }
        if (propKey === STYLE) {
          if (nextProp) {
            if ('production' !== 'production') {
              checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
              this._previousStyle = nextProp;
            }
            nextProp = this._previousStyleCopy = _assign({}, nextProp);
          } else {
            this._previousStyleCopy = null;
          }
          if (lastProp) {
            // Unset styles on `lastProp` but not on `nextProp`.
            for (styleName in lastProp) {
              if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            // Update styles that changed since `lastProp`.
            for (styleName in nextProp) {
              if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = nextProp[styleName];
              }
            }
          } else {
            // Relies on `updateStylesByID` not mutating `styleUpdates`.
            styleUpdates = nextProp;
          }
        } else if (registrationNameModules.hasOwnProperty(propKey)) {
          if (nextProp) {
            enqueuePutListener(this, propKey, nextProp, transaction);
          } else if (lastProp) {
            deleteListener(this, propKey);
          }
        } else if (isCustomComponent(this._tag, nextProps)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
          }
        } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
          var node = getNode(this);
          // If we're updating to null or undefined, we should remove the property
          // from the DOM node instead of inadvertently setting to a string. This
          // brings us in line with the same behavior we have on initial render.
          if (nextProp != null) {
            DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
          } else {
            DOMPropertyOperations.deleteValueForProperty(node, propKey);
          }
        }
      }
      if (styleUpdates) {
        CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
      }
    },

    /**
     * Reconciles the children with the various properties that affect the
     * children content.
     *
     * @param {object} lastProps
     * @param {object} nextProps
     * @param {ReactReconcileTransaction} transaction
     * @param {object} context
     */
    _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
      var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
      var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

      var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
      var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

      // Note the use of `!=` which checks for null or undefined.
      var lastChildren = lastContent != null ? null : lastProps.children;
      var nextChildren = nextContent != null ? null : nextProps.children;

      // If we're switching from children to content/html or vice versa, remove
      // the old content
      var lastHasContentOrHtml = lastContent != null || lastHtml != null;
      var nextHasContentOrHtml = nextContent != null || nextHtml != null;
      if (lastChildren != null && nextChildren == null) {
        this.updateChildren(null, transaction, context);
      } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
        this.updateTextContent('');
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
        }
      }

      if (nextContent != null) {
        if (lastContent !== nextContent) {
          this.updateTextContent('' + nextContent);
          if ('production' !== 'production') {
            setAndValidateContentChildDev.call(this, nextContent);
          }
        }
      } else if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          this.updateMarkup('' + nextHtml);
        }
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
        }
      } else if (nextChildren != null) {
        if ('production' !== 'production') {
          setAndValidateContentChildDev.call(this, null);
        }

        this.updateChildren(nextChildren, transaction, context);
      }
    },

    getHostNode: function () {
      return getNode(this);
    },

    /**
     * Destroys all event registrations for this instance. Does not remove from
     * the DOM. That must be done by the parent.
     *
     * @internal
     */
    unmountComponent: function (safely) {
      switch (this._tag) {
        case 'audio':
        case 'form':
        case 'iframe':
        case 'img':
        case 'link':
        case 'object':
        case 'source':
        case 'video':
          var listeners = this._wrapperState.listeners;
          if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
              listeners[i].remove();
            }
          }
          break;
        case 'html':
        case 'head':
        case 'body':
          /**
           * Components like <html> <head> and <body> can't be removed or added
           * easily in a cross-browser way, however it's valuable to be able to
           * take advantage of React's reconciliation for styling and <title>
           * management. So we just document it and throw in dangerous cases.
           */
          !false ? 'production' !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
          break;
      }

      this.unmountChildren(safely);
      ReactDOMComponentTree.uncacheNode(this);
      EventPluginHub.deleteAllListeners(this);
      this._rootNodeID = 0;
      this._domID = 0;
      this._wrapperState = null;

      if ('production' !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }
    },

    getPublicInstance: function () {
      return getNode(this);
    }

  };

  _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

  module.exports = ReactDOMComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMEmptyComponent.js', ['object-assign', './DOMLazyTree', './ReactDOMComponentTree', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var DOMLazyTree = $__require('./DOMLazyTree');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');

  var ReactDOMEmptyComponent = function (instantiate) {
    // ReactCompositeComponent uses this:
    this._currentElement = null;
    // ReactDOMComponentTree uses these:
    this._hostNode = null;
    this._hostParent = null;
    this._hostContainerInfo = null;
    this._domID = 0;
  };
  _assign(ReactDOMEmptyComponent.prototype, {
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      var domID = hostContainerInfo._idCounter++;
      this._domID = domID;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;

      var nodeValue = ' react-empty: ' + this._domID + ' ';
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var node = ownerDocument.createComment(nodeValue);
        ReactDOMComponentTree.precacheNode(this, node);
        return DOMLazyTree(node);
      } else {
        if (transaction.renderToStaticMarkup) {
          // Normally we'd insert a comment node, but since this is a situation
          // where React won't take over (static pages), we can simply return
          // nothing.
          return '';
        }
        return '<!--' + nodeValue + '-->';
      }
    },
    receiveComponent: function () {},
    getHostNode: function () {
      return ReactDOMComponentTree.getNodeFromInstance(this);
    },
    unmountComponent: function () {
      ReactDOMComponentTree.uncacheNode(this);
    }
  });

  module.exports = ReactDOMEmptyComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMTreeTraversal.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Return the lowest common ancestor of A and B, or null if they are in
   * different trees.
   */
  function getLowestCommonAncestor(instA, instB) {
    !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
    !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

    var depthA = 0;
    for (var tempA = instA; tempA; tempA = tempA._hostParent) {
      depthA++;
    }
    var depthB = 0;
    for (var tempB = instB; tempB; tempB = tempB._hostParent) {
      depthB++;
    }

    // If A is deeper, crawl up.
    while (depthA - depthB > 0) {
      instA = instA._hostParent;
      depthA--;
    }

    // If B is deeper, crawl up.
    while (depthB - depthA > 0) {
      instB = instB._hostParent;
      depthB--;
    }

    // Walk in lockstep until we find a match.
    var depth = depthA;
    while (depth--) {
      if (instA === instB) {
        return instA;
      }
      instA = instA._hostParent;
      instB = instB._hostParent;
    }
    return null;
  }

  /**
   * Return if A is an ancestor of B.
   */
  function isAncestor(instA, instB) {
    !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
    !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

    while (instB) {
      if (instB === instA) {
        return true;
      }
      instB = instB._hostParent;
    }
    return false;
  }

  /**
   * Return the parent instance of the passed-in instance.
   */
  function getParentInstance(inst) {
    !('_hostNode' in inst) ? 'production' !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

    return inst._hostParent;
  }

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   */
  function traverseTwoPhase(inst, fn, arg) {
    var path = [];
    while (inst) {
      path.push(inst);
      inst = inst._hostParent;
    }
    var i;
    for (i = path.length; i-- > 0;) {
      fn(path[i], 'captured', arg);
    }
    for (i = 0; i < path.length; i++) {
      fn(path[i], 'bubbled', arg);
    }
  }

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * Does not invoke the callback on the nearest common ancestor because nothing
   * "entered" or "left" that element.
   */
  function traverseEnterLeave(from, to, fn, argFrom, argTo) {
    var common = from && to ? getLowestCommonAncestor(from, to) : null;
    var pathFrom = [];
    while (from && from !== common) {
      pathFrom.push(from);
      from = from._hostParent;
    }
    var pathTo = [];
    while (to && to !== common) {
      pathTo.push(to);
      to = to._hostParent;
    }
    var i;
    for (i = 0; i < pathFrom.length; i++) {
      fn(pathFrom[i], 'bubbled', argFrom);
    }
    for (i = pathTo.length; i-- > 0;) {
      fn(pathTo[i], 'captured', argTo);
    }
  }

  module.exports = {
    isAncestor: isAncestor,
    getLowestCommonAncestor: getLowestCommonAncestor,
    getParentInstance: getParentInstance,
    traverseTwoPhase: traverseTwoPhase,
    traverseEnterLeave: traverseEnterLeave
  };
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/createArrayFromMixed.js', ['./invariant', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var invariant = $__require('./invariant');

  /**
   * Convert array-like objects to arrays.
   *
   * This API assumes the caller knows the contents of the data type. For less
   * well defined inputs use createArrayFromMixed.
   *
   * @param {object|function|filelist} obj
   * @return {array}
   */
  function toArray(obj) {
    var length = obj.length;

    // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
    // in old versions of Safari).
    !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? 'production' !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

    !(typeof length === 'number') ? 'production' !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

    !(length === 0 || length - 1 in obj) ? 'production' !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

    !(typeof obj.callee !== 'function') ? 'production' !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

    // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
    // without method will throw during the slice call and skip straight to the
    // fallback.
    if (obj.hasOwnProperty) {
      try {
        return Array.prototype.slice.call(obj);
      } catch (e) {
        // IE < 9 does not support Array#slice on collections objects
      }
    }

    // Fall back to copying key by key. This assumes all keys have a value,
    // so will not preserve sparsely populated inputs.
    var ret = Array(length);
    for (var ii = 0; ii < length; ii++) {
      ret[ii] = obj[ii];
    }
    return ret;
  }

  /**
   * Perform a heuristic test to determine if an object is "array-like".
   *
   *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
   *   Joshu replied: "Mu."
   *
   * This function determines if its argument has "array nature": it returns
   * true if the argument is an actual array, an `arguments' object, or an
   * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
   *
   * It will return false for other array-like objects like Filelist.
   *
   * @param {*} obj
   * @return {boolean}
   */
  function hasArrayNature(obj) {
    return (
      // not null/false
      !!obj && (
      // arrays are objects, NodeLists are functions in Safari
      typeof obj == 'object' || typeof obj == 'function') &&
      // quacks like an array
      'length' in obj &&
      // not window
      !('setInterval' in obj) &&
      // no DOM node should be considered an array-like
      // a 'select' element has 'length' and 'item' properties on IE8
      typeof obj.nodeType != 'number' && (
      // a real array
      Array.isArray(obj) ||
      // arguments
      'callee' in obj ||
      // HTMLCollection/NodeList
      'item' in obj)
    );
  }

  /**
   * Ensure that the argument is an array by wrapping it in an array if it is not.
   * Creates a copy of the argument if it is already an array.
   *
   * This is mostly useful idiomatically:
   *
   *   var createArrayFromMixed = require('createArrayFromMixed');
   *
   *   function takesOneOrMoreThings(things) {
   *     things = createArrayFromMixed(things);
   *     ...
   *   }
   *
   * This allows you to treat `things' as an array, but accept scalars in the API.
   *
   * If you need to convert an array-like object, like `arguments`, into an array
   * use toArray instead.
   *
   * @param {*} obj
   * @return {array}
   */
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }

  module.exports = createArrayFromMixed;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/getMarkupWrap.js', ['./ExecutionEnvironment', './invariant', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /*eslint-disable fb-www/unsafe-html */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var invariant = $__require('./invariant');

  /**
   * Dummy container used to detect which wraps are necessary.
   */
  var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

  /**
   * Some browsers cannot use `innerHTML` to render certain elements standalone,
   * so we wrap them, render the wrapped nodes, then extract the desired node.
   *
   * In IE8, certain elements cannot render alone, so wrap all elements ('*').
   */

  var shouldWrap = {};

  var selectWrap = [1, '<select multiple="true">', '</select>'];
  var tableWrap = [1, '<table>', '</table>'];
  var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

  var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

  var markupWrap = {
    '*': [1, '?<div>', '</div>'],

    'area': [1, '<map>', '</map>'],
    'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    'legend': [1, '<fieldset>', '</fieldset>'],
    'param': [1, '<object>', '</object>'],
    'tr': [2, '<table><tbody>', '</tbody></table>'],

    'optgroup': selectWrap,
    'option': selectWrap,

    'caption': tableWrap,
    'colgroup': tableWrap,
    'tbody': tableWrap,
    'tfoot': tableWrap,
    'thead': tableWrap,

    'td': trWrap,
    'th': trWrap
  };

  // Initialize the SVG elements since we know they'll always need to be wrapped
  // consistently. If they are created inside a <div> they will be initialized in
  // the wrong namespace (and will not display).
  var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
  svgElements.forEach(function (nodeName) {
    markupWrap[nodeName] = svgWrap;
    shouldWrap[nodeName] = true;
  });

  /**
   * Gets the markup wrap configuration for the supplied `nodeName`.
   *
   * NOTE: This lazily detects which wraps are necessary for the current browser.
   *
   * @param {string} nodeName Lowercase `nodeName`.
   * @return {?array} Markup wrap configuration, if applicable.
   */
  function getMarkupWrap(nodeName) {
    !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
    if (!markupWrap.hasOwnProperty(nodeName)) {
      nodeName = '*';
    }
    if (!shouldWrap.hasOwnProperty(nodeName)) {
      if (nodeName === '*') {
        dummyNode.innerHTML = '<link />';
      } else {
        dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
      }
      shouldWrap[nodeName] = !dummyNode.firstChild;
    }
    return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
  }

  module.exports = getMarkupWrap;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/createNodesFromMarkup.js', ['./ExecutionEnvironment', './createArrayFromMixed', './getMarkupWrap', './invariant', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /*eslint-disable fb-www/unsafe-html*/

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var createArrayFromMixed = $__require('./createArrayFromMixed');
  var getMarkupWrap = $__require('./getMarkupWrap');
  var invariant = $__require('./invariant');

  /**
   * Dummy container used to render all markup.
   */
  var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

  /**
   * Pattern used by `getNodeName`.
   */
  var nodeNamePattern = /^\s*<(\w+)/;

  /**
   * Extracts the `nodeName` of the first element in a string of markup.
   *
   * @param {string} markup String of markup.
   * @return {?string} Node name of the supplied markup.
   */
  function getNodeName(markup) {
    var nodeNameMatch = markup.match(nodeNamePattern);
    return nodeNameMatch && nodeNameMatch[1].toLowerCase();
  }

  /**
   * Creates an array containing the nodes rendered from the supplied markup. The
   * optionally supplied `handleScript` function will be invoked once for each
   * <script> element that is rendered. If no `handleScript` function is supplied,
   * an exception is thrown if any <script> elements are rendered.
   *
   * @param {string} markup A string of valid HTML markup.
   * @param {?function} handleScript Invoked once for each rendered <script>.
   * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
   */
  function createNodesFromMarkup(markup, handleScript) {
    var node = dummyNode;
    !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
    var nodeName = getNodeName(markup);

    var wrap = nodeName && getMarkupWrap(nodeName);
    if (wrap) {
      node.innerHTML = wrap[1] + markup + wrap[2];

      var wrapDepth = wrap[0];
      while (wrapDepth--) {
        node = node.lastChild;
      }
    } else {
      node.innerHTML = markup;
    }

    var scripts = node.getElementsByTagName('script');
    if (scripts.length) {
      !handleScript ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
      createArrayFromMixed(scripts).forEach(handleScript);
    }

    var nodes = Array.from(node.childNodes);
    while (node.lastChild) {
      node.removeChild(node.lastChild);
    }
    return nodes;
  }

  module.exports = createNodesFromMarkup;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/Danger.js', ['./reactProdInvariant', './DOMLazyTree', 'fbjs/lib/ExecutionEnvironment', 'fbjs/lib/createNodesFromMarkup', 'fbjs/lib/emptyFunction', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var DOMLazyTree = $__require('./DOMLazyTree');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  var createNodesFromMarkup = $__require('fbjs/lib/createNodesFromMarkup');
  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var invariant = $__require('fbjs/lib/invariant');

  var Danger = {

    /**
     * Replaces a node with a string of markup at its current position within its
     * parent. The markup must render into a single root node.
     *
     * @param {DOMElement} oldChild Child node to replace.
     * @param {string} markup Markup to render in place of the child node.
     * @internal
     */
    dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
      !ExecutionEnvironment.canUseDOM ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
      !markup ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
      !(oldChild.nodeName !== 'HTML') ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

      if (typeof markup === 'string') {
        var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
        oldChild.parentNode.replaceChild(newChild, oldChild);
      } else {
        DOMLazyTree.replaceChildWithTree(oldChild, markup);
      }
    }

  };

  module.exports = Danger;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DOMChildrenOperations.js', ['./DOMLazyTree', './Danger', './ReactDOMComponentTree', './ReactInstrumentation', './createMicrosoftUnsafeLocalFunction', './setInnerHTML', './setTextContent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMLazyTree = $__require('./DOMLazyTree');
  var Danger = $__require('./Danger');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstrumentation = $__require('./ReactInstrumentation');

  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');
  var setInnerHTML = $__require('./setInnerHTML');
  var setTextContent = $__require('./setTextContent');

  function getNodeAfter(parentNode, node) {
    // Special case for text components, which return [open, close] comments
    // from getHostNode.
    if (Array.isArray(node)) {
      node = node[1];
    }
    return node ? node.nextSibling : parentNode.firstChild;
  }

  /**
   * Inserts `childNode` as a child of `parentNode` at the `index`.
   *
   * @param {DOMElement} parentNode Parent node in which to insert.
   * @param {DOMElement} childNode Child node to insert.
   * @param {number} index Index at which to insert the child.
   * @internal
   */
  var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
    // We rely exclusively on `insertBefore(node, null)` instead of also using
    // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
    // we are careful to use `null`.)
    parentNode.insertBefore(childNode, referenceNode);
  });

  function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
    DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
  }

  function moveChild(parentNode, childNode, referenceNode) {
    if (Array.isArray(childNode)) {
      moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
    } else {
      insertChildAt(parentNode, childNode, referenceNode);
    }
  }

  function removeChild(parentNode, childNode) {
    if (Array.isArray(childNode)) {
      var closingComment = childNode[1];
      childNode = childNode[0];
      removeDelimitedText(parentNode, childNode, closingComment);
      parentNode.removeChild(closingComment);
    }
    parentNode.removeChild(childNode);
  }

  function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
    var node = openingComment;
    while (true) {
      var nextNode = node.nextSibling;
      insertChildAt(parentNode, node, referenceNode);
      if (node === closingComment) {
        break;
      }
      node = nextNode;
    }
  }

  function removeDelimitedText(parentNode, startNode, closingComment) {
    while (true) {
      var node = startNode.nextSibling;
      if (node === closingComment) {
        // The closing comment is removed by ReactMultiChild.
        break;
      } else {
        parentNode.removeChild(node);
      }
    }
  }

  function replaceDelimitedText(openingComment, closingComment, stringText) {
    var parentNode = openingComment.parentNode;
    var nodeAfterComment = openingComment.nextSibling;
    if (nodeAfterComment === closingComment) {
      // There are no text nodes between the opening and closing comments; insert
      // a new one if stringText isn't empty.
      if (stringText) {
        insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
      }
    } else {
      if (stringText) {
        // Set the text content of the first node after the opening comment, and
        // remove all following nodes up until the closing comment.
        setTextContent(nodeAfterComment, stringText);
        removeDelimitedText(parentNode, nodeAfterComment, closingComment);
      } else {
        removeDelimitedText(parentNode, openingComment, closingComment);
      }
    }

    if ('production' !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
        type: 'replace text',
        payload: stringText
      });
    }
  }

  var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
  if ('production' !== 'production') {
    dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
      Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
      if (prevInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: prevInstance._debugID,
          type: 'replace with',
          payload: markup.toString()
        });
      } else {
        var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
        if (nextInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: nextInstance._debugID,
            type: 'mount',
            payload: markup.toString()
          });
        }
      }
    };
  }

  /**
   * Operations for updating with DOM children.
   */
  var DOMChildrenOperations = {

    dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

    replaceDelimitedText: replaceDelimitedText,

    /**
     * Updates a component's children by processing a series of updates. The
     * update configurations are each expected to have a `parentNode` property.
     *
     * @param {array<object>} updates List of update configurations.
     * @internal
     */
    processUpdates: function (parentNode, updates) {
      if ('production' !== 'production') {
        var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
      }

      for (var k = 0; k < updates.length; k++) {
        var update = updates[k];
        switch (update.type) {
          case 'INSERT_MARKUP':
            insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
            if ('production' !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation({
                instanceID: parentNodeDebugID,
                type: 'insert child',
                payload: { toIndex: update.toIndex, content: update.content.toString() }
              });
            }
            break;
          case 'MOVE_EXISTING':
            moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
            if ('production' !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation({
                instanceID: parentNodeDebugID,
                type: 'move child',
                payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
              });
            }
            break;
          case 'SET_MARKUP':
            setInnerHTML(parentNode, update.content);
            if ('production' !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation({
                instanceID: parentNodeDebugID,
                type: 'replace children',
                payload: update.content.toString()
              });
            }
            break;
          case 'TEXT_CONTENT':
            setTextContent(parentNode, update.content);
            if ('production' !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation({
                instanceID: parentNodeDebugID,
                type: 'replace text',
                payload: update.content.toString()
              });
            }
            break;
          case 'REMOVE_NODE':
            removeChild(parentNode, update.fromNode);
            if ('production' !== 'production') {
              ReactInstrumentation.debugTool.onHostOperation({
                instanceID: parentNodeDebugID,
                type: 'remove child',
                payload: { fromIndex: update.fromIndex }
              });
            }
            break;
        }
      }
    }

  };

  module.exports = DOMChildrenOperations;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMTextComponent.js', ['./reactProdInvariant', 'object-assign', './DOMChildrenOperations', './DOMLazyTree', './ReactDOMComponentTree', './escapeTextContentForBrowser', 'fbjs/lib/invariant', './validateDOMNesting', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var DOMChildrenOperations = $__require('./DOMChildrenOperations');
  var DOMLazyTree = $__require('./DOMLazyTree');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');

  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var invariant = $__require('fbjs/lib/invariant');
  var validateDOMNesting = $__require('./validateDOMNesting');

  /**
   * Text nodes violate a couple assumptions that React makes about components:
   *
   *  - When mounting text into the DOM, adjacent text nodes are merged.
   *  - Text nodes cannot be assigned a React root ID.
   *
   * This component is used to wrap strings between comment nodes so that they
   * can undergo the same reconciliation that is applied to elements.
   *
   * TODO: Investigate representing React components in the DOM with text nodes.
   *
   * @class ReactDOMTextComponent
   * @extends ReactComponent
   * @internal
   */
  var ReactDOMTextComponent = function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;
    // ReactDOMComponentTree uses these:
    this._hostNode = null;
    this._hostParent = null;

    // Properties
    this._domID = 0;
    this._mountIndex = 0;
    this._closingComment = null;
    this._commentNodes = null;
  };

  _assign(ReactDOMTextComponent.prototype, {

    /**
     * Creates the markup for this text node. This node is not intended to have
     * any features besides containing text content.
     *
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @return {string} Markup for this text node.
     * @internal
     */
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      if ('production' !== 'production') {
        var parentInfo;
        if (hostParent != null) {
          parentInfo = hostParent._ancestorInfo;
        } else if (hostContainerInfo != null) {
          parentInfo = hostContainerInfo._ancestorInfo;
        }
        if (parentInfo) {
          // parentInfo should always be present except for the top-level
          // component when server rendering
          validateDOMNesting(null, this._stringText, this, parentInfo);
        }
      }

      var domID = hostContainerInfo._idCounter++;
      var openingValue = ' react-text: ' + domID + ' ';
      var closingValue = ' /react-text ';
      this._domID = domID;
      this._hostParent = hostParent;
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var openingComment = ownerDocument.createComment(openingValue);
        var closingComment = ownerDocument.createComment(closingValue);
        var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
        if (this._stringText) {
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
        }
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
        ReactDOMComponentTree.precacheNode(this, openingComment);
        this._closingComment = closingComment;
        return lazyTree;
      } else {
        var escapedText = escapeTextContentForBrowser(this._stringText);

        if (transaction.renderToStaticMarkup) {
          // Normally we'd wrap this between comment nodes for the reasons stated
          // above, but since this is a situation where React won't take over
          // (static pages), we can simply return the text as it is.
          return escapedText;
        }

        return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
      }
    },

    /**
     * Updates this component by updating the text content.
     *
     * @param {ReactText} nextText The next text content
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    receiveComponent: function (nextText, transaction) {
      if (nextText !== this._currentElement) {
        this._currentElement = nextText;
        var nextStringText = '' + nextText;
        if (nextStringText !== this._stringText) {
          // TODO: Save this as pending props and use performUpdateIfNecessary
          // and/or updateComponent to do the actual update for consistency with
          // other component types?
          this._stringText = nextStringText;
          var commentNodes = this.getHostNode();
          DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
        }
      }
    },

    getHostNode: function () {
      var hostNode = this._commentNodes;
      if (hostNode) {
        return hostNode;
      }
      if (!this._closingComment) {
        var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
        var node = openingComment.nextSibling;
        while (true) {
          !(node != null) ? 'production' !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
          if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
            this._closingComment = node;
            break;
          }
          node = node.nextSibling;
        }
      }
      hostNode = [this._hostNode, this._closingComment];
      this._commentNodes = hostNode;
      return hostNode;
    },

    unmountComponent: function () {
      this._closingComment = null;
      this._commentNodes = null;
      ReactDOMComponentTree.uncacheNode(this);
    }

  });

  module.exports = ReactDOMTextComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDefaultBatchingStrategy.js', ['object-assign', './ReactUpdates', './Transaction', 'fbjs/lib/emptyFunction', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var ReactUpdates = $__require('./ReactUpdates');
  var Transaction = $__require('./Transaction');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');

  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function () {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };

  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };

  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }

  _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
    getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    }
  });

  var transaction = new ReactDefaultBatchingStrategyTransaction();

  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,

    /**
     * Call the provided function in a context within which calls to `setState`
     * and friends are batched such that components aren't updated unnecessarily.
     */
    batchedUpdates: function (callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

      ReactDefaultBatchingStrategy.isBatchingUpdates = true;

      // The code is written this way to avoid extra allocations
      if (alreadyBatchingUpdates) {
        return callback(a, b, c, d, e);
      } else {
        return transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };

  module.exports = ReactDefaultBatchingStrategy;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/getUnboundedScrollPosition.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  /**
   * Gets the scroll position of the supplied element or window.
   *
   * The return values are unbounded, unlike `getScrollPosition`. This means they
   * may be negative or exceed the element boundaries (which is possible using
   * inertial scrolling).
   *
   * @param {DOMWindow|DOMElement} scrollable
   * @return {object} Map with `x` and `y` keys.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable === window) {
      return {
        x: window.pageXOffset || document.documentElement.scrollLeft,
        y: window.pageYOffset || document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }

  module.exports = getUnboundedScrollPosition;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactEventListener.js', ['object-assign', 'fbjs/lib/EventListener', 'fbjs/lib/ExecutionEnvironment', './PooledClass', './ReactDOMComponentTree', './ReactUpdates', './getEventTarget', 'fbjs/lib/getUnboundedScrollPosition', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var EventListener = $__require('fbjs/lib/EventListener');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var PooledClass = $__require('./PooledClass');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactUpdates = $__require('./ReactUpdates');

  var getEventTarget = $__require('./getEventTarget');
  var getUnboundedScrollPosition = $__require('fbjs/lib/getUnboundedScrollPosition');

  /**
   * Find the deepest React component completely containing the root of the
   * passed-in instance (for use when entire React trees are nested within each
   * other). If React trees are not nested, returns null.
   */
  function findParent(inst) {
    // TODO: It may be a good idea to cache this to prevent unnecessary DOM
    // traversal, but caching is difficult to do correctly without using a
    // mutation observer to listen for all DOM changes.
    while (inst._hostParent) {
      inst = inst._hostParent;
    }
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
    var container = rootNode.parentNode;
    return ReactDOMComponentTree.getClosestInstanceFromNode(container);
  }

  // Used to store ancestor hierarchy in top level callback
  function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
    this.topLevelType = topLevelType;
    this.nativeEvent = nativeEvent;
    this.ancestors = [];
  }
  _assign(TopLevelCallbackBookKeeping.prototype, {
    destructor: function () {
      this.topLevelType = null;
      this.nativeEvent = null;
      this.ancestors.length = 0;
    }
  });
  PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

  function handleTopLevelImpl(bookKeeping) {
    var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
    var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

    // Loop through the hierarchy, in case there's any nested components.
    // It's important that we build the array of ancestors before calling any
    // event handlers, because event handlers can modify the DOM, leading to
    // inconsistencies with ReactMount's node cache. See #1105.
    var ancestor = targetInst;
    do {
      bookKeeping.ancestors.push(ancestor);
      ancestor = ancestor && findParent(ancestor);
    } while (ancestor);

    for (var i = 0; i < bookKeeping.ancestors.length; i++) {
      targetInst = bookKeeping.ancestors[i];
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
    }
  }

  function scrollValueMonitor(cb) {
    var scrollPosition = getUnboundedScrollPosition(window);
    cb(scrollPosition);
  }

  var ReactEventListener = {
    _enabled: true,
    _handleTopLevel: null,

    WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

    setHandleTopLevel: function (handleTopLevel) {
      ReactEventListener._handleTopLevel = handleTopLevel;
    },

    setEnabled: function (enabled) {
      ReactEventListener._enabled = !!enabled;
    },

    isEnabled: function () {
      return ReactEventListener._enabled;
    },

    /**
     * Traps top-level events by using event bubbling.
     *
     * @param {string} topLevelType Record from `EventConstants`.
     * @param {string} handlerBaseName Event name (e.g. "click").
     * @param {object} element Element on which to attach listener.
     * @return {?object} An object with a remove function which will forcefully
     *                  remove the listener.
     * @internal
     */
    trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
      if (!element) {
        return null;
      }
      return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
    },

    /**
     * Traps a top-level event by using event capturing.
     *
     * @param {string} topLevelType Record from `EventConstants`.
     * @param {string} handlerBaseName Event name (e.g. "click").
     * @param {object} element Element on which to attach listener.
     * @return {?object} An object with a remove function which will forcefully
     *                  remove the listener.
     * @internal
     */
    trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
      if (!element) {
        return null;
      }
      return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
    },

    monitorScrollValue: function (refresh) {
      var callback = scrollValueMonitor.bind(null, refresh);
      EventListener.listen(window, 'scroll', callback);
    },

    dispatchEvent: function (topLevelType, nativeEvent) {
      if (!ReactEventListener._enabled) {
        return;
      }

      var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
      try {
        // Event queue being processed in the same cycle allows
        // `preventDefault`.
        ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
      } finally {
        TopLevelCallbackBookKeeping.release(bookKeeping);
      }
    }
  };

  module.exports = ReactEventListener;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactInjection.js', ['./DOMProperty', './EventPluginHub', './EventPluginUtils', './ReactComponentEnvironment', './ReactEmptyComponent', './ReactBrowserEventEmitter', './ReactHostComponent', './ReactUpdates', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginUtils = $__require('./EventPluginUtils');
  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactEmptyComponent = $__require('./ReactEmptyComponent');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactHostComponent = $__require('./ReactHostComponent');
  var ReactUpdates = $__require('./ReactUpdates');

  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventPluginUtils: EventPluginUtils.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    HostComponent: ReactHostComponent.injection,
    Updates: ReactUpdates.injection
  };

  module.exports = ReactInjection;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactReconcileTransaction.js', ['object-assign', './CallbackQueue', './PooledClass', './ReactBrowserEventEmitter', './ReactInputSelection', './ReactInstrumentation', './Transaction', './ReactUpdateQueue', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var CallbackQueue = $__require('./CallbackQueue');
  var PooledClass = $__require('./PooledClass');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactInputSelection = $__require('./ReactInputSelection');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var Transaction = $__require('./Transaction');
  var ReactUpdateQueue = $__require('./ReactUpdateQueue');

  /**
   * Ensures that, when possible, the selection range (currently selected text
   * input) is not disturbed by performing the transaction.
   */
  var SELECTION_RESTORATION = {
    /**
     * @return {Selection} Selection information.
     */
    initialize: ReactInputSelection.getSelectionInformation,
    /**
     * @param {Selection} sel Selection information returned from `initialize`.
     */
    close: ReactInputSelection.restoreSelection
  };

  /**
   * Suppresses events (blur/focus) that could be inadvertently dispatched due to
   * high level DOM manipulations (like temporarily removing a text input from the
   * DOM).
   */
  var EVENT_SUPPRESSION = {
    /**
     * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
     * the reconciliation.
     */
    initialize: function () {
      var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
      ReactBrowserEventEmitter.setEnabled(false);
      return currentlyEnabled;
    },

    /**
     * @param {boolean} previouslyEnabled Enabled status of
     *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
     *   restores the previous value.
     */
    close: function (previouslyEnabled) {
      ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
    }
  };

  /**
   * Provides a queue for collecting `componentDidMount` and
   * `componentDidUpdate` callbacks during the transaction.
   */
  var ON_DOM_READY_QUEUEING = {
    /**
     * Initializes the internal `onDOMReady` queue.
     */
    initialize: function () {
      this.reactMountReady.reset();
    },

    /**
     * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
     */
    close: function () {
      this.reactMountReady.notifyAll();
    }
  };

  /**
   * Executed within the scope of the `Transaction` instance. Consider these as
   * being member methods, but with an implied ordering while being isolated from
   * each other.
   */
  var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

  if ('production' !== 'production') {
    TRANSACTION_WRAPPERS.push({
      initialize: ReactInstrumentation.debugTool.onBeginFlush,
      close: ReactInstrumentation.debugTool.onEndFlush
    });
  }

  /**
   * Currently:
   * - The order that these are listed in the transaction is critical:
   * - Suppresses events.
   * - Restores selection range.
   *
   * Future:
   * - Restore document/overflow scroll positions that were unintentionally
   *   modified via DOM insertions above the top viewport boundary.
   * - Implement/integrate with customized constraint based layout system and keep
   *   track of which dimensions must be remeasured.
   *
   * @class ReactReconcileTransaction
   */
  function ReactReconcileTransaction(useCreateElement) {
    this.reinitializeTransaction();
    // Only server-side rendering really needs this option (see
    // `ReactServerRendering`), but server-side uses
    // `ReactServerRenderingTransaction` instead. This option is here so that it's
    // accessible and defaults to false when `ReactDOMComponent` and
    // `ReactDOMTextComponent` checks it in `mountComponent`.`
    this.renderToStaticMarkup = false;
    this.reactMountReady = CallbackQueue.getPooled(null);
    this.useCreateElement = useCreateElement;
  }

  var Mixin = {
    /**
     * @see Transaction
     * @abstract
     * @final
     * @return {array<object>} List of operation wrap procedures.
     *   TODO: convert to array<TransactionWrapper>
     */
    getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    },

    /**
     * @return {object} The queue to collect `onDOMReady` callbacks with.
     */
    getReactMountReady: function () {
      return this.reactMountReady;
    },

    /**
     * @return {object} The queue to collect React async events.
     */
    getUpdateQueue: function () {
      return ReactUpdateQueue;
    },

    /**
     * Save current transaction state -- if the return value from this method is
     * passed to `rollback`, the transaction will be reset to that state.
     */
    checkpoint: function () {
      // reactMountReady is the our only stateful wrapper
      return this.reactMountReady.checkpoint();
    },

    rollback: function (checkpoint) {
      this.reactMountReady.rollback(checkpoint);
    },

    /**
     * `PooledClass` looks for this, and will invoke this before allowing this
     * instance to be reused.
     */
    destructor: function () {
      CallbackQueue.release(this.reactMountReady);
      this.reactMountReady = null;
    }
  };

  _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

  PooledClass.addPoolingTo(ReactReconcileTransaction);

  module.exports = ReactReconcileTransaction;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SVGDOMPropertyConfig.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };

  // We use attributes for everything SVG so let's avoid some duplication and run
  // code instead.
  // The following are all specified in the HTML config already so we exclude here.
  // - class (as className)
  // - color
  // - height
  // - id
  // - lang
  // - max
  // - media
  // - method
  // - min
  // - name
  // - style
  // - target
  // - type
  // - width
  var ATTRS = {
    accentHeight: 'accent-height',
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 'alignment-baseline',
    allowReorder: 'allowReorder',
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 'arabic-form',
    ascent: 0,
    attributeName: 'attributeName',
    attributeType: 'attributeType',
    autoReverse: 'autoReverse',
    azimuth: 0,
    baseFrequency: 'baseFrequency',
    baseProfile: 'baseProfile',
    baselineShift: 'baseline-shift',
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 'calcMode',
    capHeight: 'cap-height',
    clip: 0,
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    clipPathUnits: 'clipPathUnits',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    contentScriptType: 'contentScriptType',
    contentStyleType: 'contentStyleType',
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 'diffuseConstant',
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 'dominant-baseline',
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 'edgeMode',
    elevation: 0,
    enableBackground: 'enable-background',
    end: 0,
    exponent: 0,
    externalResourcesRequired: 'externalResourcesRequired',
    fill: 0,
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    filter: 0,
    filterRes: 'filterRes',
    filterUnits: 'filterUnits',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    focusable: 0,
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    glyphRef: 'glyphRef',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    hanging: 0,
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    ideographic: 0,
    imageRendering: 'image-rendering',
    'in': 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: 'kernelMatrix',
    kernelUnitLength: 'kernelUnitLength',
    kerning: 0,
    keyPoints: 'keyPoints',
    keySplines: 'keySplines',
    keyTimes: 'keyTimes',
    lengthAdjust: 'lengthAdjust',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    limitingConeAngle: 'limitingConeAngle',
    local: 0,
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    markerHeight: 'markerHeight',
    markerUnits: 'markerUnits',
    markerWidth: 'markerWidth',
    mask: 0,
    maskContentUnits: 'maskContentUnits',
    maskUnits: 'maskUnits',
    mathematical: 0,
    mode: 0,
    numOctaves: 'numOctaves',
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pathLength: 'pathLength',
    patternContentUnits: 'patternContentUnits',
    patternTransform: 'patternTransform',
    patternUnits: 'patternUnits',
    pointerEvents: 'pointer-events',
    points: 0,
    pointsAtX: 'pointsAtX',
    pointsAtY: 'pointsAtY',
    pointsAtZ: 'pointsAtZ',
    preserveAlpha: 'preserveAlpha',
    preserveAspectRatio: 'preserveAspectRatio',
    primitiveUnits: 'primitiveUnits',
    r: 0,
    radius: 0,
    refX: 'refX',
    refY: 'refY',
    renderingIntent: 'rendering-intent',
    repeatCount: 'repeatCount',
    repeatDur: 'repeatDur',
    requiredExtensions: 'requiredExtensions',
    requiredFeatures: 'requiredFeatures',
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: 'shape-rendering',
    slope: 0,
    spacing: 0,
    specularConstant: 'specularConstant',
    specularExponent: 'specularExponent',
    speed: 0,
    spreadMethod: 'spreadMethod',
    startOffset: 'startOffset',
    stdDeviation: 'stdDeviation',
    stemh: 0,
    stemv: 0,
    stitchTiles: 'stitchTiles',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    string: 0,
    stroke: 0,
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    surfaceScale: 'surfaceScale',
    systemLanguage: 'systemLanguage',
    tableValues: 'tableValues',
    targetX: 'targetX',
    targetY: 'targetY',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    textLength: 'textLength',
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicode: 0,
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    values: 0,
    vectorEffect: 'vector-effect',
    version: 0,
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    viewBox: 'viewBox',
    viewTarget: 'viewTarget',
    visibility: 0,
    widths: 0,
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    x: 0,
    xHeight: 'x-height',
    x1: 0,
    x2: 0,
    xChannelSelector: 'xChannelSelector',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlns: 0,
    xmlnsXlink: 'xmlns:xlink',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space',
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: 'yChannelSelector',
    z: 0,
    zoomAndPan: 'zoomAndPan'
  };

  var SVGDOMPropertyConfig = {
    Properties: {},
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {}
  };

  Object.keys(ATTRS).forEach(function (key) {
    SVGDOMPropertyConfig.Properties[key] = 0;
    if (ATTRS[key]) {
      SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
    }
  });

  module.exports = SVGDOMPropertyConfig;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getNodeForCharacterOffset.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given any node return the first leaf node without children.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {DOMElement|DOMTextNode}
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }

  /**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node's siblings have been exhausted.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {?DOMElement|DOMTextNode}
   */
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }

  /**
   * Get object describing the nodes which contain characters at offset.
   *
   * @param {DOMElement|DOMTextNode} root
   * @param {number} offset
   * @return {?object}
   */
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;

    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;

        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }

        nodeStart = nodeEnd;
      }

      node = getLeafNode(getSiblingNode(node));
    }
  }

  module.exports = getNodeForCharacterOffset;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getTextContentAccessor.js', ['fbjs/lib/ExecutionEnvironment', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  var contentKey = null;

  /**
   * Gets the key used to access text content on a DOM node.
   *
   * @return {?string} Key used to access text content.
   * @internal
   */
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      // Prefer textContent to innerText because many browsers support both but
      // SVG <text> elements don't support innerText even when <div> does.
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }

  module.exports = getTextContentAccessor;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMSelection.js', ['fbjs/lib/ExecutionEnvironment', './getNodeForCharacterOffset', './getTextContentAccessor', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  var getNodeForCharacterOffset = $__require('./getNodeForCharacterOffset');
  var getTextContentAccessor = $__require('./getTextContentAccessor');

  /**
   * While `isCollapsed` is available on the Selection object and `collapsed`
   * is available on the Range object, IE11 sometimes gets them wrong.
   * If the anchor/focus nodes and offsets are the same, the range is collapsed.
   */
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }

  /**
   * Get the appropriate anchor and focus node/offset pairs for IE.
   *
   * The catch here is that IE's selection API doesn't provide information
   * about whether the selection is forward or backward, so we have to
   * behave as though it's always forward.
   *
   * IE text differs from modern selection in that it behaves as though
   * block elements end with a new line. This means character offsets will
   * differ between the two APIs.
   *
   * @param {DOMElement} node
   * @return {object}
   */
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;

    // Duplicate selection so we can move range without breaking user selection.
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);

    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;

    return {
      start: startOffset,
      end: endOffset
    };
  }

  /**
   * @param {DOMElement} node
   * @return {?object}
   */
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();

    if (!selection || selection.rangeCount === 0) {
      return null;
    }

    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;

    var currentRange = selection.getRangeAt(0);

    // In Firefox, range.startContainer and range.endContainer can be "anonymous
    // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
    // divs do not seem to expose properties, triggering a "Permission denied
    // error" if any of its properties are accessed. The only seemingly possible
    // way to avoid erroring is to access a property that typically works for
    // non-anonymous divs and catch any error that may otherwise arise. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
    try {
      /* eslint-disable no-unused-expressions */
      currentRange.startContainer.nodeType;
      currentRange.endContainer.nodeType;
      /* eslint-enable no-unused-expressions */
    } catch (e) {
      return null;
    }

    // If the node and offset values are the same, the selection is collapsed.
    // `Selection.isCollapsed` is available natively, but IE sometimes gets
    // this value wrong.
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;

    // Detect whether the selection is backward.
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;

    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start, end;

    if (offsets.end === undefined) {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }

    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }

  /**
   * In modern non-IE browsers, we can support both forward and backward
   * selections.
   *
   * Note: IE10+ supports the Selection object, but it does not support
   * the `extend` method, which means that even in modern IE, it's not possible
   * to programmatically create a backward selection. Thus, for all IE
   * versions, we use the old IE API to create our selections.
   *
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }

    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

    // IE 11 uses modern selection, but doesn't support the extend method.
    // Flip backward selections, so we can set with a single range.
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }

    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);

    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();

      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }

  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

  var ReactDOMSelection = {
    /**
     * @param {DOMElement} node
     */
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

    /**
     * @param {DOMElement|DOMTextNode} node
     * @param {object} offsets
     */
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };

  module.exports = ReactDOMSelection;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/isNode.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM node.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function isNode(object) {
    return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/isTextNode.js', ['./isNode', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var isNode = $__require('./isNode');

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM text node.
   */
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }

  module.exports = isTextNode;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/containsNode.js', ['./isTextNode', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var isTextNode = $__require('./isTextNode');

  /*eslint-disable no-bitwise */

  /**
   * Checks if a given DOM node contains or is another DOM node.
   */
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }

  module.exports = containsNode;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/focusNode.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * @param {DOMElement} node input/textarea to focus
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function focusNode(node) {
    // IE8 can throw "Can't move focus to the control because it is invisible,
    // not enabled, or of a type that does not accept the focus." for all kinds of
    // reasons that are too expensive and fragile to test.
    try {
      node.focus();
    } catch (e) {}
  }

  module.exports = focusNode;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactInputSelection.js', ['./ReactDOMSelection', 'fbjs/lib/containsNode', 'fbjs/lib/focusNode', 'fbjs/lib/getActiveElement', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMSelection = $__require('./ReactDOMSelection');

  var containsNode = $__require('fbjs/lib/containsNode');
  var focusNode = $__require('fbjs/lib/focusNode');
  var getActiveElement = $__require('fbjs/lib/getActiveElement');

  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }

  /**
   * @ReactInputSelection: React input selection module. Based on Selection.js,
   * but modified to be suitable for react and has a couple of bug fixes (doesn't
   * assume buttons have range selections allowed).
   * Input selection module for React.
   */
  var ReactInputSelection = {

    hasSelectionCapabilities: function (elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },

    getSelectionInformation: function () {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },

    /**
     * @restoreSelection: If any selection information was potentially lost,
     * restore it. This is useful when performing operations that could remove dom
     * nodes and place them back in, resulting in focus being lost.
     */
    restoreSelection: function (priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },

    /**
     * @getSelection: Gets the selection bounds of a focused textarea, input or
     * contentEditable node.
     * -@input: Look up selection bounds of this input
     * -@return {start: selectionStart, end: selectionEnd}
     */
    getSelection: function (input) {
      var selection;

      if ('selectionStart' in input) {
        // Modern browser with input or textarea.
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        // IE8 input.
        var range = document.selection.createRange();
        // There can only be one selection per document in IE, so it must
        // be in our element.
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        // Content editable or old IE textarea.
        selection = ReactDOMSelection.getOffsets(input);
      }

      return selection || { start: 0, end: 0 };
    },

    /**
     * @setSelection: Sets the selection bounds of a textarea or input and focuses
     * the input.
     * -@input     Set selection bounds of this input or textarea
     * -@offsets   Object of same form that is returned from get*
     */
    setSelection: function (input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (end === undefined) {
        end = start;
      }

      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };

  module.exports = ReactInputSelection;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/getActiveElement.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /* eslint-disable fb-www/typeof-undefined */

  /**
   * Same as document.activeElement but wraps in a try-catch block. In IE it is
   * not safe to call document.activeElement if there is nothing focused.
   *
   * The activeElement will be null only if the document or document body is not
   * yet defined.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function getActiveElement() /*?DOMElement*/{
    if (typeof document === 'undefined') {
      return null;
    }
    try {
      return document.activeElement || document.body;
    } catch (e) {
      return document.body;
    }
  }

  module.exports = getActiveElement;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/isTextInputElement.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var supportedInputTypes = {
    'color': true,
    'date': true,
    'datetime': true,
    'datetime-local': true,
    'email': true,
    'month': true,
    'number': true,
    'password': true,
    'range': true,
    'search': true,
    'tel': true,
    'text': true,
    'time': true,
    'url': true,
    'week': true
  };

  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

    if (nodeName === 'input') {
      return !!supportedInputTypes[elem.type];
    }

    if (nodeName === 'textarea') {
      return true;
    }

    return false;
  }

  module.exports = isTextInputElement;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SelectEventPlugin.js', ['./EventPropagators', 'fbjs/lib/ExecutionEnvironment', './ReactDOMComponentTree', './ReactInputSelection', './SyntheticEvent', 'fbjs/lib/getActiveElement', './isTextInputElement', 'fbjs/lib/shallowEqual', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('./EventPropagators');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInputSelection = $__require('./ReactInputSelection');
  var SyntheticEvent = $__require('./SyntheticEvent');

  var getActiveElement = $__require('fbjs/lib/getActiveElement');
  var isTextInputElement = $__require('./isTextInputElement');
  var shallowEqual = $__require('fbjs/lib/shallowEqual');

  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

  var eventTypes = {
    select: {
      phasedRegistrationNames: {
        bubbled: 'onSelect',
        captured: 'onSelectCapture'
      },
      dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
    }
  };

  var activeElement = null;
  var activeElementInst = null;
  var lastSelection = null;
  var mouseDown = false;

  // Track whether a listener exists for this plugin. If none exist, we do
  // not extract events. See #3639.
  var hasListener = false;

  /**
   * Get an object which is a unique representation of the current selection.
   *
   * The return value will not be consistent across nodes or browsers, but
   * two identical selections on the same node will return identical objects.
   *
   * @param {DOMElement} node
   * @return {object}
   */
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }

  /**
   * Poll selection to see whether it's changed.
   *
   * @param {object} nativeEvent
   * @return {?SyntheticEvent}
   */
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    // Ensure we have the right element, and that the user is not dragging a
    // selection (this matches native `select` event behavior). In HTML5, select
    // fires only on input and textarea thus if there's no focused element we
    // won't dispatch.
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }

    // Only fire when selection has actually changed.
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;

      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;

      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

      return syntheticEvent;
    }

    return null;
  }

  /**
   * This plugin creates an `onSelect` event that normalizes select events
   * across form elements.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - contentEditable
   *
   * This differs from native browser implementations in the following ways:
   * - Fires on contentEditable fields as well as inputs.
   * - Fires for collapsed selection.
   * - Fires after user input.
   */
  var SelectEventPlugin = {

    eventTypes: eventTypes,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }

      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

      switch (topLevelType) {
        // Track the input node that has focus.
        case 'topFocus':
          if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
            activeElement = targetNode;
            activeElementInst = targetInst;
            lastSelection = null;
          }
          break;
        case 'topBlur':
          activeElement = null;
          activeElementInst = null;
          lastSelection = null;
          break;

        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case 'topMouseDown':
          mouseDown = true;
          break;
        case 'topContextMenu':
        case 'topMouseUp':
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);

        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case 'topSelectionChange':
          if (skipSelectionChangeEvent) {
            break;
          }
        // falls through
        case 'topKeyDown':
        case 'topKeyUp':
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }

      return null;
    },

    didPutListener: function (inst, registrationName, listener) {
      if (registrationName === 'onSelect') {
        hasListener = true;
      }
    }
  };

  module.exports = SelectEventPlugin;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/EventListener.js', ['./emptyFunction', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * @typechecks
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyFunction = $__require('./emptyFunction');

  /**
   * Upstream version of event listener. Does not take into account specific
   * nature of platform.
   */
  var EventListener = {
    /**
     * Listen to DOM events during the bubble phase.
     *
     * @param {DOMEventTarget} target DOM element to register listener on.
     * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
     * @param {function} callback Callback function.
     * @return {object} Object with a `remove` method.
     */
    listen: function listen(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, false);
        return {
          remove: function remove() {
            target.removeEventListener(eventType, callback, false);
          }
        };
      } else if (target.attachEvent) {
        target.attachEvent('on' + eventType, callback);
        return {
          remove: function remove() {
            target.detachEvent('on' + eventType, callback);
          }
        };
      }
    },

    /**
     * Listen to DOM events during the capture phase.
     *
     * @param {DOMEventTarget} target DOM element to register listener on.
     * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
     * @param {function} callback Callback function.
     * @return {object} Object with a `remove` method.
     */
    capture: function capture(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, true);
        return {
          remove: function remove() {
            target.removeEventListener(eventType, callback, true);
          }
        };
      } else {
        if ('production' !== 'production') {
          console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
        }
        return {
          remove: emptyFunction
        };
      }
    },

    registerDefault: function registerDefault() {}
  };

  module.exports = EventListener;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/EventPropagators.js', ['./EventPluginHub', './EventPluginUtils', './accumulateInto', './forEachAccumulated', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('./EventPluginHub');
  var EventPluginUtils = $__require('./EventPluginUtils');

  var accumulateInto = $__require('./accumulateInto');
  var forEachAccumulated = $__require('./forEachAccumulated');
  var warning = $__require('fbjs/lib/warning');

  var getListener = EventPluginHub.getListener;

  /**
   * Some event types have a notion of different registration names for different
   * "phases" of propagation. This finds listeners by a given phase.
   */
  function listenerAtPhase(inst, event, propagationPhase) {
    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
    return getListener(inst, registrationName);
  }

  /**
   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
   * here, allows us to not have to bind or create functions for each event.
   * Mutating the event's members allows us to not have to create a wrapping
   * "dispatch" object that pairs the event with the listener.
   */
  function accumulateDirectionalDispatches(inst, phase, event) {
    if ('production' !== 'production') {
      'production' !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
    }
    var listener = listenerAtPhase(inst, event, phase);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }

  /**
   * Collect dispatches (must be entirely collected before dispatching - see unit
   * tests). Lazily allocate the array to conserve memory.  We must loop through
   * each event and perform the traversal for each one. We cannot perform a
   * single traversal for the entire collection of events because each event may
   * have a different target.
   */
  function accumulateTwoPhaseDispatchesSingle(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
    }
  }

  /**
   * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
   */
  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
      EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
    }
  }

  /**
   * Accumulates without regard to direction, does not look for phased
   * registration names. Same as `accumulateDirectDispatchesSingle` but without
   * requiring that the `dispatchMarker` be the same as the dispatched ID.
   */
  function accumulateDispatches(inst, ignoredDirection, event) {
    if (event && event.dispatchConfig.registrationName) {
      var registrationName = event.dispatchConfig.registrationName;
      var listener = getListener(inst, registrationName);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
  }

  /**
   * Accumulates dispatches on an `SyntheticEvent`, but only for the
   * `dispatchMarker`.
   * @param {SyntheticEvent} event
   */
  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      accumulateDispatches(event._targetInst, null, event);
    }
  }

  function accumulateTwoPhaseDispatches(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
  }

  function accumulateTwoPhaseDispatchesSkipTarget(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
  }

  function accumulateEnterLeaveDispatches(leave, enter, from, to) {
    EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
  }

  function accumulateDirectDispatches(events) {
    forEachAccumulated(events, accumulateDirectDispatchesSingle);
  }

  /**
   * A small set of propagation patterns, each of which will accept a small amount
   * of information, and generate a set of "dispatch ready event objects" - which
   * are sets of events that have already been annotated with a set of dispatched
   * listener functions/ids. The API is designed this way to discourage these
   * propagation strategies from actually executing the dispatches, since we
   * always want to collect the entire set of dispatches before executing event a
   * single one.
   *
   * @constructor EventPropagators
   */
  var EventPropagators = {
    accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
    accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
    accumulateDirectDispatches: accumulateDirectDispatches,
    accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
  };

  module.exports = EventPropagators;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticAnimationEvent.js', ['./SyntheticEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  /**
   * @interface Event
   * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
   */
  var AnimationEventInterface = {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

  module.exports = SyntheticAnimationEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticClipboardEvent.js', ['./SyntheticEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  /**
   * @interface Event
   * @see http://www.w3.org/TR/clipboard-apis/
   */
  var ClipboardEventInterface = {
    clipboardData: function (event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

  module.exports = SyntheticClipboardEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticFocusEvent.js', ['./SyntheticUIEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');

  /**
   * @interface FocusEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var FocusEventInterface = {
    relatedTarget: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

  module.exports = SyntheticFocusEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getEventKey.js', ['./getEventCharCode', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var getEventCharCode = $__require('./getEventCharCode');

  /**
   * Normalization of deprecated HTML5 `key` values
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */
  var normalizeKey = {
    'Esc': 'Escape',
    'Spacebar': ' ',
    'Left': 'ArrowLeft',
    'Up': 'ArrowUp',
    'Right': 'ArrowRight',
    'Down': 'ArrowDown',
    'Del': 'Delete',
    'Win': 'OS',
    'Menu': 'ContextMenu',
    'Apps': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'MozPrintableKey': 'Unidentified'
  };

  /**
   * Translation from legacy `keyCode` to HTML5 `key`
   * Only special keys supported, all others depend on keyboard layout or browser
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
    118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };

  /**
   * @param {object} nativeEvent Native browser event.
   * @return {string} Normalized `key` property.
   */
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      // Normalize inconsistent values reported by browsers due to
      // implementations of a working draft specification.

      // FireFox implements `key` but returns `MozPrintableKey` for all
      // printable characters (normalized to `Unidentified`), ignore it.
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }

    // Browser does not implement `key`, polyfill as much of it as we can.
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);

      // The enter-key is technically both printable and non-printable and can
      // thus be captured by `keypress`, no other non-printable key should.
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      // While user keyboard layout determines the actual meaning of each
      // `keyCode` value, almost all function keys have a universal value.
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }

  module.exports = getEventKey;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticKeyboardEvent.js', ['./SyntheticUIEvent', './getEventCharCode', './getEventKey', './getEventModifierState', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');

  var getEventCharCode = $__require('./getEventCharCode');
  var getEventKey = $__require('./getEventKey');
  var getEventModifierState = $__require('./getEventModifierState');

  /**
   * @interface KeyboardEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    // Legacy Interface
    charCode: function (event) {
      // `charCode` is the result of a KeyPress event and represents the value of
      // the actual printable character.

      // KeyPress is deprecated, but its replacement is not yet final and not
      // implemented in any major browser. Only KeyPress has charCode.
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function (event) {
      // `keyCode` is the result of a KeyDown/Up event and represents the value of
      // physical keyboard key.

      // The actual meaning of the value depends on the users' keyboard layout
      // which cannot be detected. Assuming that it is a US keyboard layout
      // provides a surprisingly accurate mapping for US and European users.
      // Due to this, it is left to the user to implement at this time.
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function (event) {
      // `which` is an alias for either `keyCode` or `charCode` depending on the
      // type of the event.
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

  module.exports = SyntheticKeyboardEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticDragEvent.js', ['./SyntheticMouseEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');

  /**
   * @interface DragEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var DragEventInterface = {
    dataTransfer: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

  module.exports = SyntheticDragEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticTouchEvent.js', ['./SyntheticUIEvent', './getEventModifierState', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');

  var getEventModifierState = $__require('./getEventModifierState');

  /**
   * @interface TouchEvent
   * @see http://www.w3.org/TR/touch-events/
   */
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

  module.exports = SyntheticTouchEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticTransitionEvent.js', ['./SyntheticEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  /**
   * @interface Event
   * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
   * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
   */
  var TransitionEventInterface = {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

  module.exports = SyntheticTransitionEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticEvent.js', ['object-assign', './PooledClass', 'fbjs/lib/emptyFunction', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var PooledClass = $__require('./PooledClass');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var warning = $__require('fbjs/lib/warning');

  var didWarnForAddedNewProperty = false;
  var isProxySupported = typeof Proxy === 'function';

  var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

  /**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var EventInterface = {
    type: null,
    target: null,
    // currentTarget is set when dispatching; no use in copying it here
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   *
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {*} targetInst Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @param {DOMEventTarget} nativeEventTarget Target node.
   */
  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    if ('production' !== 'production') {
      // these have a getter/setter for warnings
      delete this.nativeEvent;
      delete this.preventDefault;
      delete this.stopPropagation;
    }

    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;

    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      if ('production' !== 'production') {
        delete this[propName]; // this has a getter/setter for warnings
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        if (propName === 'target') {
          this.target = nativeEventTarget;
        } else {
          this[propName] = nativeEvent[propName];
        }
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    return this;
  }

  _assign(SyntheticEvent.prototype, {

    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault();
      } else if (typeof event.returnValue !== 'unknown') {
        // eslint-disable-line valid-typeof
        event.returnValue = false;
      }
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },

    stopPropagation: function () {
      var event = this.nativeEvent;
      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation();
      } else if (typeof event.cancelBubble !== 'unknown') {
        // eslint-disable-line valid-typeof
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: emptyFunction.thatReturnsFalse,

    /**
     * `PooledClass` looks for `destructor` on each instance it releases.
     */
    destructor: function () {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if ('production' !== 'production') {
          Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
        } else {
          this[propName] = null;
        }
      }
      for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
        this[shouldBeReleasedProperties[i]] = null;
      }
      if ('production' !== 'production') {
        Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
        Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
        Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
      }
    }

  });

  SyntheticEvent.Interface = EventInterface;

  if ('production' !== 'production') {
    if (isProxySupported) {
      /*eslint-disable no-func-assign */
      SyntheticEvent = new Proxy(SyntheticEvent, {
        construct: function (target, args) {
          return this.apply(target, Object.create(target.prototype), args);
        },
        apply: function (constructor, that, args) {
          return new Proxy(constructor.apply(that, args), {
            set: function (target, prop, value) {
              if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                'production' !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                didWarnForAddedNewProperty = true;
              }
              target[prop] = value;
              return true;
            }
          });
        }
      });
      /*eslint-enable no-func-assign */
    }
  }
  /**
   * Helper to reduce boilerplate when creating subclasses.
   *
   * @param {function} Class
   * @param {?object} Interface
   */
  SyntheticEvent.augmentClass = function (Class, Interface) {
    var Super = this;

    var E = function () {};
    E.prototype = Super.prototype;
    var prototype = new E();

    _assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;

    Class.Interface = _assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;

    PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
  };

  PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

  module.exports = SyntheticEvent;

  /**
    * Helper to nullify syntheticEvent instance properties when destructing
    *
    * @param {object} SyntheticEvent
    * @param {String} propName
    * @return {object} defineProperty object
    */
  function getPooledWarningPropertyDefinition(propName, getVal) {
    var isFunction = typeof getVal === 'function';
    return {
      configurable: true,
      set: set,
      get: get
    };

    function set(val) {
      var action = isFunction ? 'setting the method' : 'setting the property';
      warn(action, 'This is effectively a no-op');
      return val;
    }

    function get() {
      var action = isFunction ? 'accessing the method' : 'accessing the property';
      var result = isFunction ? 'This is a no-op function' : 'This is set to null';
      warn(action, result);
      return getVal;
    }

    function warn(action, result) {
      var warningCondition = false;
      'production' !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
    }
  }
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getEventTarget.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {DOMEventTarget} Target node.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;

    // Normalize SVG <use> element events #4963
    if (target.correspondingUseElement) {
      target = target.correspondingUseElement;
    }

    // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
    // @see http://www.quirksmode.org/js/events_properties.html
    return target.nodeType === 3 ? target.parentNode : target;
  }

  module.exports = getEventTarget;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticUIEvent.js', ['./SyntheticEvent', './getEventTarget', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('./SyntheticEvent');

  var getEventTarget = $__require('./getEventTarget');

  /**
   * @interface UIEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var UIEventInterface = {
    view: function (event) {
      if (event.view) {
        return event.view;
      }

      var target = getEventTarget(event);
      if (target.window === target) {
        // target is a window object
        return target;
      }

      var doc = target.ownerDocument;
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function (event) {
      return event.detail || 0;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

  module.exports = SyntheticUIEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getEventModifierState.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Translation from modifier key to the associated property in the event.
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var modifierKeyToProp = {
    'Alt': 'altKey',
    'Control': 'ctrlKey',
    'Meta': 'metaKey',
    'Shift': 'shiftKey'
  };

  // IE8 does not implement getModifierState so we simply map it to the only
  // modifier keys exposed by the event itself, does not support Lock-keys.
  // Currently, all major browsers except Chrome seems to support Lock-keys.
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }

  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }

  module.exports = getEventModifierState;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticMouseEvent.js', ['./SyntheticUIEvent', './ViewportMetrics', './getEventModifierState', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var ViewportMetrics = $__require('./ViewportMetrics');

  var getEventModifierState = $__require('./getEventModifierState');

  /**
   * @interface MouseEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function (event) {
      // Webkit, Firefox, IE9+
      // which:  1 2 3
      // button: 0 1 2 (standard)
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      // IE<9
      // which:  undefined
      // button: 0 0 0
      // button: 1 4 2 (onmouseup)
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function (event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    // "Proprietary" Interface.
    pageX: function (event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function (event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

  module.exports = SyntheticMouseEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SyntheticWheelEvent.js', ['./SyntheticMouseEvent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');

  /**
   * @interface WheelEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var WheelEventInterface = {
    deltaX: function (event) {
      return 'deltaX' in event ? event.deltaX :
      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function (event) {
      return 'deltaY' in event ? event.deltaY :
      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      'wheelDeltaY' in event ? -event.wheelDeltaY :
      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
      'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,

    // Browsers without "deltaMode" is reporting in raw wheel delta where one
    // notch on the scroll is always +/- 120, roughly equivalent to pixels.
    // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
    // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
    deltaMode: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticMouseEvent}
   */
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

  module.exports = SyntheticWheelEvent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getEventCharCode.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `charCode` represents the actual "character code" and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {number} Normalized `charCode` property.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;

    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;

      // FF does not set `charCode` for the Enter-key, check against `keyCode`.
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      // IE8 does not implement `charCode`, but `keyCode` has the correct value.
      charCode = keyCode;
    }

    // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
    // Must not discard the (non-)printable Enter-key.
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }

    return 0;
  }

  module.exports = getEventCharCode;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/SimpleEventPlugin.js', ['./reactProdInvariant', 'fbjs/lib/EventListener', './EventPropagators', './ReactDOMComponentTree', './SyntheticAnimationEvent', './SyntheticClipboardEvent', './SyntheticEvent', './SyntheticFocusEvent', './SyntheticKeyboardEvent', './SyntheticMouseEvent', './SyntheticDragEvent', './SyntheticTouchEvent', './SyntheticTransitionEvent', './SyntheticUIEvent', './SyntheticWheelEvent', 'fbjs/lib/emptyFunction', './getEventCharCode', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var EventListener = $__require('fbjs/lib/EventListener');
  var EventPropagators = $__require('./EventPropagators');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var SyntheticAnimationEvent = $__require('./SyntheticAnimationEvent');
  var SyntheticClipboardEvent = $__require('./SyntheticClipboardEvent');
  var SyntheticEvent = $__require('./SyntheticEvent');
  var SyntheticFocusEvent = $__require('./SyntheticFocusEvent');
  var SyntheticKeyboardEvent = $__require('./SyntheticKeyboardEvent');
  var SyntheticMouseEvent = $__require('./SyntheticMouseEvent');
  var SyntheticDragEvent = $__require('./SyntheticDragEvent');
  var SyntheticTouchEvent = $__require('./SyntheticTouchEvent');
  var SyntheticTransitionEvent = $__require('./SyntheticTransitionEvent');
  var SyntheticUIEvent = $__require('./SyntheticUIEvent');
  var SyntheticWheelEvent = $__require('./SyntheticWheelEvent');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var getEventCharCode = $__require('./getEventCharCode');
  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Turns
   * ['abort', ...]
   * into
   * eventTypes = {
   *   'abort': {
   *     phasedRegistrationNames: {
   *       bubbled: 'onAbort',
   *       captured: 'onAbortCapture',
   *     },
   *     dependencies: ['topAbort'],
   *   },
   *   ...
   * };
   * topLevelEventsToDispatchConfig = {
   *   'topAbort': { sameConfig }
   * };
   */
  var eventTypes = {};
  var topLevelEventsToDispatchConfig = {};
  ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var onEvent = 'on' + capitalizedEvent;
    var topEvent = 'top' + capitalizedEvent;

    var type = {
      phasedRegistrationNames: {
        bubbled: onEvent,
        captured: onEvent + 'Capture'
      },
      dependencies: [topEvent]
    };
    eventTypes[event] = type;
    topLevelEventsToDispatchConfig[topEvent] = type;
  });

  var onClickListeners = {};

  function getDictionaryKey(inst) {
    // Prevents V8 performance issue:
    // https://github.com/facebook/react/pull/7232
    return '.' + inst._rootNodeID;
  }

  function isInteractive(tag) {
    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
  }

  var SimpleEventPlugin = {

    eventTypes: eventTypes,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
      if (!dispatchConfig) {
        return null;
      }
      var EventConstructor;
      switch (topLevelType) {
        case 'topAbort':
        case 'topCanPlay':
        case 'topCanPlayThrough':
        case 'topDurationChange':
        case 'topEmptied':
        case 'topEncrypted':
        case 'topEnded':
        case 'topError':
        case 'topInput':
        case 'topInvalid':
        case 'topLoad':
        case 'topLoadedData':
        case 'topLoadedMetadata':
        case 'topLoadStart':
        case 'topPause':
        case 'topPlay':
        case 'topPlaying':
        case 'topProgress':
        case 'topRateChange':
        case 'topReset':
        case 'topSeeked':
        case 'topSeeking':
        case 'topStalled':
        case 'topSubmit':
        case 'topSuspend':
        case 'topTimeUpdate':
        case 'topVolumeChange':
        case 'topWaiting':
          // HTML Events
          // @see http://www.w3.org/TR/html5/index.html#events-0
          EventConstructor = SyntheticEvent;
          break;
        case 'topKeyPress':
          // Firefox creates a keypress event for function keys too. This removes
          // the unwanted keypress events. Enter is however both printable and
          // non-printable. One would expect Tab to be as well (but it isn't).
          if (getEventCharCode(nativeEvent) === 0) {
            return null;
          }
        /* falls through */
        case 'topKeyDown':
        case 'topKeyUp':
          EventConstructor = SyntheticKeyboardEvent;
          break;
        case 'topBlur':
        case 'topFocus':
          EventConstructor = SyntheticFocusEvent;
          break;
        case 'topClick':
          // Firefox creates a click event on right mouse clicks. This removes the
          // unwanted click events.
          if (nativeEvent.button === 2) {
            return null;
          }
        /* falls through */
        case 'topDoubleClick':
        case 'topMouseDown':
        case 'topMouseMove':
        case 'topMouseUp':
        // TODO: Disabled elements should not respond to mouse events
        /* falls through */
        case 'topMouseOut':
        case 'topMouseOver':
        case 'topContextMenu':
          EventConstructor = SyntheticMouseEvent;
          break;
        case 'topDrag':
        case 'topDragEnd':
        case 'topDragEnter':
        case 'topDragExit':
        case 'topDragLeave':
        case 'topDragOver':
        case 'topDragStart':
        case 'topDrop':
          EventConstructor = SyntheticDragEvent;
          break;
        case 'topTouchCancel':
        case 'topTouchEnd':
        case 'topTouchMove':
        case 'topTouchStart':
          EventConstructor = SyntheticTouchEvent;
          break;
        case 'topAnimationEnd':
        case 'topAnimationIteration':
        case 'topAnimationStart':
          EventConstructor = SyntheticAnimationEvent;
          break;
        case 'topTransitionEnd':
          EventConstructor = SyntheticTransitionEvent;
          break;
        case 'topScroll':
          EventConstructor = SyntheticUIEvent;
          break;
        case 'topWheel':
          EventConstructor = SyntheticWheelEvent;
          break;
        case 'topCopy':
        case 'topCut':
        case 'topPaste':
          EventConstructor = SyntheticClipboardEvent;
          break;
      }
      !EventConstructor ? 'production' !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
      var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    },

    didPutListener: function (inst, registrationName, listener) {
      // Mobile Safari does not fire properly bubble click events on
      // non-interactive elements, which means delegated click listeners do not
      // fire. The workaround for this bug involves attaching an empty click
      // listener on the target node.
      // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
      if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
        var key = getDictionaryKey(inst);
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        if (!onClickListeners[key]) {
          onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
        }
      }
    },

    willDeleteListener: function (inst, registrationName) {
      if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
        var key = getDictionaryKey(inst);
        onClickListeners[key].remove();
        delete onClickListeners[key];
      }
    }

  };

  module.exports = SimpleEventPlugin;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDefaultInjection.js', ['./ARIADOMPropertyConfig', './BeforeInputEventPlugin', './ChangeEventPlugin', './DefaultEventPluginOrder', './EnterLeaveEventPlugin', './HTMLDOMPropertyConfig', './ReactComponentBrowserEnvironment', './ReactDOMComponent', './ReactDOMComponentTree', './ReactDOMEmptyComponent', './ReactDOMTreeTraversal', './ReactDOMTextComponent', './ReactDefaultBatchingStrategy', './ReactEventListener', './ReactInjection', './ReactReconcileTransaction', './SVGDOMPropertyConfig', './SelectEventPlugin', './SimpleEventPlugin', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = $__require('./ARIADOMPropertyConfig');
  var BeforeInputEventPlugin = $__require('./BeforeInputEventPlugin');
  var ChangeEventPlugin = $__require('./ChangeEventPlugin');
  var DefaultEventPluginOrder = $__require('./DefaultEventPluginOrder');
  var EnterLeaveEventPlugin = $__require('./EnterLeaveEventPlugin');
  var HTMLDOMPropertyConfig = $__require('./HTMLDOMPropertyConfig');
  var ReactComponentBrowserEnvironment = $__require('./ReactComponentBrowserEnvironment');
  var ReactDOMComponent = $__require('./ReactDOMComponent');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMEmptyComponent = $__require('./ReactDOMEmptyComponent');
  var ReactDOMTreeTraversal = $__require('./ReactDOMTreeTraversal');
  var ReactDOMTextComponent = $__require('./ReactDOMTextComponent');
  var ReactDefaultBatchingStrategy = $__require('./ReactDefaultBatchingStrategy');
  var ReactEventListener = $__require('./ReactEventListener');
  var ReactInjection = $__require('./ReactInjection');
  var ReactReconcileTransaction = $__require('./ReactReconcileTransaction');
  var SVGDOMPropertyConfig = $__require('./SVGDOMPropertyConfig');
  var SelectEventPlugin = $__require('./SelectEventPlugin');
  var SimpleEventPlugin = $__require('./SimpleEventPlugin');

  var alreadyInjected = false;

  function inject() {
    if (alreadyInjected) {
      // TODO: This is currently true because these injections are shared between
      // the client and the server package. They should be built independently
      // and not share any injection state. Then this problem will be solved.
      return;
    }
    alreadyInjected = true;

    ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

    /**
     * Inject modules for resolving DOM hierarchy and plugin ordering.
     */
    ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
    ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
    ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

    /**
     * Some important event plugins included by default (without having to require
     * them).
     */
    ReactInjection.EventPluginHub.injectEventPluginsByName({
      SimpleEventPlugin: SimpleEventPlugin,
      EnterLeaveEventPlugin: EnterLeaveEventPlugin,
      ChangeEventPlugin: ChangeEventPlugin,
      SelectEventPlugin: SelectEventPlugin,
      BeforeInputEventPlugin: BeforeInputEventPlugin
    });

    ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

    ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

    ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

    ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
      return new ReactDOMEmptyComponent(instantiate);
    });

    ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
    ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

    ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  }

  module.exports = {
    inject: inject
  };
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactVersion.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = '15.4.1';
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/findDOMNode.js', ['./reactProdInvariant', 'react/lib/ReactCurrentOwner', './ReactDOMComponentTree', './ReactInstanceMap', './getHostComponentFromComposite', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactInstanceMap = $__require('./ReactInstanceMap');

  var getHostComponentFromComposite = $__require('./getHostComponentFromComposite');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  /**
   * Returns the DOM node rendered by this element.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
   *
   * @param {ReactComponent|DOMElement} componentOrElement
   * @return {?DOMElement} The root node of this element.
   */
  function findDOMNode(componentOrElement) {
    if ('production' !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === 1) {
      return componentOrElement;
    }

    var inst = ReactInstanceMap.get(componentOrElement);
    if (inst) {
      inst = getHostComponentFromComposite(inst);
      return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
    }

    if (typeof componentOrElement.render === 'function') {
      !false ? 'production' !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
    } else {
      !false ? 'production' !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
    }
  }

  module.exports = findDOMNode;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getHostComponentFromComposite.js', ['./ReactNodeTypes', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactNodeTypes = $__require('./ReactNodeTypes');

  function getHostComponentFromComposite(inst) {
    var type;

    while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
      inst = inst._renderedComponent;
    }

    if (type === ReactNodeTypes.HOST) {
      return inst._renderedComponent;
    } else if (type === ReactNodeTypes.EMPTY) {
      return null;
    }
  }

  module.exports = getHostComponentFromComposite;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/escapeTextContentForBrowser.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * Based on the escape-html library, which is used under the MIT License below:
   *
   * Copyright (c) 2012-2013 TJ Holowaychuk
   * Copyright (c) 2015 Andreas Lubbe
   * Copyright (c) 2015 Tiancheng "Timothy" Gu
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * 'Software'), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   */

  'use strict';

  // code copied and modified from escape-html
  /**
   * Module variables.
   * @private
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);

    if (!match) {
      return str;
    }

    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#x27;'; // modified from escape-html; used to be '&#39'
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }

      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }

      lastIndex = index + 1;
      html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  // end code copied and modified from escape-html


  /**
   * Escapes text to prevent scripting attacks.
   *
   * @param {*} text Text value to escape.
   * @return {string} An escaped string.
   */
  function escapeTextContentForBrowser(text) {
    if (typeof text === 'boolean' || typeof text === 'number') {
      // this shortcircuit helps perf for types that we know will never have
      // special characters, especially given that this function is used often
      // for numeric dom ids.
      return '' + text;
    }
    return escapeHtml(text);
  }

  module.exports = escapeTextContentForBrowser;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/setTextContent.js', ['fbjs/lib/ExecutionEnvironment', './escapeTextContentForBrowser', './setInnerHTML', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var escapeTextContentForBrowser = $__require('./escapeTextContentForBrowser');
  var setInnerHTML = $__require('./setInnerHTML');

  /**
   * Set the textContent property of a node, ensuring that whitespace is preserved
   * even in IE8. innerText is a poor substitute for textContent and, among many
   * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
   * as it should.
   *
   * @param {DOMElement} node
   * @param {string} text
   * @internal
   */
  var setTextContent = function (node, text) {
    if (text) {
      var firstChild = node.firstChild;

      if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  };

  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function (node, text) {
        if (node.nodeType === 3) {
          node.nodeValue = text;
          return;
        }
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }

  module.exports = setTextContent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DOMLazyTree.js', ['./DOMNamespaces', './setInnerHTML', './createMicrosoftUnsafeLocalFunction', './setTextContent', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = $__require('./DOMNamespaces');
  var setInnerHTML = $__require('./setInnerHTML');

  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');
  var setTextContent = $__require('./setTextContent');

  var ELEMENT_NODE_TYPE = 1;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

  /**
   * In IE (8-11) and Edge, appending nodes with no children is dramatically
   * faster than appending a full subtree, so we essentially queue up the
   * .appendChild calls here and apply them so each node is added to its parent
   * before any children are added.
   *
   * In other browsers, doing so is slower or neutral compared to the other order
   * (in Firefox, twice as slow) so we only do this inversion in IE.
   *
   * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
   */
  var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

  function insertTreeChildren(tree) {
    if (!enableLazy) {
      return;
    }
    var node = tree.node;
    var children = tree.children;
    if (children.length) {
      for (var i = 0; i < children.length; i++) {
        insertTreeBefore(node, children[i], null);
      }
    } else if (tree.html != null) {
      setInnerHTML(node, tree.html);
    } else if (tree.text != null) {
      setTextContent(node, tree.text);
    }
  }

  var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
    // DocumentFragments aren't actually part of the DOM after insertion so
    // appending children won't update the DOM. We need to ensure the fragment
    // is properly populated first, breaking out of our lazy approach for just
    // this level. Also, some <object> plugins (like Flash Player) will read
    // <param> nodes immediately upon insertion into the DOM, so <object>
    // must also be populated prior to insertion into the DOM.
    if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
      insertTreeChildren(tree);
      parentNode.insertBefore(tree.node, referenceNode);
    } else {
      parentNode.insertBefore(tree.node, referenceNode);
      insertTreeChildren(tree);
    }
  });

  function replaceChildWithTree(oldNode, newTree) {
    oldNode.parentNode.replaceChild(newTree.node, oldNode);
    insertTreeChildren(newTree);
  }

  function queueChild(parentTree, childTree) {
    if (enableLazy) {
      parentTree.children.push(childTree);
    } else {
      parentTree.node.appendChild(childTree.node);
    }
  }

  function queueHTML(tree, html) {
    if (enableLazy) {
      tree.html = html;
    } else {
      setInnerHTML(tree.node, html);
    }
  }

  function queueText(tree, text) {
    if (enableLazy) {
      tree.text = text;
    } else {
      setTextContent(tree.node, text);
    }
  }

  function toString() {
    return this.node.nodeName;
  }

  function DOMLazyTree(node) {
    return {
      node: node,
      children: [],
      html: null,
      text: null,
      toString: toString
    };
  }

  DOMLazyTree.insertTreeBefore = insertTreeBefore;
  DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
  DOMLazyTree.queueChild = queueChild;
  DOMLazyTree.queueHTML = queueHTML;
  DOMLazyTree.queueText = queueText;

  module.exports = DOMLazyTree;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/EventPluginUtils.js', ['./reactProdInvariant', './ReactErrorUtils', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactErrorUtils = $__require('./ReactErrorUtils');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  /**
   * Injected dependencies:
   */

  /**
   * - `ComponentTree`: [required] Module that can convert between React instances
   *   and actual node references.
   */
  var ComponentTree;
  var TreeTraversal;
  var injection = {
    injectComponentTree: function (Injected) {
      ComponentTree = Injected;
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
      }
    },
    injectTreeTraversal: function (Injected) {
      TreeTraversal = Injected;
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
      }
    }
  };

  function isEndish(topLevelType) {
    return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
  }

  function isMoveish(topLevelType) {
    return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
  }
  function isStartish(topLevelType) {
    return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
  }

  var validateEventDispatches;
  if ('production' !== 'production') {
    validateEventDispatches = function (event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;

      var listenersIsArr = Array.isArray(dispatchListeners);
      var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

      var instancesIsArr = Array.isArray(dispatchInstances);
      var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

      'production' !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
    };
  }

  /**
   * Dispatch the event to the listener.
   * @param {SyntheticEvent} event SyntheticEvent to handle
   * @param {boolean} simulated If the event is simulated (changes exn behavior)
   * @param {function} listener Application-level callback
   * @param {*} inst Internal component instance
   */
  function executeDispatch(event, simulated, listener, inst) {
    var type = event.type || 'unknown-event';
    event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
    if (simulated) {
      ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
    } else {
      ReactErrorUtils.invokeGuardedCallback(type, listener, event);
    }
    event.currentTarget = null;
  }

  /**
   * Standard/simple iteration through an event's collected dispatches.
   */
  function executeDispatchesInOrder(event, simulated) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;
    if ('production' !== 'production') {
      validateEventDispatches(event);
    }
    if (Array.isArray(dispatchListeners)) {
      for (var i = 0; i < dispatchListeners.length; i++) {
        if (event.isPropagationStopped()) {
          break;
        }
        // Listeners and Instances are two parallel arrays that are always in sync.
        executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
      }
    } else if (dispatchListeners) {
      executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
    }
    event._dispatchListeners = null;
    event._dispatchInstances = null;
  }

  /**
   * Standard/simple iteration through an event's collected dispatches, but stops
   * at the first dispatch execution returning true, and returns that id.
   *
   * @return {?string} id of the first dispatch execution who's listener returns
   * true, or null if no listener returned true.
   */
  function executeDispatchesInOrderStopAtTrueImpl(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;
    if ('production' !== 'production') {
      validateEventDispatches(event);
    }
    if (Array.isArray(dispatchListeners)) {
      for (var i = 0; i < dispatchListeners.length; i++) {
        if (event.isPropagationStopped()) {
          break;
        }
        // Listeners and Instances are two parallel arrays that are always in sync.
        if (dispatchListeners[i](event, dispatchInstances[i])) {
          return dispatchInstances[i];
        }
      }
    } else if (dispatchListeners) {
      if (dispatchListeners(event, dispatchInstances)) {
        return dispatchInstances;
      }
    }
    return null;
  }

  /**
   * @see executeDispatchesInOrderStopAtTrueImpl
   */
  function executeDispatchesInOrderStopAtTrue(event) {
    var ret = executeDispatchesInOrderStopAtTrueImpl(event);
    event._dispatchInstances = null;
    event._dispatchListeners = null;
    return ret;
  }

  /**
   * Execution of a "direct" dispatch - there must be at most one dispatch
   * accumulated on the event or it is considered an error. It doesn't really make
   * sense for an event with multiple dispatches (bubbled) to keep track of the
   * return values at each dispatch execution, but it does tend to make sense when
   * dealing with "direct" dispatches.
   *
   * @return {*} The return value of executing the single dispatch.
   */
  function executeDirectDispatch(event) {
    if ('production' !== 'production') {
      validateEventDispatches(event);
    }
    var dispatchListener = event._dispatchListeners;
    var dispatchInstance = event._dispatchInstances;
    !!Array.isArray(dispatchListener) ? 'production' !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
    event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
    var res = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return res;
  }

  /**
   * @param {SyntheticEvent} event
   * @return {boolean} True iff number of dispatches accumulated is greater than 0.
   */
  function hasDispatches(event) {
    return !!event._dispatchListeners;
  }

  /**
   * General utilities that are useful in creating custom Event Plugins.
   */
  var EventPluginUtils = {
    isEndish: isEndish,
    isMoveish: isMoveish,
    isStartish: isStartish,

    executeDirectDispatch: executeDirectDispatch,
    executeDispatchesInOrder: executeDispatchesInOrder,
    executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
    hasDispatches: hasDispatches,

    getInstanceFromNode: function (node) {
      return ComponentTree.getInstanceFromNode(node);
    },
    getNodeFromInstance: function (node) {
      return ComponentTree.getNodeFromInstance(node);
    },
    isAncestor: function (a, b) {
      return TreeTraversal.isAncestor(a, b);
    },
    getLowestCommonAncestor: function (a, b) {
      return TreeTraversal.getLowestCommonAncestor(a, b);
    },
    getParentInstance: function (inst) {
      return TreeTraversal.getParentInstance(inst);
    },
    traverseTwoPhase: function (target, fn, arg) {
      return TreeTraversal.traverseTwoPhase(target, fn, arg);
    },
    traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
      return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
    },

    injection: injection
  };

  module.exports = EventPluginUtils;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/accumulateInto.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Accumulates items that must not be null or undefined into the first one. This
   * is used to conserve memory by avoiding array allocations, and thus sacrifices
   * API cleanness. Since `current` can be null before being passed in and not
   * null after this function, make sure to assign it back to `current`:
   *
   * `a = accumulateInto(a, b);`
   *
   * This API should be sparingly used. Try `accumulate` for something cleaner.
   *
   * @return {*|array<*>} An accumulation of items.
   */

  function accumulateInto(current, next) {
    !(next != null) ? 'production' !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

    if (current == null) {
      return next;
    }

    // Both are not empty. Warning: Never call x.concat(y) when you are not
    // certain that x is an Array (x could be a string with concat method).
    if (Array.isArray(current)) {
      if (Array.isArray(next)) {
        current.push.apply(current, next);
        return current;
      }
      current.push(next);
      return current;
    }

    if (Array.isArray(next)) {
      // A bit too dangerous to mutate `next`.
      return [current].concat(next);
    }

    return [current, next];
  }

  module.exports = accumulateInto;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/forEachAccumulated.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @param {array} arr an "accumulation" of items which is either an Array or
   * a single item. Useful when paired with the `accumulate` module. This is a
   * simple utility that allows us to reason about a collection of items, but
   * handling the case when there is exactly one item (and we do not need to
   * allocate an array).
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function forEachAccumulated(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  }

  module.exports = forEachAccumulated;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/EventPluginHub.js', ['./reactProdInvariant', './EventPluginRegistry', './EventPluginUtils', './ReactErrorUtils', './accumulateInto', './forEachAccumulated', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var EventPluginUtils = $__require('./EventPluginUtils');
  var ReactErrorUtils = $__require('./ReactErrorUtils');

  var accumulateInto = $__require('./accumulateInto');
  var forEachAccumulated = $__require('./forEachAccumulated');
  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Internal store for event listeners
   */
  var listenerBank = {};

  /**
   * Internal queue of events that have accumulated their dispatches and are
   * waiting to have their dispatches executed.
   */
  var eventQueue = null;

  /**
   * Dispatches an event and releases it back into the pool, unless persistent.
   *
   * @param {?object} event Synthetic event to be dispatched.
   * @param {boolean} simulated If the event is simulated (changes exn behavior)
   * @private
   */
  var executeDispatchesAndRelease = function (event, simulated) {
    if (event) {
      EventPluginUtils.executeDispatchesInOrder(event, simulated);

      if (!event.isPersistent()) {
        event.constructor.release(event);
      }
    }
  };
  var executeDispatchesAndReleaseSimulated = function (e) {
    return executeDispatchesAndRelease(e, true);
  };
  var executeDispatchesAndReleaseTopLevel = function (e) {
    return executeDispatchesAndRelease(e, false);
  };

  var getDictionaryKey = function (inst) {
    // Prevents V8 performance issue:
    // https://github.com/facebook/react/pull/7232
    return '.' + inst._rootNodeID;
  };

  function isInteractive(tag) {
    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
  }

  function shouldPreventMouseEvent(name, type, props) {
    switch (name) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
        return !!(props.disabled && isInteractive(type));
      default:
        return false;
    }
  }

  /**
   * This is a unified interface for event plugins to be installed and configured.
   *
   * Event plugins can implement the following properties:
   *
   *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
   *     Required. When a top-level event is fired, this method is expected to
   *     extract synthetic events that will in turn be queued and dispatched.
   *
   *   `eventTypes` {object}
   *     Optional, plugins that fire events must publish a mapping of registration
   *     names that are used to register listeners. Values of this mapping must
   *     be objects that contain `registrationName` or `phasedRegistrationNames`.
   *
   *   `executeDispatch` {function(object, function, string)}
   *     Optional, allows plugins to override how an event gets dispatched. By
   *     default, the listener is simply invoked.
   *
   * Each plugin that is injected into `EventsPluginHub` is immediately operable.
   *
   * @public
   */
  var EventPluginHub = {

    /**
     * Methods for injecting dependencies.
     */
    injection: {

      /**
       * @param {array} InjectedEventPluginOrder
       * @public
       */
      injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

      /**
       * @param {object} injectedNamesToPlugins Map from names to plugin modules.
       */
      injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

    },

    /**
     * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
     *
     * @param {object} inst The instance, which is the source of events.
     * @param {string} registrationName Name of listener (e.g. `onClick`).
     * @param {function} listener The callback to store.
     */
    putListener: function (inst, registrationName, listener) {
      !(typeof listener === 'function') ? 'production' !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

      var key = getDictionaryKey(inst);
      var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
      bankForRegistrationName[key] = listener;

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.didPutListener) {
        PluginModule.didPutListener(inst, registrationName, listener);
      }
    },

    /**
     * @param {object} inst The instance, which is the source of events.
     * @param {string} registrationName Name of listener (e.g. `onClick`).
     * @return {?function} The stored callback.
     */
    getListener: function (inst, registrationName) {
      // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
      // live here; needs to be moved to a better place soon
      var bankForRegistrationName = listenerBank[registrationName];
      if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
        return null;
      }
      var key = getDictionaryKey(inst);
      return bankForRegistrationName && bankForRegistrationName[key];
    },

    /**
     * Deletes a listener from the registration bank.
     *
     * @param {object} inst The instance, which is the source of events.
     * @param {string} registrationName Name of listener (e.g. `onClick`).
     */
    deleteListener: function (inst, registrationName) {
      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      var bankForRegistrationName = listenerBank[registrationName];
      // TODO: This should never be null -- when is it?
      if (bankForRegistrationName) {
        var key = getDictionaryKey(inst);
        delete bankForRegistrationName[key];
      }
    },

    /**
     * Deletes all listeners for the DOM element with the supplied ID.
     *
     * @param {object} inst The instance, which is the source of events.
     */
    deleteAllListeners: function (inst) {
      var key = getDictionaryKey(inst);
      for (var registrationName in listenerBank) {
        if (!listenerBank.hasOwnProperty(registrationName)) {
          continue;
        }

        if (!listenerBank[registrationName][key]) {
          continue;
        }

        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(inst, registrationName);
        }

        delete listenerBank[registrationName][key];
      }
    },

    /**
     * Allows registered plugins an opportunity to extract events from top-level
     * native browser events.
     *
     * @return {*} An accumulation of synthetic events.
     * @internal
     */
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events;
      var plugins = EventPluginRegistry.plugins;
      for (var i = 0; i < plugins.length; i++) {
        // Not every plugin in the ordering may be loaded at runtime.
        var possiblePlugin = plugins[i];
        if (possiblePlugin) {
          var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
          if (extractedEvents) {
            events = accumulateInto(events, extractedEvents);
          }
        }
      }
      return events;
    },

    /**
     * Enqueues a synthetic event that should be dispatched when
     * `processEventQueue` is invoked.
     *
     * @param {*} events An accumulation of synthetic events.
     * @internal
     */
    enqueueEvents: function (events) {
      if (events) {
        eventQueue = accumulateInto(eventQueue, events);
      }
    },

    /**
     * Dispatches all synthetic events on the event queue.
     *
     * @internal
     */
    processEventQueue: function (simulated) {
      // Set `eventQueue` to null before processing it so that we can tell if more
      // events get enqueued while processing.
      var processingEventQueue = eventQueue;
      eventQueue = null;
      if (simulated) {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
      } else {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
      }
      !!eventQueue ? 'production' !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
      // This would be a good time to rethrow if any of the event handlers threw.
      ReactErrorUtils.rethrowCaughtError();
    },

    /**
     * These are needed for tests only. Do not use!
     */
    __purge: function () {
      listenerBank = {};
    },

    __getListenerBank: function () {
      return listenerBank;
    }

  };

  module.exports = EventPluginHub;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactEventEmitterMixin.js', ['./EventPluginHub', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('./EventPluginHub');

  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue(false);
  }

  var ReactEventEmitterMixin = {

    /**
     * Streams a fired top-level event to `EventPluginHub` where plugins have the
     * opportunity to create `ReactEvent`s to be dispatched.
     */
    handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    }
  };

  module.exports = ReactEventEmitterMixin;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ViewportMetrics.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ViewportMetrics = {

    currentScrollLeft: 0,

    currentScrollTop: 0,

    refreshScrollValues: function (scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }

  };

  module.exports = ViewportMetrics;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getVendorPrefixedEventName.js', ['fbjs/lib/ExecutionEnvironment', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  /**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * @param {string} styleProp
   * @param {string} eventName
   * @returns {object}
   */
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};

    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes['Webkit' + styleProp] = 'webkit' + eventName;
    prefixes['Moz' + styleProp] = 'moz' + eventName;
    prefixes['ms' + styleProp] = 'MS' + eventName;
    prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

    return prefixes;
  }

  /**
   * A list of event names to a configurable list of vendor prefixes.
   */
  var vendorPrefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
    animationstart: makePrefixMap('Animation', 'AnimationStart'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  /**
   * Event names that have already been detected and prefixed (if applicable).
   */
  var prefixedEventNames = {};

  /**
   * Element to check for prefixes on.
   */
  var style = {};

  /**
   * Bootstrap if a DOM exists.
   */
  if (ExecutionEnvironment.canUseDOM) {
    style = document.createElement('div').style;

    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are usable, and if not remove them from the map.
    if (!('AnimationEvent' in window)) {
      delete vendorPrefixes.animationend.animation;
      delete vendorPrefixes.animationiteration.animation;
      delete vendorPrefixes.animationstart.animation;
    }

    // Same as above
    if (!('TransitionEvent' in window)) {
      delete vendorPrefixes.transitionend.transition;
    }
  }

  /**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * @param {string} eventName
   * @returns {string}
   */
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    } else if (!vendorPrefixes[eventName]) {
      return eventName;
    }

    var prefixMap = vendorPrefixes[eventName];

    for (var styleProp in prefixMap) {
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
        return prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }

    return '';
  }

  module.exports = getVendorPrefixedEventName;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/isEventSupported.js', ['fbjs/lib/ExecutionEnvironment', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
  }

  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }

    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;

    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  module.exports = isEventSupported;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactBrowserEventEmitter.js', ['object-assign', './EventPluginRegistry', './ReactEventEmitterMixin', './ViewportMetrics', './getVendorPrefixedEventName', './isEventSupported', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactEventEmitterMixin = $__require('./ReactEventEmitterMixin');
  var ViewportMetrics = $__require('./ViewportMetrics');

  var getVendorPrefixedEventName = $__require('./getVendorPrefixedEventName');
  var isEventSupported = $__require('./isEventSupported');

  /**
   * Summary of `ReactBrowserEventEmitter` event handling:
   *
   *  - Top-level delegation is used to trap most native browser events. This
   *    may only occur in the main thread and is the responsibility of
   *    ReactEventListener, which is injected and can therefore support pluggable
   *    event sources. This is the only work that occurs in the main thread.
   *
   *  - We normalize and de-duplicate events to account for browser quirks. This
   *    may be done in the worker thread.
   *
   *  - Forward these native events (with the associated top-level type used to
   *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
   *    to extract any synthetic events.
   *
   *  - The `EventPluginHub` will then process each event by annotating them with
   *    "dispatches", a sequence of listeners and IDs that care about that event.
   *
   *  - The `EventPluginHub` then dispatches the events.
   *
   * Overview of React and the event system:
   *
   * +------------+    .
   * |    DOM     |    .
   * +------------+    .
   *       |           .
   *       v           .
   * +------------+    .
   * | ReactEvent |    .
   * |  Listener  |    .
   * +------------+    .                         +-----------+
   *       |           .               +--------+|SimpleEvent|
   *       |           .               |         |Plugin     |
   * +-----|------+    .               v         +-----------+
   * |     |      |    .    +--------------+                    +------------+
   * |     +-----------.--->|EventPluginHub|                    |    Event   |
   * |            |    .    |              |     +-----------+  | Propagators|
   * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
   * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
   * |            |    .    |              |     +-----------+  |  utilities |
   * |     +-----------.--->|              |                    +------------+
   * |     |      |    .    +--------------+
   * +-----|------+    .                ^        +-----------+
   *       |           .                |        |Enter/Leave|
   *       +           .                +-------+|Plugin     |
   * +-------------+   .                         +-----------+
   * | application |   .
   * |-------------|   .
   * |             |   .
   * |             |   .
   * +-------------+   .
   *                   .
   *    React Core     .  General Purpose Event Plugin System
   */

  var hasEventPageXY;
  var alreadyListeningTo = {};
  var isMonitoringScrollValue = false;
  var reactTopListenersCounter = 0;

  // For events like 'submit' which don't consistently bubble (which we trap at a
  // lower node than `document`), binding at `document` would cause duplicate
  // events so we don't include them here
  var topEventMapping = {
    topAbort: 'abort',
    topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
    topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
    topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
    topBlur: 'blur',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topChange: 'change',
    topClick: 'click',
    topCompositionEnd: 'compositionend',
    topCompositionStart: 'compositionstart',
    topCompositionUpdate: 'compositionupdate',
    topContextMenu: 'contextmenu',
    topCopy: 'copy',
    topCut: 'cut',
    topDoubleClick: 'dblclick',
    topDrag: 'drag',
    topDragEnd: 'dragend',
    topDragEnter: 'dragenter',
    topDragExit: 'dragexit',
    topDragLeave: 'dragleave',
    topDragOver: 'dragover',
    topDragStart: 'dragstart',
    topDrop: 'drop',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topFocus: 'focus',
    topInput: 'input',
    topKeyDown: 'keydown',
    topKeyPress: 'keypress',
    topKeyUp: 'keyup',
    topLoadedData: 'loadeddata',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topMouseDown: 'mousedown',
    topMouseMove: 'mousemove',
    topMouseOut: 'mouseout',
    topMouseOver: 'mouseover',
    topMouseUp: 'mouseup',
    topPaste: 'paste',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topScroll: 'scroll',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topSelectionChange: 'selectionchange',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTextInput: 'textInput',
    topTimeUpdate: 'timeupdate',
    topTouchCancel: 'touchcancel',
    topTouchEnd: 'touchend',
    topTouchMove: 'touchmove',
    topTouchStart: 'touchstart',
    topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting',
    topWheel: 'wheel'
  };

  /**
   * To ensure no conflicts with other potential React instances on the page
   */
  var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

  function getListeningForDocument(mountAt) {
    // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
    // directly.
    if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
      mountAt[topListenersIDKey] = reactTopListenersCounter++;
      alreadyListeningTo[mountAt[topListenersIDKey]] = {};
    }
    return alreadyListeningTo[mountAt[topListenersIDKey]];
  }

  /**
   * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
   * example:
   *
   *   EventPluginHub.putListener('myID', 'onClick', myFunction);
   *
   * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
   *
   * @internal
   */
  var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

    /**
     * Injectable event backend
     */
    ReactEventListener: null,

    injection: {
      /**
       * @param {object} ReactEventListener
       */
      injectReactEventListener: function (ReactEventListener) {
        ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
        ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
      }
    },

    /**
     * Sets whether or not any created callbacks should be enabled.
     *
     * @param {boolean} enabled True if callbacks should be enabled.
     */
    setEnabled: function (enabled) {
      if (ReactBrowserEventEmitter.ReactEventListener) {
        ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
      }
    },

    /**
     * @return {boolean} True if callbacks are enabled.
     */
    isEnabled: function () {
      return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
    },

    /**
     * We listen for bubbled touch events on the document object.
     *
     * Firefox v8.01 (and possibly others) exhibited strange behavior when
     * mounting `onmousemove` events at some node that was not the document
     * element. The symptoms were that if your mouse is not moving over something
     * contained within that mount point (for example on the background) the
     * top-level listeners for `onmousemove` won't be called. However, if you
     * register the `mousemove` on the document object, then it will of course
     * catch all `mousemove`s. This along with iOS quirks, justifies restricting
     * top-level listeners to the document object only, at least for these
     * movement types of events and possibly all events.
     *
     * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
     *
     * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
     * they bubble to document.
     *
     * @param {string} registrationName Name of listener (e.g. `onClick`).
     * @param {object} contentDocumentHandle Document which owns the container
     */
    listenTo: function (registrationName, contentDocumentHandle) {
      var mountAt = contentDocumentHandle;
      var isListening = getListeningForDocument(mountAt);
      var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

      for (var i = 0; i < dependencies.length; i++) {
        var dependency = dependencies[i];
        if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
          if (dependency === 'topWheel') {
            if (isEventSupported('wheel')) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
            } else if (isEventSupported('mousewheel')) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
            } else {
              // Firefox needs to capture a different mouse scroll event.
              // @see http://www.quirksmode.org/dom/events/tests/scroll.html
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
            }
          } else if (dependency === 'topScroll') {

            if (isEventSupported('scroll', true)) {
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
            } else {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
            }
          } else if (dependency === 'topFocus' || dependency === 'topBlur') {

            if (isEventSupported('focus', true)) {
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
              ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
            } else if (isEventSupported('focusin')) {
              // IE has `focusin` and `focusout` events which bubble.
              // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
            }

            // to make sure blur and focus event listeners are only attached once
            isListening.topBlur = true;
            isListening.topFocus = true;
          } else if (topEventMapping.hasOwnProperty(dependency)) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
          }

          isListening[dependency] = true;
        }
      }
    },

    trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
      return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
    },

    trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
      return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
    },

    /**
     * Protect against document.createEvent() returning null
     * Some popup blocker extensions appear to do this:
     * https://github.com/facebook/react/issues/6887
     */
    supportsEventPageXY: function () {
      if (!document.createEvent) {
        return false;
      }
      var ev = document.createEvent('MouseEvent');
      return ev != null && 'pageX' in ev;
    },

    /**
     * Listens to window scroll and resize events. We cache scroll values so that
     * application code can access them without triggering reflows.
     *
     * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
     * pageX/pageY isn't supported (legacy browsers).
     *
     * NOTE: Scroll events do not bubble.
     *
     * @see http://www.quirksmode.org/dom/events/scroll.html
     */
    ensureScrollValueMonitoring: function () {
      if (hasEventPageXY === undefined) {
        hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
      }
      if (!hasEventPageXY && !isMonitoringScrollValue) {
        var refresh = ViewportMetrics.refreshScrollValues;
        ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
        isMonitoringScrollValue = true;
      }
    }

  });

  module.exports = ReactBrowserEventEmitter;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMComponentFlags.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentFlags = {
    hasCachedChildNodes: 1 << 0
  };

  module.exports = ReactDOMComponentFlags;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMComponentTree.js', ['./reactProdInvariant', './DOMProperty', './ReactDOMComponentFlags', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var DOMProperty = $__require('./DOMProperty');
  var ReactDOMComponentFlags = $__require('./ReactDOMComponentFlags');

  var invariant = $__require('fbjs/lib/invariant');

  var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
  var Flags = ReactDOMComponentFlags;

  var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

  /**
   * Drill down (through composites and empty components) until we get a host or
   * host text component.
   *
   * This is pretty polymorphic but unavoidable with the current structure we have
   * for `_renderedChildren`.
   */
  function getRenderedHostOrTextFromComponent(component) {
    var rendered;
    while (rendered = component._renderedComponent) {
      component = rendered;
    }
    return component;
  }

  /**
   * Populate `_hostNode` on the rendered host/text component with the given
   * DOM node. The passed `inst` can be a composite.
   */
  function precacheNode(inst, node) {
    var hostInst = getRenderedHostOrTextFromComponent(inst);
    hostInst._hostNode = node;
    node[internalInstanceKey] = hostInst;
  }

  function uncacheNode(inst) {
    var node = inst._hostNode;
    if (node) {
      delete node[internalInstanceKey];
      inst._hostNode = null;
    }
  }

  /**
   * Populate `_hostNode` on each child of `inst`, assuming that the children
   * match up with the DOM (element) children of `node`.
   *
   * We cache entire levels at once to avoid an n^2 problem where we access the
   * children of a node sequentially and have to walk from the start to our target
   * node every time.
   *
   * Since we update `_renderedChildren` and the actual DOM at (slightly)
   * different times, we could race here and see a newer `_renderedChildren` than
   * the DOM nodes we see. To avoid this, ReactMultiChild calls
   * `prepareToManageChildren` before we change `_renderedChildren`, at which
   * time the container's child nodes are always cached (until it unmounts).
   */
  function precacheChildNodes(inst, node) {
    if (inst._flags & Flags.hasCachedChildNodes) {
      return;
    }
    var children = inst._renderedChildren;
    var childNode = node.firstChild;
    outer: for (var name in children) {
      if (!children.hasOwnProperty(name)) {
        continue;
      }
      var childInst = children[name];
      var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
      if (childID === 0) {
        // We're currently unmounting this child in ReactMultiChild; skip it.
        continue;
      }
      // We assume the child nodes are in the same order as the child instances.
      for (; childNode !== null; childNode = childNode.nextSibling) {
        if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
          precacheNode(childInst, childNode);
          continue outer;
        }
      }
      // We reached the end of the DOM children without finding an ID match.
      !false ? 'production' !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
    }
    inst._flags |= Flags.hasCachedChildNodes;
  }

  /**
   * Given a DOM node, return the closest ReactDOMComponent or
   * ReactDOMTextComponent instance ancestor.
   */
  function getClosestInstanceFromNode(node) {
    if (node[internalInstanceKey]) {
      return node[internalInstanceKey];
    }

    // Walk up the tree until we find an ancestor whose instance we have cached.
    var parents = [];
    while (!node[internalInstanceKey]) {
      parents.push(node);
      if (node.parentNode) {
        node = node.parentNode;
      } else {
        // Top of the tree. This node must not be part of a React tree (or is
        // unmounted, potentially).
        return null;
      }
    }

    var closest;
    var inst;
    for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
      closest = inst;
      if (parents.length) {
        precacheChildNodes(inst, node);
      }
    }

    return closest;
  }

  /**
   * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
   * instance, or null if the node was not rendered by this React.
   */
  function getInstanceFromNode(node) {
    var inst = getClosestInstanceFromNode(node);
    if (inst != null && inst._hostNode === node) {
      return inst;
    } else {
      return null;
    }
  }

  /**
   * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
   * DOM node.
   */
  function getNodeFromInstance(inst) {
    // Without this first invariant, passing a non-DOM-component triggers the next
    // invariant for a missing parent, which is super confusing.
    !(inst._hostNode !== undefined) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

    if (inst._hostNode) {
      return inst._hostNode;
    }

    // Walk up the tree until we find an ancestor whose DOM node we have cached.
    var parents = [];
    while (!inst._hostNode) {
      parents.push(inst);
      !inst._hostParent ? 'production' !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
      inst = inst._hostParent;
    }

    // Now parents contains each ancestor that does *not* have a cached native
    // node, and `inst` is the deepest ancestor that does.
    for (; parents.length; inst = parents.pop()) {
      precacheChildNodes(inst, inst._hostNode);
    }

    return inst._hostNode;
  }

  var ReactDOMComponentTree = {
    getClosestInstanceFromNode: getClosestInstanceFromNode,
    getInstanceFromNode: getInstanceFromNode,
    getNodeFromInstance: getNodeFromInstance,
    precacheChildNodes: precacheChildNodes,
    precacheNode: precacheNode,
    uncacheNode: uncacheNode
  };

  module.exports = ReactDOMComponentTree;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/validateDOMNesting.js', ['object-assign', 'fbjs/lib/emptyFunction', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var warning = $__require('fbjs/lib/warning');

  var validateDOMNesting = emptyFunction;

  if ('production' !== 'production') {
    // This validation code was written based on the HTML5 parsing spec:
    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    //
    // Note: this does not catch all invalid nesting, nor does it try to (as it's
    // not clear what practical benefit doing so provides); instead, we warn only
    // for cases where the parser will give a parse tree differing from what React
    // intended. For example, <b><div></div></b> is invalid but we don't warn
    // because it still parses correctly; we do warn for other cases like nested
    // <p> tags where the beginning of the second element implicitly closes the
    // first, causing a confusing mess.

    // https://html.spec.whatwg.org/multipage/syntax.html#special
    var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

    // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
    // TODO: Distinguish by namespace here -- for <title>, including it here
    // errs on the side of fewer warnings
    'foreignObject', 'desc', 'title'];

    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
    var buttonScopeTags = inScopeTags.concat(['button']);

    // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
    var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

    var emptyAncestorInfo = {
      current: null,

      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,

      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null
    };

    var updatedAncestorInfo = function (oldInfo, tag, instance) {
      var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
      var info = { tag: tag, instance: instance };

      if (inScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.aTagInScope = null;
        ancestorInfo.buttonTagInScope = null;
        ancestorInfo.nobrTagInScope = null;
      }
      if (buttonScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.pTagInButtonScope = null;
      }

      // See rules for 'li', 'dd', 'dt' start tags in
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
      if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
        ancestorInfo.listItemTagAutoclosing = null;
        ancestorInfo.dlItemTagAutoclosing = null;
      }

      ancestorInfo.current = info;

      if (tag === 'form') {
        ancestorInfo.formTag = info;
      }
      if (tag === 'a') {
        ancestorInfo.aTagInScope = info;
      }
      if (tag === 'button') {
        ancestorInfo.buttonTagInScope = info;
      }
      if (tag === 'nobr') {
        ancestorInfo.nobrTagInScope = info;
      }
      if (tag === 'p') {
        ancestorInfo.pTagInButtonScope = info;
      }
      if (tag === 'li') {
        ancestorInfo.listItemTagAutoclosing = info;
      }
      if (tag === 'dd' || tag === 'dt') {
        ancestorInfo.dlItemTagAutoclosing = info;
      }

      return ancestorInfo;
    };

    /**
     * Returns whether
     */
    var isTagValidWithParent = function (tag, parentTag) {
      // First, let's check if we're in an unusual parsing mode...
      switch (parentTag) {
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
        case 'select':
          return tag === 'option' || tag === 'optgroup' || tag === '#text';
        case 'optgroup':
          return tag === 'option' || tag === '#text';
        // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
        // but
        case 'option':
          return tag === '#text';

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
        // No special behavior since these rules fall back to "in body" mode for
        // all except special table nodes which cause bad parsing behavior anyway.

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
        case 'tr':
          return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
        case 'tbody':
        case 'thead':
        case 'tfoot':
          return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
        case 'colgroup':
          return tag === 'col' || tag === 'template';

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
        case 'table':
          return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
        case 'head':
          return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

        // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
        case 'html':
          return tag === 'head' || tag === 'body';
        case '#document':
          return tag === 'html';
      }

      // Probably in the "in body" parsing mode, so we outlaw only tag combos
      // where the parsing rules cause implicit opens or closes to be added.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
      switch (tag) {
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

        case 'rp':
        case 'rt':
          return impliedEndTags.indexOf(parentTag) === -1;

        case 'body':
        case 'caption':
        case 'col':
        case 'colgroup':
        case 'frame':
        case 'head':
        case 'html':
        case 'tbody':
        case 'td':
        case 'tfoot':
        case 'th':
        case 'thead':
        case 'tr':
          // These tags are only valid with a few parents that have special child
          // parsing rules -- if we're down here, then none of those matched and
          // so we allow it only if we don't know what the parent is, as all other
          // cases are invalid.
          return parentTag == null;
      }

      return true;
    };

    /**
     * Returns whether
     */
    var findInvalidAncestorForTag = function (tag, ancestorInfo) {
      switch (tag) {
        case 'address':
        case 'article':
        case 'aside':
        case 'blockquote':
        case 'center':
        case 'details':
        case 'dialog':
        case 'dir':
        case 'div':
        case 'dl':
        case 'fieldset':
        case 'figcaption':
        case 'figure':
        case 'footer':
        case 'header':
        case 'hgroup':
        case 'main':
        case 'menu':
        case 'nav':
        case 'ol':
        case 'p':
        case 'section':
        case 'summary':
        case 'ul':

        case 'pre':
        case 'listing':

        case 'table':

        case 'hr':

        case 'xmp':

        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return ancestorInfo.pTagInButtonScope;

        case 'form':
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

        case 'li':
          return ancestorInfo.listItemTagAutoclosing;

        case 'dd':
        case 'dt':
          return ancestorInfo.dlItemTagAutoclosing;

        case 'button':
          return ancestorInfo.buttonTagInScope;

        case 'a':
          // Spec says something about storing a list of markers, but it sounds
          // equivalent to this check.
          return ancestorInfo.aTagInScope;

        case 'nobr':
          return ancestorInfo.nobrTagInScope;
      }

      return null;
    };

    /**
     * Given a ReactCompositeComponent instance, return a list of its recursive
     * owners, starting at the root and ending with the instance itself.
     */
    var findOwnerStack = function (instance) {
      if (!instance) {
        return [];
      }

      var stack = [];
      do {
        stack.push(instance);
      } while (instance = instance._currentElement._owner);
      stack.reverse();
      return stack;
    };

    var didWarn = {};

    validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;

      if (childText != null) {
        'production' !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
        childTag = '#text';
      }

      var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
      var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      var problematic = invalidParent || invalidAncestor;

      if (problematic) {
        var ancestorTag = problematic.tag;
        var ancestorInstance = problematic.instance;

        var childOwner = childInstance && childInstance._currentElement._owner;
        var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

        var childOwners = findOwnerStack(childOwner);
        var ancestorOwners = findOwnerStack(ancestorOwner);

        var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
        var i;

        var deepestCommon = -1;
        for (i = 0; i < minStackLen; i++) {
          if (childOwners[i] === ancestorOwners[i]) {
            deepestCommon = i;
          } else {
            break;
          }
        }

        var UNKNOWN = '(unknown)';
        var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
          return inst.getName() || UNKNOWN;
        });
        var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
          return inst.getName() || UNKNOWN;
        });
        var ownerInfo = [].concat(
        // If the parent and child instances have a common owner ancestor, start
        // with that -- otherwise we just start with the parent's owners.
        deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
        // If we're warning about an invalid (non-parent) ancestry, add '...'
        invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
        if (didWarn[warnKey]) {
          return;
        }
        didWarn[warnKey] = true;

        var tagDisplayName = childTag;
        var whitespaceInfo = '';
        if (childTag === '#text') {
          if (/\S/.test(childText)) {
            tagDisplayName = 'Text nodes';
          } else {
            tagDisplayName = 'Whitespace text nodes';
            whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
          }
        } else {
          tagDisplayName = '<' + childTag + '>';
        }

        if (invalidParent) {
          var info = '';
          if (ancestorTag === 'table' && childTag === 'tr') {
            info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
          }
          'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
        } else {
          'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
        }
      }
    };

    validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

    // For testing
    validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;
      return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
    };
  }

  module.exports = validateDOMNesting;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMContainerInfo.js', ['./validateDOMNesting', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var validateDOMNesting = $__require('./validateDOMNesting');

  var DOC_NODE_TYPE = 9;

  function ReactDOMContainerInfo(topLevelWrapper, node) {
    var info = {
      _topLevelWrapper: topLevelWrapper,
      _idCounter: 1,
      _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
      _node: node,
      _tag: node ? node.nodeName.toLowerCase() : null,
      _namespaceURI: node ? node.namespaceURI : null
    };
    if ('production' !== 'production') {
      info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
    }
    return info;
  }

  module.exports = ReactDOMContainerInfo;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMFeatureFlags.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMFeatureFlags = {
    useCreateElement: true,
    useFiber: false
  };

  module.exports = ReactDOMFeatureFlags;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/adler32.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var MOD = 65521;

  // adler32 is not cryptographically strong, and is only used to sanity check that
  // markup generated on the server matches the markup generated on the client.
  // This implementation (a modified version of the SheetJS version) has been optimized
  // for our use case, at the expense of conforming to the adler32 specification
  // for non-ascii inputs.
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      var n = Math.min(i + 4096, m);
      for (; i < n; i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }

  module.exports = adler32;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactMarkupChecksum.js', ['./adler32', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var adler32 = $__require('./adler32');

  var TAG_END = /\/?>/;
  var COMMENT_START = /^<\!\-\-/;

  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',

    /**
     * @param {string} markup Markup string
     * @return {string} Markup string with checksum attribute attached
     */
    addChecksumToMarkup: function (markup) {
      var checksum = adler32(markup);

      // Add checksum (handle both parent tags, comments and self-closing tags)
      if (COMMENT_START.test(markup)) {
        return markup;
      } else {
        return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
      }
    },

    /**
     * @param {string} markup to use
     * @param {DOMElement} element root React element
     * @returns {boolean} whether or not the markup is the same
     */
    canReuseMarkup: function (markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };

  module.exports = ReactMarkupChecksum;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactUpdateQueue.js', ['./reactProdInvariant', 'react/lib/ReactCurrentOwner', './ReactInstanceMap', './ReactInstrumentation', './ReactUpdates', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactUpdates = $__require('./ReactUpdates');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  function enqueueUpdate(internalInstance) {
    ReactUpdates.enqueueUpdate(internalInstance);
  }

  function formatUnexpectedArgument(arg) {
    var type = typeof arg;
    if (type !== 'object') {
      return type;
    }
    var displayName = arg.constructor && arg.constructor.name || type;
    var keys = Object.keys(arg);
    if (keys.length > 0 && keys.length < 20) {
      return displayName + ' (keys: ' + keys.join(', ') + ')';
    }
    return displayName;
  }

  function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (!internalInstance) {
      if ('production' !== 'production') {
        var ctor = publicInstance.constructor;
        // Only warn when we have a callerName. Otherwise we should be silent.
        // We're probably calling from enqueueCallback. We don't want to warn
        // there because we already warned for the corresponding lifecycle method.
        'production' !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
      }
      return null;
    }

    if ('production' !== 'production') {
      'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
    }

    return internalInstance;
  }

  /**
   * ReactUpdateQueue allows for state updates to be scheduled into a later
   * reconciliation step.
   */
  var ReactUpdateQueue = {

    /**
     * Checks whether or not this composite component is mounted.
     * @param {ReactClass} publicInstance The instance we want to test.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function (publicInstance) {
      if ('production' !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
          owner._warnedAboutRefsInRender = true;
        }
      }
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (internalInstance) {
        // During componentWillMount and render this will still be null but after
        // that will always render to something. At least for now. So we can use
        // this hack.
        return !!internalInstance._renderedComponent;
      } else {
        return false;
      }
    },

    /**
     * Enqueue a callback that will be executed after all the pending updates
     * have processed.
     *
     * @param {ReactClass} publicInstance The instance to use as `this` context.
     * @param {?function} callback Called after state is updated.
     * @param {string} callerName Name of the calling function in the public API.
     * @internal
     */
    enqueueCallback: function (publicInstance, callback, callerName) {
      ReactUpdateQueue.validateCallback(callback, callerName);
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

      // Previously we would throw an error if we didn't have an internal
      // instance. Since we want to make it a no-op instead, we mirror the same
      // behavior we have in other enqueue* methods.
      // We also need to ignore callbacks in componentWillMount. See
      // enqueueUpdates.
      if (!internalInstance) {
        return null;
      }

      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
      // TODO: The callback here is ignored when setState is called from
      // componentWillMount. Either fix it or disallow doing so completely in
      // favor of getInitialState. Alternatively, we can disallow
      // componentWillMount during server-side rendering.
      enqueueUpdate(internalInstance);
    },

    enqueueCallbackInternal: function (internalInstance, callback) {
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
      enqueueUpdate(internalInstance);
    },

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @internal
     */
    enqueueForceUpdate: function (publicInstance) {
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

      if (!internalInstance) {
        return;
      }

      internalInstance._pendingForceUpdate = true;

      enqueueUpdate(internalInstance);
    },

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} completeState Next state.
     * @internal
     */
    enqueueReplaceState: function (publicInstance, completeState) {
      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

      if (!internalInstance) {
        return;
      }

      internalInstance._pendingStateQueue = [completeState];
      internalInstance._pendingReplaceState = true;

      enqueueUpdate(internalInstance);
    },

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} partialState Next partial state to be merged with state.
     * @internal
     */
    enqueueSetState: function (publicInstance, partialState) {
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onSetState();
        'production' !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
      }

      var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

      if (!internalInstance) {
        return;
      }

      var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
      queue.push(partialState);

      enqueueUpdate(internalInstance);
    },

    enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
      internalInstance._pendingElement = nextElement;
      // TODO: introduce _pendingContext instead of setting it directly.
      internalInstance._context = nextContext;
      enqueueUpdate(internalInstance);
    },

    validateCallback: function (callback, callerName) {
      !(!callback || typeof callback === 'function') ? 'production' !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
    }

  };

  module.exports = ReactUpdateQueue;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/CallbackQueue.js', ['./reactProdInvariant', './PooledClass', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var PooledClass = $__require('./PooledClass');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * A specialized pseudo-event module to help keep track of components waiting to
   * be notified when their DOM representations are available for use.
   *
   * This implements `PooledClass`, so you should never need to instantiate this.
   * Instead, use `CallbackQueue.getPooled()`.
   *
   * @class ReactMountReady
   * @implements PooledClass
   * @internal
   */

  var CallbackQueue = function () {
    function CallbackQueue(arg) {
      _classCallCheck(this, CallbackQueue);

      this._callbacks = null;
      this._contexts = null;
      this._arg = arg;
    }

    /**
     * Enqueues a callback to be invoked when `notifyAll` is invoked.
     *
     * @param {function} callback Invoked when `notifyAll` is invoked.
     * @param {?object} context Context to call `callback` with.
     * @internal
     */

    CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
      this._callbacks = this._callbacks || [];
      this._callbacks.push(callback);
      this._contexts = this._contexts || [];
      this._contexts.push(context);
    };

    /**
     * Invokes all enqueued callbacks and clears the queue. This is invoked after
     * the DOM representation of a component has been created or updated.
     *
     * @internal
     */

    CallbackQueue.prototype.notifyAll = function notifyAll() {
      var callbacks = this._callbacks;
      var contexts = this._contexts;
      var arg = this._arg;
      if (callbacks && contexts) {
        !(callbacks.length === contexts.length) ? 'production' !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
        this._callbacks = null;
        this._contexts = null;
        for (var i = 0; i < callbacks.length; i++) {
          callbacks[i].call(contexts[i], arg);
        }
        callbacks.length = 0;
        contexts.length = 0;
      }
    };

    CallbackQueue.prototype.checkpoint = function checkpoint() {
      return this._callbacks ? this._callbacks.length : 0;
    };

    CallbackQueue.prototype.rollback = function rollback(len) {
      if (this._callbacks && this._contexts) {
        this._callbacks.length = len;
        this._contexts.length = len;
      }
    };

    /**
     * Resets the internal queue.
     *
     * @internal
     */

    CallbackQueue.prototype.reset = function reset() {
      this._callbacks = null;
      this._contexts = null;
    };

    /**
     * `PooledClass` looks for this.
     */

    CallbackQueue.prototype.destructor = function destructor() {
      this.reset();
    };

    return CallbackQueue;
  }();

  module.exports = PooledClass.addPoolingTo(CallbackQueue);
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/PooledClass.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Static poolers. Several custom versions for each potential number of
   * arguments. A completely generic pooler is easy to implement, but would
   * require accessing the `arguments` object. In each of these, `this` refers to
   * the Class itself, not an instance. If any others are needed, simply add them
   * here, or in their own files.
   */
  var oneArgumentPooler = function (copyFieldsFrom) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, copyFieldsFrom);
      return instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };

  var twoArgumentPooler = function (a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };

  var threeArgumentPooler = function (a1, a2, a3) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3);
      return instance;
    } else {
      return new Klass(a1, a2, a3);
    }
  };

  var fourArgumentPooler = function (a1, a2, a3, a4) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };

  var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4, a5);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4, a5);
    }
  };

  var standardReleaser = function (instance) {
    var Klass = this;
    !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };

  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;

  /**
   * Augments `CopyConstructor` to be a poolable class, augmenting only the class
   * itself (statically) not adding any prototypical fields. Any CopyConstructor
   * you give this may have a `poolSize` property, and will look for a
   * prototypical `destructor` on instances.
   *
   * @param {Function} CopyConstructor Constructor that can be used to reset.
   * @param {Function} pooler Customizable pooler.
   */
  var addPoolingTo = function (CopyConstructor, pooler) {
    // Casting as any so that flow ignores the actual implementation and trusts
    // it to match the type we declared
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };

  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler,
    fiveArgumentPooler: fiveArgumentPooler
  };

  module.exports = PooledClass;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactFeatureFlags.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactFeatureFlags = {
    // When true, call console.time() before and .timeEnd() after each top-level
    // render (both initial renders and updates). Useful when looking at prod-mode
    // timeline profiles in Chrome, for example.
    logTopLevelRenders: false
  };

  module.exports = ReactFeatureFlags;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/Transaction.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  var OBSERVED_ERROR = {};

  /**
   * `Transaction` creates a black box that is able to wrap any method such that
   * certain invariants are maintained before and after the method is invoked
   * (Even if an exception is thrown while invoking the wrapped method). Whoever
   * instantiates a transaction can provide enforcers of the invariants at
   * creation time. The `Transaction` class itself will supply one additional
   * automatic invariant for you - the invariant that any transaction instance
   * should not be run while it is already being run. You would typically create a
   * single instance of a `Transaction` for reuse multiple times, that potentially
   * is used to wrap several different methods. Wrappers are extremely simple -
   * they only require implementing two methods.
   *
   * <pre>
   *                       wrappers (injected at creation time)
   *                                      +        +
   *                                      |        |
   *                    +-----------------|--------|--------------+
   *                    |                 v        |              |
   *                    |      +---------------+   |              |
   *                    |   +--|    wrapper1   |---|----+         |
   *                    |   |  +---------------+   v    |         |
   *                    |   |          +-------------+  |         |
   *                    |   |     +----|   wrapper2  |--------+   |
   *                    |   |     |    +-------------+  |     |   |
   *                    |   |     |                     |     |   |
   *                    |   v     v                     v     v   | wrapper
   *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
   * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
   * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
   *                    | |   | |   |   |         |   |   | |   | |
   *                    | |   | |   |   |         |   |   | |   | |
   *                    | |   | |   |   |         |   |   | |   | |
   *                    | +---+ +---+   +---------+   +---+ +---+ |
   *                    |  initialize                    close    |
   *                    +-----------------------------------------+
   * </pre>
   *
   * Use cases:
   * - Preserving the input selection ranges before/after reconciliation.
   *   Restoring selection even in the event of an unexpected error.
   * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
   *   while guaranteeing that afterwards, the event system is reactivated.
   * - Flushing a queue of collected DOM mutations to the main UI thread after a
   *   reconciliation takes place in a worker thread.
   * - Invoking any collected `componentDidUpdate` callbacks after rendering new
   *   content.
   * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
   *   to preserve the `scrollTop` (an automatic scroll aware DOM).
   * - (Future use case): Layout calculations before and after DOM updates.
   *
   * Transactional plugin API:
   * - A module that has an `initialize` method that returns any precomputation.
   * - and a `close` method that accepts the precomputation. `close` is invoked
   *   when the wrapped process is completed, or has failed.
   *
   * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
   * that implement `initialize` and `close`.
   * @return {Transaction} Single transaction for reuse in thread.
   *
   * @class Transaction
   */
  var TransactionImpl = {
    /**
     * Sets up this instance so that it is prepared for collecting metrics. Does
     * so such that this setup method may be used on an instance that is already
     * initialized, in a way that does not consume additional memory upon reuse.
     * That can be useful if you decide to make your subclass of this mixin a
     * "PooledClass".
     */
    reinitializeTransaction: function () {
      this.transactionWrappers = this.getTransactionWrappers();
      if (this.wrapperInitData) {
        this.wrapperInitData.length = 0;
      } else {
        this.wrapperInitData = [];
      }
      this._isInTransaction = false;
    },

    _isInTransaction: false,

    /**
     * @abstract
     * @return {Array<TransactionWrapper>} Array of transaction wrappers.
     */
    getTransactionWrappers: null,

    isInTransaction: function () {
      return !!this._isInTransaction;
    },

    /**
     * Executes the function within a safety window. Use this for the top level
     * methods that result in large amounts of computation/mutations that would
     * need to be safety checked. The optional arguments helps prevent the need
     * to bind in many cases.
     *
     * @param {function} method Member of scope to call.
     * @param {Object} scope Scope to invoke from.
     * @param {Object?=} a Argument to pass to the method.
     * @param {Object?=} b Argument to pass to the method.
     * @param {Object?=} c Argument to pass to the method.
     * @param {Object?=} d Argument to pass to the method.
     * @param {Object?=} e Argument to pass to the method.
     * @param {Object?=} f Argument to pass to the method.
     *
     * @return {*} Return value from `method`.
     */
    perform: function (method, scope, a, b, c, d, e, f) {
      !!this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
      var errorThrown;
      var ret;
      try {
        this._isInTransaction = true;
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // one of these calls threw.
        errorThrown = true;
        this.initializeAll(0);
        ret = method.call(scope, a, b, c, d, e, f);
        errorThrown = false;
      } finally {
        try {
          if (errorThrown) {
            // If `method` throws, prefer to show that stack trace over any thrown
            // by invoking `closeAll`.
            try {
              this.closeAll(0);
            } catch (err) {}
          } else {
            // Since `method` didn't throw, we don't want to silence the exception
            // here.
            this.closeAll(0);
          }
        } finally {
          this._isInTransaction = false;
        }
      }
      return ret;
    },

    initializeAll: function (startIndex) {
      var transactionWrappers = this.transactionWrappers;
      for (var i = startIndex; i < transactionWrappers.length; i++) {
        var wrapper = transactionWrappers[i];
        try {
          // Catching errors makes debugging more difficult, so we start with the
          // OBSERVED_ERROR state before overwriting it with the real return value
          // of initialize -- if it's still set to OBSERVED_ERROR in the finally
          // block, it means wrapper.initialize threw.
          this.wrapperInitData[i] = OBSERVED_ERROR;
          this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
        } finally {
          if (this.wrapperInitData[i] === OBSERVED_ERROR) {
            // The initializer for wrapper i threw an error; initialize the
            // remaining wrappers but silence any exceptions from them to ensure
            // that the first error is the one to bubble up.
            try {
              this.initializeAll(i + 1);
            } catch (err) {}
          }
        }
      }
    },

    /**
     * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
     * them the respective return values of `this.transactionWrappers.init[i]`
     * (`close`rs that correspond to initializers that failed will not be
     * invoked).
     */
    closeAll: function (startIndex) {
      !this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
      var transactionWrappers = this.transactionWrappers;
      for (var i = startIndex; i < transactionWrappers.length; i++) {
        var wrapper = transactionWrappers[i];
        var initData = this.wrapperInitData[i];
        var errorThrown;
        try {
          // Catching errors makes debugging more difficult, so we start with
          // errorThrown set to true before setting it to false after calling
          // close -- if it's still set to true in the finally block, it means
          // wrapper.close threw.
          errorThrown = true;
          if (initData !== OBSERVED_ERROR && wrapper.close) {
            wrapper.close.call(this, initData);
          }
          errorThrown = false;
        } finally {
          if (errorThrown) {
            // The closer for wrapper i threw an error; close the remaining
            // wrappers but silence any exceptions from them to ensure that the
            // first error is the one to bubble up.
            try {
              this.closeAll(i + 1);
            } catch (e) {}
          }
        }
      }
      this.wrapperInitData.length = 0;
    }
  };

  module.exports = TransactionImpl;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactUpdates.js', ['./reactProdInvariant', 'object-assign', './CallbackQueue', './PooledClass', './ReactFeatureFlags', './ReactReconciler', './Transaction', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var CallbackQueue = $__require('./CallbackQueue');
  var PooledClass = $__require('./PooledClass');
  var ReactFeatureFlags = $__require('./ReactFeatureFlags');
  var ReactReconciler = $__require('./ReactReconciler');
  var Transaction = $__require('./Transaction');

  var invariant = $__require('fbjs/lib/invariant');

  var dirtyComponents = [];
  var updateBatchNumber = 0;
  var asapCallbackQueue = CallbackQueue.getPooled();
  var asapEnqueued = false;

  var batchingStrategy = null;

  function ensureInjected() {
    !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
  }

  var NESTED_UPDATES = {
    initialize: function () {
      this.dirtyComponentsLength = dirtyComponents.length;
    },
    close: function () {
      if (this.dirtyComponentsLength !== dirtyComponents.length) {
        // Additional updates were enqueued by componentDidUpdate handlers or
        // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
        // these new updates so that if A's componentDidUpdate calls setState on
        // B, B will update before the callback A's updater provided when calling
        // setState.
        dirtyComponents.splice(0, this.dirtyComponentsLength);
        flushBatchedUpdates();
      } else {
        dirtyComponents.length = 0;
      }
    }
  };

  var UPDATE_QUEUEING = {
    initialize: function () {
      this.callbackQueue.reset();
    },
    close: function () {
      this.callbackQueue.notifyAll();
    }
  };

  var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

  function ReactUpdatesFlushTransaction() {
    this.reinitializeTransaction();
    this.dirtyComponentsLength = null;
    this.callbackQueue = CallbackQueue.getPooled();
    this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
    /* useCreateElement */true);
  }

  _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
    getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    },

    destructor: function () {
      this.dirtyComponentsLength = null;
      CallbackQueue.release(this.callbackQueue);
      this.callbackQueue = null;
      ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
      this.reconcileTransaction = null;
    },

    perform: function (method, scope, a) {
      // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
      // with this transaction's wrappers around it.
      return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
    }
  });

  PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

  function batchedUpdates(callback, a, b, c, d, e) {
    ensureInjected();
    return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
  }

  /**
   * Array comparator for ReactComponents by mount ordering.
   *
   * @param {ReactComponent} c1 first component you're comparing
   * @param {ReactComponent} c2 second component you're comparing
   * @return {number} Return value usable by Array.prototype.sort().
   */
  function mountOrderComparator(c1, c2) {
    return c1._mountOrder - c2._mountOrder;
  }

  function runBatchedUpdates(transaction) {
    var len = transaction.dirtyComponentsLength;
    !(len === dirtyComponents.length) ? 'production' !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

    // Since reconciling a component higher in the owner hierarchy usually (not
    // always -- see shouldComponentUpdate()) will reconcile children, reconcile
    // them before their children by sorting the array.
    dirtyComponents.sort(mountOrderComparator);

    // Any updates enqueued while reconciling must be performed after this entire
    // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
    // C, B could update twice in a single batch if C's render enqueues an update
    // to B (since B would have already updated, we should skip it, and the only
    // way we can know to do so is by checking the batch counter).
    updateBatchNumber++;

    for (var i = 0; i < len; i++) {
      // If a component is unmounted before pending changes apply, it will still
      // be here, but we assume that it has cleared its _pendingCallbacks and
      // that performUpdateIfNecessary is a noop.
      var component = dirtyComponents[i];

      // If performUpdateIfNecessary happens to enqueue any new updates, we
      // shouldn't execute the callbacks until the next render happens, so
      // stash the callbacks first
      var callbacks = component._pendingCallbacks;
      component._pendingCallbacks = null;

      var markerName;
      if (ReactFeatureFlags.logTopLevelRenders) {
        var namedComponent = component;
        // Duck type TopLevelWrapper. This is probably always true.
        if (component._currentElement.type.isReactTopLevelWrapper) {
          namedComponent = component._renderedComponent;
        }
        markerName = 'React update: ' + namedComponent.getName();
        console.time(markerName);
      }

      ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

      if (markerName) {
        console.timeEnd(markerName);
      }

      if (callbacks) {
        for (var j = 0; j < callbacks.length; j++) {
          transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
        }
      }
    }
  }

  var flushBatchedUpdates = function () {
    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
    // array and perform any updates enqueued by mount-ready handlers (i.e.,
    // componentDidUpdate) but we need to check here too in order to catch
    // updates enqueued by setState callbacks and asap calls.
    while (dirtyComponents.length || asapEnqueued) {
      if (dirtyComponents.length) {
        var transaction = ReactUpdatesFlushTransaction.getPooled();
        transaction.perform(runBatchedUpdates, null, transaction);
        ReactUpdatesFlushTransaction.release(transaction);
      }

      if (asapEnqueued) {
        asapEnqueued = false;
        var queue = asapCallbackQueue;
        asapCallbackQueue = CallbackQueue.getPooled();
        queue.notifyAll();
        CallbackQueue.release(queue);
      }
    }
  };

  /**
   * Mark a component as needing a rerender, adding an optional callback to a
   * list of functions which will be executed once the rerender occurs.
   */
  function enqueueUpdate(component) {
    ensureInjected();

    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (This is called by each top-level update
    // function, like setState, forceUpdate, etc.; creation and
    // destruction of top-level components is guarded in ReactMount.)

    if (!batchingStrategy.isBatchingUpdates) {
      batchingStrategy.batchedUpdates(enqueueUpdate, component);
      return;
    }

    dirtyComponents.push(component);
    if (component._updateBatchNumber == null) {
      component._updateBatchNumber = updateBatchNumber + 1;
    }
  }

  /**
   * Enqueue a callback to be run at the end of the current batching cycle. Throws
   * if no updates are currently being performed.
   */
  function asap(callback, context) {
    !batchingStrategy.isBatchingUpdates ? 'production' !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
    asapCallbackQueue.enqueue(callback, context);
    asapEnqueued = true;
  }

  var ReactUpdatesInjection = {
    injectReconcileTransaction: function (ReconcileTransaction) {
      !ReconcileTransaction ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
      ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
    },

    injectBatchingStrategy: function (_batchingStrategy) {
      !_batchingStrategy ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
      !(typeof _batchingStrategy.batchedUpdates === 'function') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
      !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
      batchingStrategy = _batchingStrategy;
    }
  };

  var ReactUpdates = {
    /**
     * React references `ReactReconcileTransaction` using this property in order
     * to allow dependency injection.
     *
     * @internal
     */
    ReactReconcileTransaction: null,

    batchedUpdates: batchedUpdates,
    enqueueUpdate: enqueueUpdate,
    flushBatchedUpdates: flushBatchedUpdates,
    injection: ReactUpdatesInjection,
    asap: asap
  };

  module.exports = ReactUpdates;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactComponentEnvironment.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  var injected = false;

  var ReactComponentEnvironment = {

    /**
     * Optionally injectable hook for swapping out mount images in the middle of
     * the tree.
     */
    replaceNodeWithMarkup: null,

    /**
     * Optionally injectable hook for processing a queue of child updates. Will
     * later move into MultiChildComponents.
     */
    processChildrenUpdates: null,

    injection: {
      injectEnvironment: function (environment) {
        !!injected ? 'production' !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
        ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
        ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
        injected = true;
      }
    }

  };

  module.exports = ReactComponentEnvironment;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactErrorUtils.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var caughtError = null;

  /**
   * Call a function while guarding against errors that happens within it.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} a First argument
   * @param {*} b Second argument
   */
  function invokeGuardedCallback(name, func, a) {
    try {
      func(a);
    } catch (x) {
      if (caughtError === null) {
        caughtError = x;
      }
    }
  }

  var ReactErrorUtils = {
    invokeGuardedCallback: invokeGuardedCallback,

    /**
     * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
     * handler are sure to be rethrown by rethrowCaughtError.
     */
    invokeGuardedCallbackWithCatch: invokeGuardedCallback,

    /**
     * During execution of guarded functions we will capture the first error which
     * we will rethrow to be handled by the top level error handler.
     */
    rethrowCaughtError: function () {
      if (caughtError) {
        var error = caughtError;
        caughtError = null;
        throw error;
      }
    }
  };

  if ('production' !== 'production') {
    /**
     * To help development we can get better devtools integration by simulating a
     * real browser event.
     */
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
      var fakeNode = document.createElement('react');
      ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
        var boundFunc = func.bind(null, a);
        var evtType = 'react-' + name;
        fakeNode.addEventListener(evtType, boundFunc, false);
        var evt = document.createEvent('Event');
        // $FlowFixMe https://github.com/facebook/flow/issues/2336
        evt.initEvent(evtType, false, false);
        fakeNode.dispatchEvent(evt);
        fakeNode.removeEventListener(evtType, boundFunc, false);
      };
    }
  }

  module.exports = ReactErrorUtils;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactInstanceMap.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   */

  // TODO: Replace this with ES6: var ReactInstanceMap = new Map();

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactInstanceMap = {

    /**
     * This API should be called `delete` but we'd have to make sure to always
     * transform these to strings for IE support. When this transform is fully
     * supported we can rename it.
     */
    remove: function (key) {
      key._reactInternalInstance = undefined;
    },

    get: function (key) {
      return key._reactInternalInstance;
    },

    has: function (key) {
      return key._reactInternalInstance !== undefined;
    },

    set: function (key, value) {
      key._reactInternalInstance = value;
    }

  };

  module.exports = ReactInstanceMap;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactNodeTypes.js', ['./reactProdInvariant', 'react/lib/React', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var React = $__require('react/lib/React');

  var invariant = $__require('fbjs/lib/invariant');

  var ReactNodeTypes = {
    HOST: 0,
    COMPOSITE: 1,
    EMPTY: 2,

    getType: function (node) {
      if (node === null || node === false) {
        return ReactNodeTypes.EMPTY;
      } else if (React.isValidElement(node)) {
        if (typeof node.type === 'function') {
          return ReactNodeTypes.COMPOSITE;
        } else {
          return ReactNodeTypes.HOST;
        }
      }
      !false ? 'production' !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
    }
  };

  module.exports = ReactNodeTypes;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactOwner.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  function isValidOwner(object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  }

  /**
   * ReactOwners are capable of storing references to owned components.
   *
   * All components are capable of //being// referenced by owner components, but
   * only ReactOwner components are capable of //referencing// owned components.
   * The named reference is known as a "ref".
   *
   * Refs are available when mounted and updated during reconciliation.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return (
   *         <div onClick={this.handleClick}>
   *           <CustomComponent ref="custom" />
   *         </div>
   *       );
   *     },
   *     handleClick: function() {
   *       this.refs.custom.handleClick();
   *     },
   *     componentDidMount: function() {
   *       this.refs.custom.initialize();
   *     }
   *   });
   *
   * Refs should rarely be used. When refs are used, they should only be done to
   * control data that is not handled by React's data flow.
   *
   * @class ReactOwner
   */
  var ReactOwner = {
    /**
     * Adds a component by ref to an owner component.
     *
     * @param {ReactComponent} component Component to reference.
     * @param {string} ref Name by which to refer to the component.
     * @param {ReactOwner} owner Component on which to record the ref.
     * @final
     * @internal
     */
    addComponentAsRefTo: function (component, ref, owner) {
      !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
      owner.attachRef(ref, component);
    },

    /**
     * Removes a component by ref from an owner component.
     *
     * @param {ReactComponent} component Component to dereference.
     * @param {string} ref Name of the ref to remove.
     * @param {ReactOwner} owner Component on which the ref is recorded.
     * @final
     * @internal
     */
    removeComponentAsRefFrom: function (component, ref, owner) {
      !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
      var ownerPublicInstance = owner.getPublicInstance();
      // Check that `component`'s owner is still alive and that `component` is still the current ref
      // because we do not want to detach the ref if another component stole it.
      if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
        owner.detachRef(ref);
      }
    }

  };

  module.exports = ReactOwner;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactRef.js', ['./ReactOwner', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactOwner = $__require('./ReactOwner');

  var ReactRef = {};

  function attachRef(ref, component, owner) {
    if (typeof ref === 'function') {
      ref(component.getPublicInstance());
    } else {
      // Legacy ref
      ReactOwner.addComponentAsRefTo(component, ref, owner);
    }
  }

  function detachRef(ref, component, owner) {
    if (typeof ref === 'function') {
      ref(null);
    } else {
      // Legacy ref
      ReactOwner.removeComponentAsRefFrom(component, ref, owner);
    }
  }

  ReactRef.attachRefs = function (instance, element) {
    if (element === null || typeof element !== 'object') {
      return;
    }
    var ref = element.ref;
    if (ref != null) {
      attachRef(ref, instance, element._owner);
    }
  };

  ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
    // If either the owner or a `ref` has changed, make sure the newest owner
    // has stored a reference to `this`, and the previous owner (if different)
    // has forgotten the reference to `this`. We use the element instead
    // of the public this.props because the post processing cannot determine
    // a ref. The ref conceptually lives on the element.

    // TODO: Should this even be possible? The owner cannot change because
    // it's forbidden by shouldUpdateReactComponent. The ref can change
    // if you swap the keys of but not the refs. Reconsider where this check
    // is made. It probably belongs where the key checking and
    // instantiateReactComponent is done.

    var prevRef = null;
    var prevOwner = null;
    if (prevElement !== null && typeof prevElement === 'object') {
      prevRef = prevElement.ref;
      prevOwner = prevElement._owner;
    }

    var nextRef = null;
    var nextOwner = null;
    if (nextElement !== null && typeof nextElement === 'object') {
      nextRef = nextElement.ref;
      nextOwner = nextElement._owner;
    }

    return prevRef !== nextRef ||
    // If owner changes but we have an unchanged function ref, don't update refs
    typeof nextRef === 'string' && nextOwner !== prevOwner;
  };

  ReactRef.detachRefs = function (instance, element) {
    if (element === null || typeof element !== 'object') {
      return;
    }
    var ref = element.ref;
    if (ref != null) {
      detachRef(ref, instance, element._owner);
    }
  };

  module.exports = ReactRef;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactReconciler.js', ['./ReactRef', './ReactInstrumentation', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactRef = $__require('./ReactRef');
  var ReactInstrumentation = $__require('./ReactInstrumentation');

  var warning = $__require('fbjs/lib/warning');

  /**
   * Helper to call ReactRef.attachRefs with this composite component, split out
   * to avoid allocations in the transaction mount-ready queue.
   */
  function attachRefs() {
    ReactRef.attachRefs(this, this._currentElement);
  }

  var ReactReconciler = {

    /**
     * Initializes the component, renders markup, and registers event listeners.
     *
     * @param {ReactComponent} internalInstance
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {?object} the containing host component instance
     * @param {?object} info about the host container
     * @return {?string} Rendered markup to be inserted into the DOM.
     * @final
     * @internal
     */
    mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
    ) {
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
        }
      }
      var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
      if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
        }
      }
      return markup;
    },

    /**
     * Returns a value that can be passed to
     * ReactComponentEnvironment.replaceNodeWithMarkup.
     */
    getHostNode: function (internalInstance) {
      return internalInstance.getHostNode();
    },

    /**
     * Releases any resources allocated by `mountComponent`.
     *
     * @final
     * @internal
     */
    unmountComponent: function (internalInstance, safely) {
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
        }
      }
      ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
      internalInstance.unmountComponent(safely);
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
        }
      }
    },

    /**
     * Update a component using a new element.
     *
     * @param {ReactComponent} internalInstance
     * @param {ReactElement} nextElement
     * @param {ReactReconcileTransaction} transaction
     * @param {object} context
     * @internal
     */
    receiveComponent: function (internalInstance, nextElement, transaction, context) {
      var prevElement = internalInstance._currentElement;

      if (nextElement === prevElement && context === internalInstance._context) {
        // Since elements are immutable after the owner is rendered,
        // we can do a cheap identity compare here to determine if this is a
        // superfluous reconcile. It's possible for state to be mutable but such
        // change should trigger an update of the owner which would recreate
        // the element. We explicitly check for the existence of an owner since
        // it's possible for an element created outside a composite to be
        // deeply mutated and reused.

        // TODO: Bailing out early is just a perf optimization right?
        // TODO: Removing the return statement should affect correctness?
        return;
      }

      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
        }
      }

      var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

      if (refsChanged) {
        ReactRef.detachRefs(internalInstance, prevElement);
      }

      internalInstance.receiveComponent(nextElement, transaction, context);

      if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
        transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
      }

      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
        }
      }
    },

    /**
     * Flush any dirty changes in a component.
     *
     * @param {ReactComponent} internalInstance
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
      if (internalInstance._updateBatchNumber !== updateBatchNumber) {
        // The component's enqueued batch number should always be the current
        // batch or the following one.
        'production' !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
        return;
      }
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
        }
      }
      internalInstance.performUpdateIfNecessary(transaction);
      if ('production' !== 'production') {
        if (internalInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
        }
      }
    }

  };

  module.exports = ReactReconciler;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactPropTypeLocationNames.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypeLocationNames = {};

  if ('production' !== 'production') {
    ReactPropTypeLocationNames = {
      prop: 'prop',
      context: 'context',
      childContext: 'child context'
    };
  }

  module.exports = ReactPropTypeLocationNames;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactPropTypesSecret.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/checkReactTypeSpec.js', ['./reactProdInvariant', './ReactPropTypeLocationNames', './ReactPropTypesSecret', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'react/lib/ReactComponentTreeHook', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var ReactPropTypesSecret = $__require('./ReactPropTypesSecret');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var ReactComponentTreeHook;

  if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
    // Temporary hack.
    // Inline requires don't work well with Jest:
    // https://github.com/facebook/react/issues/7240
    // Remove the inline requires when we don't need them anymore:
    // https://github.com/facebook/react/pull/7178
    ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
  }

  var loggedTypeFailures = {};

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?object} element The React element that is being type-checked
   * @param {?number} debugID The React component instance that is being type-checked
   * @private
   */
  function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var componentStackInfo = '';

          if ('production' !== 'production') {
            if (!ReactComponentTreeHook) {
              ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
            }
            if (debugID !== null) {
              componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
            } else if (element !== null) {
              componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
            }
          }

          'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
        }
      }
    }
  }

  module.exports = checkReactTypeSpec;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/shallowEqual.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   * 
   */

  /*eslint-disable no-self-compare */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      // Added the nonzero y check to make Flow happy, but it is redundant
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }

  /**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    // Test for A's keys different from B.
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactCompositeComponent.js', ['./reactProdInvariant', 'object-assign', 'react/lib/React', './ReactComponentEnvironment', 'react/lib/ReactCurrentOwner', './ReactErrorUtils', './ReactInstanceMap', './ReactInstrumentation', './ReactNodeTypes', './ReactReconciler', './checkReactTypeSpec', 'fbjs/lib/emptyObject', 'fbjs/lib/invariant', 'fbjs/lib/shallowEqual', './shouldUpdateReactComponent', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var React = $__require('react/lib/React');
  var ReactComponentEnvironment = $__require('./ReactComponentEnvironment');
  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var ReactErrorUtils = $__require('./ReactErrorUtils');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactNodeTypes = $__require('./ReactNodeTypes');
  var ReactReconciler = $__require('./ReactReconciler');

  if ('production' !== 'production') {
    var checkReactTypeSpec = $__require('./checkReactTypeSpec');
  }

  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var shallowEqual = $__require('fbjs/lib/shallowEqual');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var warning = $__require('fbjs/lib/warning');

  var CompositeTypes = {
    ImpureClass: 0,
    PureClass: 1,
    StatelessFunctional: 2
  };

  function StatelessComponent(Component) {}
  StatelessComponent.prototype.render = function () {
    var Component = ReactInstanceMap.get(this)._currentElement.type;
    var element = Component(this.props, this.context, this.updater);
    warnIfInvalidElement(Component, element);
    return element;
  };

  function warnIfInvalidElement(Component, element) {
    if ('production' !== 'production') {
      'production' !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
      'production' !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
    }
  }

  function shouldConstruct(Component) {
    return !!(Component.prototype && Component.prototype.isReactComponent);
  }

  function isPureComponent(Component) {
    return !!(Component.prototype && Component.prototype.isPureReactComponent);
  }

  // Separated into a function to contain deoptimizations caused by try/finally.
  function measureLifeCyclePerf(fn, debugID, timerType) {
    if (debugID === 0) {
      // Top-level wrappers (see ReactMount) and empty components (see
      // ReactDOMEmptyComponent) are invisible to hooks and devtools.
      // Both are implementation details that should go away in the future.
      return fn();
    }

    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
    try {
      return fn();
    } finally {
      ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
    }
  }

  /**
   * ------------------ The Life-Cycle of a Composite Component ------------------
   *
   * - constructor: Initialization of state. The instance is now retained.
   *   - componentWillMount
   *   - render
   *   - [children's constructors]
   *     - [children's componentWillMount and render]
   *     - [children's componentDidMount]
   *     - componentDidMount
   *
   *       Update Phases:
   *       - componentWillReceiveProps (only called if parent updated)
   *       - shouldComponentUpdate
   *         - componentWillUpdate
   *           - render
   *           - [children's constructors or receive props phases]
   *         - componentDidUpdate
   *
   *     - componentWillUnmount
   *     - [children's componentWillUnmount]
   *   - [children destroyed]
   * - (destroyed): The instance is now blank, released by React and ready for GC.
   *
   * -----------------------------------------------------------------------------
   */

  /**
   * An incrementing ID assigned to each component when it is mounted. This is
   * used to enforce the order in which `ReactUpdates` updates dirty components.
   *
   * @private
   */
  var nextMountID = 1;

  /**
   * @lends {ReactCompositeComponent.prototype}
   */
  var ReactCompositeComponent = {

    /**
     * Base constructor for all composite component.
     *
     * @param {ReactElement} element
     * @final
     * @internal
     */
    construct: function (element) {
      this._currentElement = element;
      this._rootNodeID = 0;
      this._compositeType = null;
      this._instance = null;
      this._hostParent = null;
      this._hostContainerInfo = null;

      // See ReactUpdateQueue
      this._updateBatchNumber = null;
      this._pendingElement = null;
      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;

      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._context = null;
      this._mountOrder = 0;
      this._topLevelWrapper = null;

      // See ReactUpdates and ReactUpdateQueue.
      this._pendingCallbacks = null;

      // ComponentWillUnmount shall only be called once
      this._calledComponentWillUnmount = false;

      if ('production' !== 'production') {
        this._warnedAboutRefsInRender = false;
      }
    },

    /**
     * Initializes the component, renders markup, and registers event listeners.
     *
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {?object} hostParent
     * @param {?object} hostContainerInfo
     * @param {?object} context
     * @return {?string} Rendered markup to be inserted into the DOM.
     * @final
     * @internal
     */
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      var _this = this;

      this._context = context;
      this._mountOrder = nextMountID++;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;

      var publicProps = this._currentElement.props;
      var publicContext = this._processContext(context);

      var Component = this._currentElement.type;

      var updateQueue = transaction.getUpdateQueue();

      // Initialize the public class
      var doConstruct = shouldConstruct(Component);
      var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
      var renderedElement;

      // Support functional components
      if (!doConstruct && (inst == null || inst.render == null)) {
        renderedElement = inst;
        warnIfInvalidElement(Component, renderedElement);
        !(inst === null || inst === false || React.isValidElement(inst)) ? 'production' !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
        inst = new StatelessComponent(Component);
        this._compositeType = CompositeTypes.StatelessFunctional;
      } else {
        if (isPureComponent(Component)) {
          this._compositeType = CompositeTypes.PureClass;
        } else {
          this._compositeType = CompositeTypes.ImpureClass;
        }
      }

      if ('production' !== 'production') {
        // This will throw later in _renderValidatedComponent, but add an early
        // warning now to help debugging
        if (inst.render == null) {
          'production' !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
        }

        var propsMutated = inst.props !== publicProps;
        var componentName = Component.displayName || Component.name || 'Component';

        'production' !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
      }

      // These should be set up in the constructor, but as a convenience for
      // simpler class abstractions, we set them up after the fact.
      inst.props = publicProps;
      inst.context = publicContext;
      inst.refs = emptyObject;
      inst.updater = updateQueue;

      this._instance = inst;

      // Store a reference from the instance back to the internal representation
      ReactInstanceMap.set(inst, this);

      if ('production' !== 'production') {
        // Since plain JS classes are defined without any special initialization
        // logic, we can not catch common errors early. Therefore, we have to
        // catch them here, at initialization time, instead.
        'production' !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
        'production' !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
        'production' !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
        'production' !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
        'production' !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
        'production' !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
        'production' !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
      }

      var initialState = inst.state;
      if (initialState === undefined) {
        inst.state = initialState = null;
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;

      var markup;
      if (inst.unstable_handleError) {
        markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
      } else {
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      }

      if (inst.componentDidMount) {
        if ('production' !== 'production') {
          transaction.getReactMountReady().enqueue(function () {
            measureLifeCyclePerf(function () {
              return inst.componentDidMount();
            }, _this._debugID, 'componentDidMount');
          });
        } else {
          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
        }
      }

      return markup;
    },

    _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
      if ('production' !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      }
    },

    _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
      var Component = this._currentElement.type;

      if (doConstruct) {
        if ('production' !== 'production') {
          return measureLifeCyclePerf(function () {
            return new Component(publicProps, publicContext, updateQueue);
          }, this._debugID, 'ctor');
        } else {
          return new Component(publicProps, publicContext, updateQueue);
        }
      }

      // This can still be an instance in case of factory components
      // but we'll count this as time spent rendering as the more common case.
      if ('production' !== 'production') {
        return measureLifeCyclePerf(function () {
          return Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'render');
      } else {
        return Component(publicProps, publicContext, updateQueue);
      }
    },

    performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
      var markup;
      var checkpoint = transaction.checkpoint();
      try {
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      } catch (e) {
        // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
        transaction.rollback(checkpoint);
        this._instance.unstable_handleError(e);
        if (this._pendingStateQueue) {
          this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
        }
        checkpoint = transaction.checkpoint();

        this._renderedComponent.unmountComponent(true);
        transaction.rollback(checkpoint);

        // Try again - we've informed the component about the error, so they can render an error message this time.
        // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
      }
      return markup;
    },

    performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
      var inst = this._instance;

      var debugID = 0;
      if ('production' !== 'production') {
        debugID = this._debugID;
      }

      if (inst.componentWillMount) {
        if ('production' !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillMount();
          }, debugID, 'componentWillMount');
        } else {
          inst.componentWillMount();
        }
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingStateQueue` without triggering a re-render.
        if (this._pendingStateQueue) {
          inst.state = this._processPendingState(inst.props, inst.context);
        }
      }

      // If not a stateless component, we now render
      if (renderedElement === undefined) {
        renderedElement = this._renderValidatedComponent();
      }

      var nodeType = ReactNodeTypes.getType(renderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

      if ('production' !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      return markup;
    },

    getHostNode: function () {
      return ReactReconciler.getHostNode(this._renderedComponent);
    },

    /**
     * Releases any resources allocated by `mountComponent`.
     *
     * @final
     * @internal
     */
    unmountComponent: function (safely) {
      if (!this._renderedComponent) {
        return;
      }

      var inst = this._instance;

      if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
        inst._calledComponentWillUnmount = true;

        if (safely) {
          var name = this.getName() + '.componentWillUnmount()';
          ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
        } else {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillUnmount();
            }, this._debugID, 'componentWillUnmount');
          } else {
            inst.componentWillUnmount();
          }
        }
      }

      if (this._renderedComponent) {
        ReactReconciler.unmountComponent(this._renderedComponent, safely);
        this._renderedNodeType = null;
        this._renderedComponent = null;
        this._instance = null;
      }

      // Reset pending fields
      // Even if this component is scheduled for another update in ReactUpdates,
      // it would still be ignored because these fields are reset.
      this._pendingStateQueue = null;
      this._pendingReplaceState = false;
      this._pendingForceUpdate = false;
      this._pendingCallbacks = null;
      this._pendingElement = null;

      // These fields do not really need to be reset since this object is no
      // longer accessible.
      this._context = null;
      this._rootNodeID = 0;
      this._topLevelWrapper = null;

      // Delete the reference from the instance to this internal representation
      // which allow the internals to be properly cleaned up even if the user
      // leaks a reference to the public instance.
      ReactInstanceMap.remove(inst);

      // Some existing components rely on inst.props even after they've been
      // destroyed (in event handlers).
      // TODO: inst.props = null;
      // TODO: inst.state = null;
      // TODO: inst.context = null;
    },

    /**
     * Filters the context object to only contain keys specified in
     * `contextTypes`
     *
     * @param {object} context
     * @return {?object}
     * @private
     */
    _maskContext: function (context) {
      var Component = this._currentElement.type;
      var contextTypes = Component.contextTypes;
      if (!contextTypes) {
        return emptyObject;
      }
      var maskedContext = {};
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
      return maskedContext;
    },

    /**
     * Filters the context object to only contain keys specified in
     * `contextTypes`, and asserts that they are valid.
     *
     * @param {object} context
     * @return {?object}
     * @private
     */
    _processContext: function (context) {
      var maskedContext = this._maskContext(context);
      if ('production' !== 'production') {
        var Component = this._currentElement.type;
        if (Component.contextTypes) {
          this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
        }
      }
      return maskedContext;
    },

    /**
     * @param {object} currentContext
     * @return {object}
     * @private
     */
    _processChildContext: function (currentContext) {
      var Component = this._currentElement.type;
      var inst = this._instance;
      var childContext;

      if (inst.getChildContext) {
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onBeginProcessingChildContext();
          try {
            childContext = inst.getChildContext();
          } finally {
            ReactInstrumentation.debugTool.onEndProcessingChildContext();
          }
        } else {
          childContext = inst.getChildContext();
        }
      }

      if (childContext) {
        !(typeof Component.childContextTypes === 'object') ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
        if ('production' !== 'production') {
          this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
        }
        for (var name in childContext) {
          !(name in Component.childContextTypes) ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
        }
        return _assign({}, currentContext, childContext);
      }
      return currentContext;
    },

    /**
     * Assert that the context types are valid
     *
     * @param {object} typeSpecs Map of context field to a ReactPropType
     * @param {object} values Runtime values that need to be type-checked
     * @param {string} location e.g. "prop", "context", "child context"
     * @private
     */
    _checkContextTypes: function (typeSpecs, values, location) {
      if ('production' !== 'production') {
        checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
      }
    },

    receiveComponent: function (nextElement, transaction, nextContext) {
      var prevElement = this._currentElement;
      var prevContext = this._context;

      this._pendingElement = null;

      this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
    },

    /**
     * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
     * is set, update the component.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    performUpdateIfNecessary: function (transaction) {
      if (this._pendingElement != null) {
        ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
      } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
        this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
      } else {
        this._updateBatchNumber = null;
      }
    },

    /**
     * Perform an update to a mounted component. The componentWillReceiveProps and
     * shouldComponentUpdate methods are called, then (assuming the update isn't
     * skipped) the remaining update lifecycle methods are called and the DOM
     * representation is updated.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @param {ReactElement} prevParentElement
     * @param {ReactElement} nextParentElement
     * @internal
     * @overridable
     */
    updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
      var inst = this._instance;
      !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

      var willReceive = false;
      var nextContext;

      // Determine if the context has changed or not
      if (this._context === nextUnmaskedContext) {
        nextContext = inst.context;
      } else {
        nextContext = this._processContext(nextUnmaskedContext);
        willReceive = true;
      }

      var prevProps = prevParentElement.props;
      var nextProps = nextParentElement.props;

      // Not a simple state update but a props update
      if (prevParentElement !== nextParentElement) {
        willReceive = true;
      }

      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.
      if (willReceive && inst.componentWillReceiveProps) {
        if ('production' !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillReceiveProps(nextProps, nextContext);
          }, this._debugID, 'componentWillReceiveProps');
        } else {
          inst.componentWillReceiveProps(nextProps, nextContext);
        }
      }

      var nextState = this._processPendingState(nextProps, nextContext);
      var shouldUpdate = true;

      if (!this._pendingForceUpdate) {
        if (inst.shouldComponentUpdate) {
          if ('production' !== 'production') {
            shouldUpdate = measureLifeCyclePerf(function () {
              return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
            }, this._debugID, 'shouldComponentUpdate');
          } else {
            shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }
        } else {
          if (this._compositeType === CompositeTypes.PureClass) {
            shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
          }
        }
      }

      if ('production' !== 'production') {
        'production' !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
      }

      this._updateBatchNumber = null;
      if (shouldUpdate) {
        this._pendingForceUpdate = false;
        // Will set `this.props`, `this.state` and `this.context`.
        this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
      } else {
        // If it's determined that a component should not update, we still want
        // to set props and state but we shortcut the rest of the update.
        this._currentElement = nextParentElement;
        this._context = nextUnmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
      }
    },

    _processPendingState: function (props, context) {
      var inst = this._instance;
      var queue = this._pendingStateQueue;
      var replace = this._pendingReplaceState;
      this._pendingReplaceState = false;
      this._pendingStateQueue = null;

      if (!queue) {
        return inst.state;
      }

      if (replace && queue.length === 1) {
        return queue[0];
      }

      var nextState = _assign({}, replace ? queue[0] : inst.state);
      for (var i = replace ? 1 : 0; i < queue.length; i++) {
        var partial = queue[i];
        _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
      }

      return nextState;
    },

    /**
     * Merges new props and state, notifies delegate methods of update and
     * performs update.
     *
     * @param {ReactElement} nextElement Next element
     * @param {object} nextProps Next public object to set as properties.
     * @param {?object} nextState Next object to set as state.
     * @param {?object} nextContext Next public object to set as context.
     * @param {ReactReconcileTransaction} transaction
     * @param {?object} unmaskedContext
     * @private
     */
    _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
      var _this2 = this;

      var inst = this._instance;

      var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
      var prevProps;
      var prevState;
      var prevContext;
      if (hasComponentDidUpdate) {
        prevProps = inst.props;
        prevState = inst.state;
        prevContext = inst.context;
      }

      if (inst.componentWillUpdate) {
        if ('production' !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'componentWillUpdate');
        } else {
          inst.componentWillUpdate(nextProps, nextState, nextContext);
        }
      }

      this._currentElement = nextElement;
      this._context = unmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;

      this._updateRenderedComponent(transaction, unmaskedContext);

      if (hasComponentDidUpdate) {
        if ('production' !== 'production') {
          transaction.getReactMountReady().enqueue(function () {
            measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
          });
        } else {
          transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
        }
      }
    },

    /**
     * Call the component's `render` method and update the DOM accordingly.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    _updateRenderedComponent: function (transaction, context) {
      var prevComponentInstance = this._renderedComponent;
      var prevRenderedElement = prevComponentInstance._currentElement;
      var nextRenderedElement = this._renderValidatedComponent();

      var debugID = 0;
      if ('production' !== 'production') {
        debugID = this._debugID;
      }

      if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
        ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
      } else {
        var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
        ReactReconciler.unmountComponent(prevComponentInstance, false);

        var nodeType = ReactNodeTypes.getType(nextRenderedElement);
        this._renderedNodeType = nodeType;
        var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
        );
        this._renderedComponent = child;

        var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

        if ('production' !== 'production') {
          if (debugID !== 0) {
            var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
            ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
          }
        }

        this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
      }
    },

    /**
     * Overridden in shallow rendering.
     *
     * @protected
     */
    _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
      ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
    },

    /**
     * @protected
     */
    _renderValidatedComponentWithoutOwnerOrContext: function () {
      var inst = this._instance;
      var renderedElement;

      if ('production' !== 'production') {
        renderedElement = measureLifeCyclePerf(function () {
          return inst.render();
        }, this._debugID, 'render');
      } else {
        renderedElement = inst.render();
      }

      if ('production' !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (renderedElement === undefined && inst.render._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          renderedElement = null;
        }
      }

      return renderedElement;
    },

    /**
     * @private
     */
    _renderValidatedComponent: function () {
      var renderedElement;
      if ('production' !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
        ReactCurrentOwner.current = this;
        try {
          renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      }
      !(
      // TODO: An `isValidNode` function would probably be more appropriate
      renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? 'production' !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

      return renderedElement;
    },

    /**
     * Lazily allocates the refs object and stores `component` as `ref`.
     *
     * @param {string} ref Reference name.
     * @param {component} component Component to store as `ref`.
     * @final
     * @private
     */
    attachRef: function (ref, component) {
      var inst = this.getPublicInstance();
      !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
      var publicComponentInstance = component.getPublicInstance();
      if ('production' !== 'production') {
        var componentName = component && component.getName ? component.getName() : 'a component';
        'production' !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
      }
      var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
      refs[ref] = publicComponentInstance;
    },

    /**
     * Detaches a reference name.
     *
     * @param {string} ref Name to dereference.
     * @final
     * @private
     */
    detachRef: function (ref) {
      var refs = this.getPublicInstance().refs;
      delete refs[ref];
    },

    /**
     * Get a text description of the component that can be used to identify it
     * in error messages.
     * @return {string} The name or null.
     * @internal
     */
    getName: function () {
      var type = this._currentElement.type;
      var constructor = this._instance && this._instance.constructor;
      return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
    },

    /**
     * Get the publicly accessible representation of this component - i.e. what
     * is exposed by refs and returned by render. Can be null for stateless
     * components.
     *
     * @return {ReactComponent} the public component instance.
     * @internal
     */
    getPublicInstance: function () {
      var inst = this._instance;
      if (this._compositeType === CompositeTypes.StatelessFunctional) {
        return null;
      }
      return inst;
    },

    // Stub
    _instantiateReactComponent: null

  };

  module.exports = ReactCompositeComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactEmptyComponent.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyComponentFactory;

  var ReactEmptyComponentInjection = {
    injectEmptyComponentFactory: function (factory) {
      emptyComponentFactory = factory;
    }
  };

  var ReactEmptyComponent = {
    create: function (instantiate) {
      return emptyComponentFactory(instantiate);
    }
  };

  ReactEmptyComponent.injection = ReactEmptyComponentInjection;

  module.exports = ReactEmptyComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactHostComponent.js', ['./reactProdInvariant', 'object-assign', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var invariant = $__require('fbjs/lib/invariant');

  var genericComponentClass = null;
  // This registry keeps track of wrapper classes around host tags.
  var tagToComponentClass = {};
  var textComponentClass = null;

  var ReactHostComponentInjection = {
    // This accepts a class that receives the tag string. This is a catch all
    // that can render any kind of tag.
    injectGenericComponentClass: function (componentClass) {
      genericComponentClass = componentClass;
    },
    // This accepts a text component class that takes the text string to be
    // rendered as props.
    injectTextComponentClass: function (componentClass) {
      textComponentClass = componentClass;
    },
    // This accepts a keyed object with classes as values. Each key represents a
    // tag. That particular tag will use this class instead of the generic one.
    injectComponentClasses: function (componentClasses) {
      _assign(tagToComponentClass, componentClasses);
    }
  };

  /**
   * Get a host internal component class for a specific tag.
   *
   * @param {ReactElement} element The element to create.
   * @return {function} The internal class constructor function.
   */
  function createInternalComponent(element) {
    !genericComponentClass ? 'production' !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
    return new genericComponentClass(element);
  }

  /**
   * @param {ReactText} text
   * @return {ReactComponent}
   */
  function createInstanceForText(text) {
    return new textComponentClass(text);
  }

  /**
   * @param {ReactComponent} component
   * @return {boolean}
   */
  function isTextComponent(component) {
    return component instanceof textComponentClass;
  }

  var ReactHostComponent = {
    createInternalComponent: createInternalComponent,
    createInstanceForText: createInstanceForText,
    isTextComponent: isTextComponent,
    injection: ReactHostComponentInjection
  };

  module.exports = ReactHostComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/getNextDebugID.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var nextDebugID = 1;

  function getNextDebugID() {
    return nextDebugID++;
  }

  module.exports = getNextDebugID;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/instantiateReactComponent.js', ['./reactProdInvariant', 'object-assign', './ReactCompositeComponent', './ReactEmptyComponent', './ReactHostComponent', './getNextDebugID', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var ReactCompositeComponent = $__require('./ReactCompositeComponent');
  var ReactEmptyComponent = $__require('./ReactEmptyComponent');
  var ReactHostComponent = $__require('./ReactHostComponent');

  var getNextDebugID = $__require('./getNextDebugID');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  // To avoid a cyclic dependency, we create the final class in this module
  var ReactCompositeComponentWrapper = function (element) {
    this.construct(element);
  };
  _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
    _instantiateReactComponent: instantiateReactComponent
  });

  function getDeclarationErrorAddendum(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }

  /**
   * Check if the type reference is a known internal type. I.e. not a user
   * provided composite type.
   *
   * @param {function} type
   * @return {boolean} Returns true if this is a valid internal type.
   */
  function isInternalComponentType(type) {
    return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
  }

  /**
   * Given a ReactNode, create an instance that will actually be mounted.
   *
   * @param {ReactNode} node
   * @param {boolean} shouldHaveDebugID
   * @return {object} A new instance of the element's constructor.
   * @protected
   */
  function instantiateReactComponent(node, shouldHaveDebugID) {
    var instance;

    if (node === null || node === false) {
      instance = ReactEmptyComponent.create(instantiateReactComponent);
    } else if (typeof node === 'object') {
      var element = node;
      !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? 'production' !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;

      // Special case string values
      if (typeof element.type === 'string') {
        instance = ReactHostComponent.createInternalComponent(element);
      } else if (isInternalComponentType(element.type)) {
        // This is temporarily available for custom components that are not string
        // representations. I.e. ART. Once those are updated to use the string
        // representation, we can drop this code path.
        instance = new element.type(element);

        // We renamed this. Allow the old name for compat. :(
        if (!instance.getHostNode) {
          instance.getHostNode = instance.getNativeNode;
        }
      } else {
        instance = new ReactCompositeComponentWrapper(element);
      }
    } else if (typeof node === 'string' || typeof node === 'number') {
      instance = ReactHostComponent.createInstanceForText(node);
    } else {
      !false ? 'production' !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
    }

    if ('production' !== 'production') {
      'production' !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
    }

    // These two fields are used by the DOM and ART diffing algorithms
    // respectively. Instead of using expandos on components, we should be
    // storing the state needed by the diffing algorithms elsewhere.
    instance._mountIndex = 0;
    instance._mountImage = null;

    if ('production' !== 'production') {
      instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
    }

    // Internal instances should fully constructed at this point, so they should
    // not get any new fields added to them at this point.
    if ('production' !== 'production') {
      if (Object.preventExtensions) {
        Object.preventExtensions(instance);
      }
    }

    return instance;
  }

  module.exports = instantiateReactComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DOMNamespaces.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMNamespaces = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
  };

  module.exports = DOMNamespaces;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/createMicrosoftUnsafeLocalFunction.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /* globals MSApp */

  'use strict';

  /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var createMicrosoftUnsafeLocalFunction = function (func) {
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      return function (arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function () {
          return func(arg0, arg1, arg2, arg3);
        });
      };
    } else {
      return func;
    }
  };

  module.exports = createMicrosoftUnsafeLocalFunction;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/setInnerHTML.js', ['fbjs/lib/ExecutionEnvironment', './DOMNamespaces', './createMicrosoftUnsafeLocalFunction', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
  var DOMNamespaces = $__require('./DOMNamespaces');

  var WHITESPACE_TEST = /^[ \r\n\t\f]/;
  var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

  var createMicrosoftUnsafeLocalFunction = $__require('./createMicrosoftUnsafeLocalFunction');

  // SVG temp container for IE lacking innerHTML
  var reusableSVGContainer;

  /**
   * Set the innerHTML property of a node, ensuring that whitespace is preserved
   * even in IE8.
   *
   * @param {DOMElement} node
   * @param {string} html
   * @internal
   */
  var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
    // IE does not have innerHTML for SVG nodes, so instead we inject the
    // new markup in a temp node and then move the child nodes across into
    // the target node
    if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;
      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }
    } else {
      node.innerHTML = html;
    }
  });

  if (ExecutionEnvironment.canUseDOM) {
    // IE8: When updating a just created node with innerHTML only leading
    // whitespace is removed. When updating an existing node with innerHTML
    // whitespace in root TextNodes is also collapsed.
    // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

    // Feature detection; only IE8 is known to behave improperly like this.
    var testElement = document.createElement('div');
    testElement.innerHTML = ' ';
    if (testElement.innerHTML === '') {
      setInnerHTML = function (node, html) {
        // Magic theory: IE8 supposedly differentiates between added and updated
        // nodes when processing innerHTML, innerHTML on updated nodes suffers
        // from worse whitespace behavior. Re-adding a node like this triggers
        // the initial and more favorable whitespace behavior.
        // TODO: What to do on a detached node?
        if (node.parentNode) {
          node.parentNode.replaceChild(node, node);
        }

        // We also implement a workaround for non-visible tags disappearing into
        // thin air on IE8, this only happens if there is no visible text
        // in-front of the non-visible tags. Piggyback on the whitespace fix
        // and simply check if any non-visible tags appear in the source.
        if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
          // Recover leading whitespace by temporarily prepending any character.
          // \uFEFF has the potential advantage of being zero-width/invisible.
          // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
          // in hopes that this is preserved even if "\uFEFF" is transformed to
          // the actual Unicode character (by Babel, for example).
          // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
          node.innerHTML = String.fromCharCode(0xFEFF) + html;

          // deleteData leaves an empty `TextNode` which offsets the index of all
          // children. Definitely want to avoid this.
          var textNode = node.firstChild;
          if (textNode.data.length === 1) {
            node.removeChild(textNode);
          } else {
            textNode.deleteData(0, 1);
          }
        } else {
          node.innerHTML = html;
        }
      };
    }
    testElement = null;
  }

  module.exports = setInnerHTML;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/shouldUpdateReactComponent.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given a `prevElement` and `nextElement`, determines if the existing
   * instance should be updated as opposed to being destroyed or replaced by a new
   * instance. Both arguments are elements. This ensures that this logic can
   * operate on stateless trees without any backing instance.
   *
   * @param {?object} prevElement
   * @param {?object} nextElement
   * @return {boolean} True if the existing instance should be updated.
   * @protected
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function shouldUpdateReactComponent(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    if (prevEmpty || nextEmpty) {
      return prevEmpty === nextEmpty;
    }

    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }

  module.exports = shouldUpdateReactComponent;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactMount.js', ['./reactProdInvariant', './DOMLazyTree', './DOMProperty', 'react/lib/React', './ReactBrowserEventEmitter', 'react/lib/ReactCurrentOwner', './ReactDOMComponentTree', './ReactDOMContainerInfo', './ReactDOMFeatureFlags', './ReactFeatureFlags', './ReactInstanceMap', './ReactInstrumentation', './ReactMarkupChecksum', './ReactReconciler', './ReactUpdateQueue', './ReactUpdates', 'fbjs/lib/emptyObject', './instantiateReactComponent', 'fbjs/lib/invariant', './setInnerHTML', './shouldUpdateReactComponent', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var DOMLazyTree = $__require('./DOMLazyTree');
  var DOMProperty = $__require('./DOMProperty');
  var React = $__require('react/lib/React');
  var ReactBrowserEventEmitter = $__require('./ReactBrowserEventEmitter');
  var ReactCurrentOwner = $__require('react/lib/ReactCurrentOwner');
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDOMContainerInfo = $__require('./ReactDOMContainerInfo');
  var ReactDOMFeatureFlags = $__require('./ReactDOMFeatureFlags');
  var ReactFeatureFlags = $__require('./ReactFeatureFlags');
  var ReactInstanceMap = $__require('./ReactInstanceMap');
  var ReactInstrumentation = $__require('./ReactInstrumentation');
  var ReactMarkupChecksum = $__require('./ReactMarkupChecksum');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactUpdateQueue = $__require('./ReactUpdateQueue');
  var ReactUpdates = $__require('./ReactUpdates');

  var emptyObject = $__require('fbjs/lib/emptyObject');
  var instantiateReactComponent = $__require('./instantiateReactComponent');
  var invariant = $__require('fbjs/lib/invariant');
  var setInnerHTML = $__require('./setInnerHTML');
  var shouldUpdateReactComponent = $__require('./shouldUpdateReactComponent');
  var warning = $__require('fbjs/lib/warning');

  var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
  var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

  var ELEMENT_NODE_TYPE = 1;
  var DOC_NODE_TYPE = 9;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

  var instancesByReactRootID = {};

  /**
   * Finds the index of the first character
   * that's not common between the two given strings.
   *
   * @return {number} the index of the character where the strings diverge
   */
  function firstDifferenceIndex(string1, string2) {
    var minLen = Math.min(string1.length, string2.length);
    for (var i = 0; i < minLen; i++) {
      if (string1.charAt(i) !== string2.charAt(i)) {
        return i;
      }
    }
    return string1.length === string2.length ? -1 : minLen;
  }

  /**
   * @param {DOMElement|DOMDocument} container DOM element that may contain
   * a React component
   * @return {?*} DOM element that may have the reactRoot ID, or null.
   */
  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }

    if (container.nodeType === DOC_NODE_TYPE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }

  function internalGetID(node) {
    // If node is something like a window, document, or text node, none of
    // which support attributes or a .getAttribute method, gracefully return
    // the empty string, as if the attribute were missing.
    return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
  }

  /**
   * Mounts this component and inserts it into the DOM.
   *
   * @param {ReactComponent} componentInstance The instance to mount.
   * @param {DOMElement} container DOM element to mount into.
   * @param {ReactReconcileTransaction} transaction
   * @param {boolean} shouldReuseMarkup If true, do not insert markup
   */
  function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var wrappedElement = wrapperInstance._currentElement.props.child;
      var type = wrappedElement.type;
      markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
      console.time(markerName);
    }

    var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
    );

    if (markerName) {
      console.timeEnd(markerName);
    }

    wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
    ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
  }

  /**
   * Batched mount.
   *
   * @param {ReactComponent} componentInstance The instance to mount.
   * @param {DOMElement} container DOM element to mount into.
   * @param {boolean} shouldReuseMarkup If true, do not insert markup
   */
  function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
    var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
    /* useCreateElement */
    !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
    transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
    ReactUpdates.ReactReconcileTransaction.release(transaction);
  }

  /**
   * Unmounts a component and removes it from the DOM.
   *
   * @param {ReactComponent} instance React component instance.
   * @param {DOMElement} container DOM element to unmount from.
   * @final
   * @internal
   * @see {ReactMount.unmountComponentAtNode}
   */
  function unmountComponentFromNode(instance, container, safely) {
    if ('production' !== 'production') {
      ReactInstrumentation.debugTool.onBeginFlush();
    }
    ReactReconciler.unmountComponent(instance, safely);
    if ('production' !== 'production') {
      ReactInstrumentation.debugTool.onEndFlush();
    }

    if (container.nodeType === DOC_NODE_TYPE) {
      container = container.documentElement;
    }

    // http://jsperf.com/emptying-a-node
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
  }

  /**
   * True if the supplied DOM node has a direct React-rendered child that is
   * not a React root element. Useful for warning in `render`,
   * `unmountComponentAtNode`, etc.
   *
   * @param {?DOMElement} node The candidate DOM node.
   * @return {boolean} True if the DOM element contains a direct child that was
   * rendered by React but is not a root element.
   * @internal
   */
  function hasNonRootReactChild(container) {
    var rootEl = getReactRootElementInContainer(container);
    if (rootEl) {
      var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
      return !!(inst && inst._hostParent);
    }
  }

  /**
   * True if the supplied DOM node is a React DOM element and
   * it has been rendered by another copy of React.
   *
   * @param {?DOMElement} node The candidate DOM node.
   * @return {boolean} True if the DOM has been rendered by another copy of React
   * @internal
   */
  function nodeIsRenderedByOtherInstance(container) {
    var rootEl = getReactRootElementInContainer(container);
    return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
  }

  /**
   * True if the supplied DOM node is a valid node element.
   *
   * @param {?DOMElement} node The candidate DOM node.
   * @return {boolean} True if the DOM is a valid DOM node.
   * @internal
   */
  function isValidContainer(node) {
    return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
  }

  /**
   * True if the supplied DOM node is a valid React node element.
   *
   * @param {?DOMElement} node The candidate DOM node.
   * @return {boolean} True if the DOM is a valid React DOM node.
   * @internal
   */
  function isReactNode(node) {
    return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
  }

  function getHostRootInstanceInContainer(container) {
    var rootEl = getReactRootElementInContainer(container);
    var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
  }

  function getTopLevelWrapperInContainer(container) {
    var root = getHostRootInstanceInContainer(container);
    return root ? root._hostContainerInfo._topLevelWrapper : null;
  }

  /**
   * Temporary (?) hack so that we can store all top-level pending updates on
   * composites instead of having to worry about different types of components
   * here.
   */
  var topLevelRootCounter = 1;
  var TopLevelWrapper = function () {
    this.rootID = topLevelRootCounter++;
  };
  TopLevelWrapper.prototype.isReactComponent = {};
  if ('production' !== 'production') {
    TopLevelWrapper.displayName = 'TopLevelWrapper';
  }
  TopLevelWrapper.prototype.render = function () {
    return this.props.child;
  };
  TopLevelWrapper.isReactTopLevelWrapper = true;

  /**
   * Mounting is the process of initializing a React component by creating its
   * representative DOM elements and inserting them into a supplied `container`.
   * Any prior content inside `container` is destroyed in the process.
   *
   *   ReactMount.render(
   *     component,
   *     document.getElementById('container')
   *   );
   *
   *   <div id="container">                   <-- Supplied `container`.
   *     <div data-reactid=".3">              <-- Rendered reactRoot of React
   *       // ...                                 component.
   *     </div>
   *   </div>
   *
   * Inside of `container`, the first element rendered is the "reactRoot".
   */
  var ReactMount = {

    TopLevelWrapper: TopLevelWrapper,

    /**
     * Used by devtools. The keys are not important.
     */
    _instancesByReactRootID: instancesByReactRootID,

    /**
     * This is a hook provided to support rendering React components while
     * ensuring that the apparent scroll position of its `container` does not
     * change.
     *
     * @param {DOMElement} container The `container` being rendered into.
     * @param {function} renderCallback This must be called once to do the render.
     */
    scrollMonitor: function (container, renderCallback) {
      renderCallback();
    },

    /**
     * Take a component that's already mounted into the DOM and replace its props
     * @param {ReactComponent} prevComponent component instance already in the DOM
     * @param {ReactElement} nextElement component instance to render
     * @param {DOMElement} container container to render into
     * @param {?function} callback function triggered on completion
     */
    _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
      ReactMount.scrollMonitor(container, function () {
        ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
        if (callback) {
          ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
        }
      });

      return prevComponent;
    },

    /**
     * Render a new component into the DOM. Hooked by hooks!
     *
     * @param {ReactElement} nextElement element to render
     * @param {DOMElement} container container to render into
     * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
     * @return {ReactComponent} nextComponent
     */
    _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
      // Various parts of our code (such as ReactCompositeComponent's
      // _renderValidatedComponent) assume that calls to render aren't nested;
      // verify that that's the case.
      'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

      !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

      ReactBrowserEventEmitter.ensureScrollValueMonitoring();
      var componentInstance = instantiateReactComponent(nextElement, false);

      // The initial render is synchronous but any updates that happen during
      // rendering, in componentWillMount or componentDidMount, will be batched
      // according to the current batching strategy.

      ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

      var wrapperID = componentInstance._instance.rootID;
      instancesByReactRootID[wrapperID] = componentInstance;

      return componentInstance;
    },

    /**
     * Renders a React component into the DOM in the supplied `container`.
     *
     * If the React component was previously rendered into `container`, this will
     * perform an update on it and only mutate the DOM as necessary to reflect the
     * latest React component.
     *
     * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
     * @param {ReactElement} nextElement Component element to render.
     * @param {DOMElement} container DOM element to render into.
     * @param {?function} callback function triggered on completion
     * @return {ReactComponent} Component instance rendered in `container`.
     */
    renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
      !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? 'production' !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
      return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
    },

    _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
      ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
      !React.isValidElement(nextElement) ? 'production' !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
      // Check if it quacks like an element
      nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

      'production' !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

      var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

      var nextContext;
      if (parentComponent) {
        var parentInst = ReactInstanceMap.get(parentComponent);
        nextContext = parentInst._processChildContext(parentInst._context);
      } else {
        nextContext = emptyObject;
      }

      var prevComponent = getTopLevelWrapperInContainer(container);

      if (prevComponent) {
        var prevWrappedElement = prevComponent._currentElement;
        var prevElement = prevWrappedElement.props.child;
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          var publicInst = prevComponent._renderedComponent.getPublicInstance();
          var updatedCallback = callback && function () {
            callback.call(publicInst);
          };
          ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
          return publicInst;
        } else {
          ReactMount.unmountComponentAtNode(container);
        }
      }

      var reactRootElement = getReactRootElementInContainer(container);
      var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      if ('production' !== 'production') {
        'production' !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

        if (!containerHasReactMarkup || reactRootElement.nextSibling) {
          var rootElementSibling = reactRootElement;
          while (rootElementSibling) {
            if (internalGetID(rootElementSibling)) {
              'production' !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
              break;
            }
            rootElementSibling = rootElementSibling.nextSibling;
          }
        }
      }

      var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
      var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
      if (callback) {
        callback.call(component);
      }
      return component;
    },

    /**
     * Renders a React component into the DOM in the supplied `container`.
     * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
     *
     * If the React component was previously rendered into `container`, this will
     * perform an update on it and only mutate the DOM as necessary to reflect the
     * latest React component.
     *
     * @param {ReactElement} nextElement Component element to render.
     * @param {DOMElement} container DOM element to render into.
     * @param {?function} callback function triggered on completion
     * @return {ReactComponent} Component instance rendered in `container`.
     */
    render: function (nextElement, container, callback) {
      return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
    },

    /**
     * Unmounts and destroys the React component rendered in the `container`.
     * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
     *
     * @param {DOMElement} container DOM element containing a React component.
     * @return {boolean} True if a component was found in and unmounted from
     *                   `container`
     */
    unmountComponentAtNode: function (container) {
      // Various parts of our code (such as ReactCompositeComponent's
      // _renderValidatedComponent) assume that calls to render aren't nested;
      // verify that that's the case. (Strictly speaking, unmounting won't cause a
      // render but we still don't expect to be in a render call here.)
      'production' !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

      !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

      if ('production' !== 'production') {
        'production' !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
      }

      var prevComponent = getTopLevelWrapperInContainer(container);
      if (!prevComponent) {
        // Check if the node being unmounted was rendered by React, but isn't a
        // root node.
        var containerHasNonRootReactChild = hasNonRootReactChild(container);

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
        }

        return false;
      }
      delete instancesByReactRootID[prevComponent._instance.rootID];
      ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
      return true;
    },

    _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
      !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

      if (shouldReuseMarkup) {
        var rootElement = getReactRootElementInContainer(container);
        if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
          ReactDOMComponentTree.precacheNode(instance, rootElement);
          return;
        } else {
          var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
          rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

          var rootMarkup = rootElement.outerHTML;
          rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

          var normalizedMarkup = markup;
          if ('production' !== 'production') {
            // because rootMarkup is retrieved from the DOM, various normalizations
            // will have occurred which will not be present in `markup`. Here,
            // insert markup into a <div> or <iframe> depending on the container
            // type to perform the same normalizations before comparing.
            var normalizer;
            if (container.nodeType === ELEMENT_NODE_TYPE) {
              normalizer = document.createElement('div');
              normalizer.innerHTML = markup;
              normalizedMarkup = normalizer.innerHTML;
            } else {
              normalizer = document.createElement('iframe');
              document.body.appendChild(normalizer);
              normalizer.contentDocument.write(markup);
              normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
              document.body.removeChild(normalizer);
            }
          }

          var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
          var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

          !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

          if ('production' !== 'production') {
            'production' !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
          }
        }
      }

      !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

      if (transaction.useCreateElement) {
        while (container.lastChild) {
          container.removeChild(container.lastChild);
        }
        DOMLazyTree.insertTreeBefore(container, markup, null);
      } else {
        setInnerHTML(container, markup);
        ReactDOMComponentTree.precacheNode(instance, container.firstChild);
      }

      if ('production' !== 'production') {
        var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
        if (hostNode._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: hostNode._debugID,
            type: 'mount',
            payload: markup.toString()
          });
        }
      }
    }
  };

  module.exports = ReactMount;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/renderSubtreeIntoContainer.js', ['./ReactMount', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactMount = $__require('./ReactMount');

  module.exports = ReactMount.renderSubtreeIntoContainer;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactInvalidSetStateWarningHook.js', ['fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = $__require('fbjs/lib/warning');

  if ('production' !== 'production') {
    var processingChildContext = false;

    var warnInvalidSetState = function () {
      'production' !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
    };
  }

  var ReactInvalidSetStateWarningHook = {
    onBeginProcessingChildContext: function () {
      processingChildContext = true;
    },
    onEndProcessingChildContext: function () {
      processingChildContext = false;
    },
    onSetState: function () {
      warnInvalidSetState();
    }
  };

  module.exports = ReactInvalidSetStateWarningHook;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactHostOperationHistoryHook.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var history = [];

  var ReactHostOperationHistoryHook = {
    onHostOperation: function (operation) {
      history.push(operation);
    },
    clearHistory: function () {
      if (ReactHostOperationHistoryHook._preventClearing) {
        // Should only be used for tests.
        return;
      }

      history = [];
    },
    getHistory: function () {
      return history;
    }
  };

  module.exports = ReactHostOperationHistoryHook;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/ExecutionEnvironment.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  /**
   * Simple, lightweight module assisting with the detection and context of
   * Worker. Helps avoid circular dependencies and allows code to reason about
   * whether or not they are in a Worker, even if they never include the main
   * `ReactWorker` dependency.
   */
  var ExecutionEnvironment = {

    canUseDOM: canUseDOM,

    canUseWorkers: typeof Worker !== 'undefined',

    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

    canUseViewport: canUseDOM && !!window.screen,

    isInWorker: !canUseDOM // For now, this is true - might change in the future.

  };

  module.exports = ExecutionEnvironment;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/performance.js', ['./ExecutionEnvironment', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var performance;

  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }

  module.exports = performance || {};
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/performanceNow.js', ['./performance', 'process'], true, function ($__require, exports, module) {
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var performance = $__require('./performance');

  var performanceNow;

  /**
   * Detect if we can use `window.performance.now()` and gracefully fallback to
   * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
   * because of Facebook's testing infrastructure.
   */
  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }

  module.exports = performanceNow;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDebugTool.js', ['./ReactInvalidSetStateWarningHook', './ReactHostOperationHistoryHook', 'react/lib/ReactComponentTreeHook', 'fbjs/lib/ExecutionEnvironment', 'fbjs/lib/performanceNow', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactInvalidSetStateWarningHook = $__require('./ReactInvalidSetStateWarningHook');
  var ReactHostOperationHistoryHook = $__require('./ReactHostOperationHistoryHook');
  var ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');
  var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');

  var performanceNow = $__require('fbjs/lib/performanceNow');
  var warning = $__require('fbjs/lib/warning');

  var hooks = [];
  var didHookThrowForEvent = {};

  function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
    try {
      fn.call(context, arg1, arg2, arg3, arg4, arg5);
    } catch (e) {
      'production' !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
      didHookThrowForEvent[event] = true;
    }
  }

  function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
    for (var i = 0; i < hooks.length; i++) {
      var hook = hooks[i];
      var fn = hook[event];
      if (fn) {
        callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
      }
    }
  }

  var isProfiling = false;
  var flushHistory = [];
  var lifeCycleTimerStack = [];
  var currentFlushNesting = 0;
  var currentFlushMeasurements = [];
  var currentFlushStartTime = 0;
  var currentTimerDebugID = null;
  var currentTimerStartTime = 0;
  var currentTimerNestedFlushDuration = 0;
  var currentTimerType = null;

  var lifeCycleTimerHasWarned = false;

  function clearHistory() {
    ReactComponentTreeHook.purgeUnmountedComponents();
    ReactHostOperationHistoryHook.clearHistory();
  }

  function getTreeSnapshot(registeredIDs) {
    return registeredIDs.reduce(function (tree, id) {
      var ownerID = ReactComponentTreeHook.getOwnerID(id);
      var parentID = ReactComponentTreeHook.getParentID(id);
      tree[id] = {
        displayName: ReactComponentTreeHook.getDisplayName(id),
        text: ReactComponentTreeHook.getText(id),
        updateCount: ReactComponentTreeHook.getUpdateCount(id),
        childIDs: ReactComponentTreeHook.getChildIDs(id),
        // Text nodes don't have owners but this is close enough.
        ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
        parentID: parentID
      };
      return tree;
    }, {});
  }

  function resetMeasurements() {
    var previousStartTime = currentFlushStartTime;
    var previousMeasurements = currentFlushMeasurements;
    var previousOperations = ReactHostOperationHistoryHook.getHistory();

    if (currentFlushNesting === 0) {
      currentFlushStartTime = 0;
      currentFlushMeasurements = [];
      clearHistory();
      return;
    }

    if (previousMeasurements.length || previousOperations.length) {
      var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
      flushHistory.push({
        duration: performanceNow() - previousStartTime,
        measurements: previousMeasurements || [],
        operations: previousOperations || [],
        treeSnapshot: getTreeSnapshot(registeredIDs)
      });
    }

    clearHistory();
    currentFlushStartTime = performanceNow();
    currentFlushMeasurements = [];
  }

  function checkDebugID(debugID) {
    var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (allowRoot && debugID === 0) {
      return;
    }
    if (!debugID) {
      'production' !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
    }
  }

  function beginLifeCycleTimer(debugID, timerType) {
    if (currentFlushNesting === 0) {
      return;
    }
    if (currentTimerType && !lifeCycleTimerHasWarned) {
      'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
      lifeCycleTimerHasWarned = true;
    }
    currentTimerStartTime = performanceNow();
    currentTimerNestedFlushDuration = 0;
    currentTimerDebugID = debugID;
    currentTimerType = timerType;
  }

  function endLifeCycleTimer(debugID, timerType) {
    if (currentFlushNesting === 0) {
      return;
    }
    if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
      'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
      lifeCycleTimerHasWarned = true;
    }
    if (isProfiling) {
      currentFlushMeasurements.push({
        timerType: timerType,
        instanceID: debugID,
        duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
      });
    }
    currentTimerStartTime = 0;
    currentTimerNestedFlushDuration = 0;
    currentTimerDebugID = null;
    currentTimerType = null;
  }

  function pauseCurrentLifeCycleTimer() {
    var currentTimer = {
      startTime: currentTimerStartTime,
      nestedFlushStartTime: performanceNow(),
      debugID: currentTimerDebugID,
      timerType: currentTimerType
    };
    lifeCycleTimerStack.push(currentTimer);
    currentTimerStartTime = 0;
    currentTimerNestedFlushDuration = 0;
    currentTimerDebugID = null;
    currentTimerType = null;
  }

  function resumeCurrentLifeCycleTimer() {
    var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
        startTime = _lifeCycleTimerStack$.startTime,
        nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
        debugID = _lifeCycleTimerStack$.debugID,
        timerType = _lifeCycleTimerStack$.timerType;

    var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
    currentTimerStartTime = startTime;
    currentTimerNestedFlushDuration += nestedFlushDuration;
    currentTimerDebugID = debugID;
    currentTimerType = timerType;
  }

  var lastMarkTimeStamp = 0;
  var canUsePerformanceMeasure =
  // $FlowFixMe https://github.com/facebook/flow/issues/2345
  typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

  function shouldMark(debugID) {
    if (!isProfiling || !canUsePerformanceMeasure) {
      return false;
    }
    var element = ReactComponentTreeHook.getElement(debugID);
    if (element == null || typeof element !== 'object') {
      return false;
    }
    var isHostElement = typeof element.type === 'string';
    if (isHostElement) {
      return false;
    }
    return true;
  }

  function markBegin(debugID, markType) {
    if (!shouldMark(debugID)) {
      return;
    }

    var markName = debugID + '::' + markType;
    lastMarkTimeStamp = performanceNow();
    performance.mark(markName);
  }

  function markEnd(debugID, markType) {
    if (!shouldMark(debugID)) {
      return;
    }

    var markName = debugID + '::' + markType;
    var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

    // Chrome has an issue of dropping markers recorded too fast:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
    // To work around this, we will not report very small measurements.
    // I determined the magic number by tweaking it back and forth.
    // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
    // When the bug is fixed, we can `measure()` unconditionally if we want to.
    var timeStamp = performanceNow();
    if (timeStamp - lastMarkTimeStamp > 0.1) {
      var measurementName = displayName + ' [' + markType + ']';
      performance.measure(measurementName, markName);
    }

    performance.clearMarks(markName);
    performance.clearMeasures(measurementName);
  }

  var ReactDebugTool = {
    addHook: function (hook) {
      hooks.push(hook);
    },
    removeHook: function (hook) {
      for (var i = 0; i < hooks.length; i++) {
        if (hooks[i] === hook) {
          hooks.splice(i, 1);
          i--;
        }
      }
    },
    isProfiling: function () {
      return isProfiling;
    },
    beginProfiling: function () {
      if (isProfiling) {
        return;
      }

      isProfiling = true;
      flushHistory.length = 0;
      resetMeasurements();
      ReactDebugTool.addHook(ReactHostOperationHistoryHook);
    },
    endProfiling: function () {
      if (!isProfiling) {
        return;
      }

      isProfiling = false;
      resetMeasurements();
      ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
    },
    getFlushHistory: function () {
      return flushHistory;
    },
    onBeginFlush: function () {
      currentFlushNesting++;
      resetMeasurements();
      pauseCurrentLifeCycleTimer();
      emitEvent('onBeginFlush');
    },
    onEndFlush: function () {
      resetMeasurements();
      currentFlushNesting--;
      resumeCurrentLifeCycleTimer();
      emitEvent('onEndFlush');
    },
    onBeginLifeCycleTimer: function (debugID, timerType) {
      checkDebugID(debugID);
      emitEvent('onBeginLifeCycleTimer', debugID, timerType);
      markBegin(debugID, timerType);
      beginLifeCycleTimer(debugID, timerType);
    },
    onEndLifeCycleTimer: function (debugID, timerType) {
      checkDebugID(debugID);
      endLifeCycleTimer(debugID, timerType);
      markEnd(debugID, timerType);
      emitEvent('onEndLifeCycleTimer', debugID, timerType);
    },
    onBeginProcessingChildContext: function () {
      emitEvent('onBeginProcessingChildContext');
    },
    onEndProcessingChildContext: function () {
      emitEvent('onEndProcessingChildContext');
    },
    onHostOperation: function (operation) {
      checkDebugID(operation.instanceID);
      emitEvent('onHostOperation', operation);
    },
    onSetState: function () {
      emitEvent('onSetState');
    },
    onSetChildren: function (debugID, childDebugIDs) {
      checkDebugID(debugID);
      childDebugIDs.forEach(checkDebugID);
      emitEvent('onSetChildren', debugID, childDebugIDs);
    },
    onBeforeMountComponent: function (debugID, element, parentDebugID) {
      checkDebugID(debugID);
      checkDebugID(parentDebugID, true);
      emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
      markBegin(debugID, 'mount');
    },
    onMountComponent: function (debugID) {
      checkDebugID(debugID);
      markEnd(debugID, 'mount');
      emitEvent('onMountComponent', debugID);
    },
    onBeforeUpdateComponent: function (debugID, element) {
      checkDebugID(debugID);
      emitEvent('onBeforeUpdateComponent', debugID, element);
      markBegin(debugID, 'update');
    },
    onUpdateComponent: function (debugID) {
      checkDebugID(debugID);
      markEnd(debugID, 'update');
      emitEvent('onUpdateComponent', debugID);
    },
    onBeforeUnmountComponent: function (debugID) {
      checkDebugID(debugID);
      emitEvent('onBeforeUnmountComponent', debugID);
      markBegin(debugID, 'unmount');
    },
    onUnmountComponent: function (debugID) {
      checkDebugID(debugID);
      markEnd(debugID, 'unmount');
      emitEvent('onUnmountComponent', debugID);
    },
    onTestEvent: function () {
      emitEvent('onTestEvent');
    }
  };

  // TODO remove these when RN/www gets updated
  ReactDebugTool.addDevtool = ReactDebugTool.addHook;
  ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

  ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
  ReactDebugTool.addHook(ReactComponentTreeHook);
  var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
  if (/[?&]react_perf\b/.test(url)) {
    ReactDebugTool.beginProfiling();
  }

  module.exports = ReactDebugTool;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactInstrumentation.js', ['./ReactDebugTool', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // Trust the developer to only use ReactInstrumentation with a __DEV__ check

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var debugTool = null;

  if ('production' !== 'production') {
    var ReactDebugTool = $__require('./ReactDebugTool');
    debugTool = ReactDebugTool;
  }

  module.exports = { debugTool: debugTool };
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/EventPluginRegistry.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Injectable ordering of event plugins.
   */
  var eventPluginOrder = null;

  /**
   * Injectable mapping from names to event plugin modules.
   */
  var namesToPlugins = {};

  /**
   * Recomputes the plugin list using the injected plugins and plugin ordering.
   *
   * @private
   */
  function recomputePluginOrdering() {
    if (!eventPluginOrder) {
      // Wait until an `eventPluginOrder` is injected.
      return;
    }
    for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName];
      var pluginIndex = eventPluginOrder.indexOf(pluginName);
      !(pluginIndex > -1) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
      if (EventPluginRegistry.plugins[pluginIndex]) {
        continue;
      }
      !pluginModule.extractEvents ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
      EventPluginRegistry.plugins[pluginIndex] = pluginModule;
      var publishedEvents = pluginModule.eventTypes;
      for (var eventName in publishedEvents) {
        !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
      }
    }
  }

  /**
   * Publishes an event so that it can be dispatched by the supplied plugin.
   *
   * @param {object} dispatchConfig Dispatch configuration for the event.
   * @param {object} PluginModule Plugin publishing the event.
   * @return {boolean} True if the event was successfully published.
   * @private
   */
  function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
    !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
    EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
    if (phasedRegistrationNames) {
      for (var phaseName in phasedRegistrationNames) {
        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
          var phasedRegistrationName = phasedRegistrationNames[phaseName];
          publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
        }
      }
      return true;
    } else if (dispatchConfig.registrationName) {
      publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
      return true;
    }
    return false;
  }

  /**
   * Publishes a registration name that is used to identify dispatched events and
   * can be used with `EventPluginHub.putListener` to register listeners.
   *
   * @param {string} registrationName Registration name to add.
   * @param {object} PluginModule Plugin publishing the event.
   * @private
   */
  function publishRegistrationName(registrationName, pluginModule, eventName) {
    !!EventPluginRegistry.registrationNameModules[registrationName] ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
    EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
    EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

    if ('production' !== 'production') {
      var lowerCasedName = registrationName.toLowerCase();
      EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

      if (registrationName === 'onDoubleClick') {
        EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
      }
    }
  }

  /**
   * Registers plugins so that they can extract and dispatch events.
   *
   * @see {EventPluginHub}
   */
  var EventPluginRegistry = {

    /**
     * Ordered list of injected plugins.
     */
    plugins: [],

    /**
     * Mapping from event name to dispatch config
     */
    eventNameDispatchConfigs: {},

    /**
     * Mapping from registration name to plugin module
     */
    registrationNameModules: {},

    /**
     * Mapping from registration name to event name
     */
    registrationNameDependencies: {},

    /**
     * Mapping from lowercase registration names to the properly cased version,
     * used to warn in the case of missing event handlers. Available
     * only in __DEV__.
     * @type {Object}
     */
    possibleRegistrationNames: 'production' !== 'production' ? {} : null,
    // Trust the developer to only use possibleRegistrationNames in __DEV__

    /**
     * Injects an ordering of plugins (by plugin name). This allows the ordering
     * to be decoupled from injection of the actual plugins so that ordering is
     * always deterministic regardless of packaging, on-the-fly injection, etc.
     *
     * @param {array} InjectedEventPluginOrder
     * @internal
     * @see {EventPluginHub.injection.injectEventPluginOrder}
     */
    injectEventPluginOrder: function (injectedEventPluginOrder) {
      !!eventPluginOrder ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
      // Clone the ordering so it cannot be dynamically mutated.
      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    },

    /**
     * Injects plugins to be used by `EventPluginHub`. The plugin names must be
     * in the ordering injected by `injectEventPluginOrder`.
     *
     * Plugins can be injected as part of page initialization or on-the-fly.
     *
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     * @internal
     * @see {EventPluginHub.injection.injectEventPluginsByName}
     */
    injectEventPluginsByName: function (injectedNamesToPlugins) {
      var isOrderingDirty = false;
      for (var pluginName in injectedNamesToPlugins) {
        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          continue;
        }
        var pluginModule = injectedNamesToPlugins[pluginName];
        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
          !!namesToPlugins[pluginName] ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
          namesToPlugins[pluginName] = pluginModule;
          isOrderingDirty = true;
        }
      }
      if (isOrderingDirty) {
        recomputePluginOrdering();
      }
    },

    /**
     * Looks up the plugin for the supplied event.
     *
     * @param {object} event A synthetic event.
     * @return {?object} The plugin that created the supplied event.
     * @internal
     */
    getPluginModuleForEvent: function (event) {
      var dispatchConfig = event.dispatchConfig;
      if (dispatchConfig.registrationName) {
        return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
      }
      if (dispatchConfig.phasedRegistrationNames !== undefined) {
        // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
        // that it is not undefined.
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

        for (var phase in phasedRegistrationNames) {
          if (!phasedRegistrationNames.hasOwnProperty(phase)) {
            continue;
          }
          var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
          if (pluginModule) {
            return pluginModule;
          }
        }
      }
      return null;
    },

    /**
     * Exposed for unit testing.
     * @private
     */
    _resetEventPlugins: function () {
      eventPluginOrder = null;
      for (var pluginName in namesToPlugins) {
        if (namesToPlugins.hasOwnProperty(pluginName)) {
          delete namesToPlugins[pluginName];
        }
      }
      EventPluginRegistry.plugins.length = 0;

      var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
      for (var eventName in eventNameDispatchConfigs) {
        if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
          delete eventNameDispatchConfigs[eventName];
        }
      }

      var registrationNameModules = EventPluginRegistry.registrationNameModules;
      for (var registrationName in registrationNameModules) {
        if (registrationNameModules.hasOwnProperty(registrationName)) {
          delete registrationNameModules[registrationName];
        }
      }

      if ('production' !== 'production') {
        var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
        for (var lowerCasedName in possibleRegistrationNames) {
          if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
            delete possibleRegistrationNames[lowerCasedName];
          }
        }
      }
    }

  };

  module.exports = EventPluginRegistry;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMUnknownPropertyHook.js', ['./DOMProperty', './EventPluginRegistry', 'react/lib/ReactComponentTreeHook', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var EventPluginRegistry = $__require('./EventPluginRegistry');
  var ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');

  var warning = $__require('fbjs/lib/warning');

  if ('production' !== 'production') {
    var reactProps = {
      children: true,
      dangerouslySetInnerHTML: true,
      key: true,
      ref: true,

      autoFocus: true,
      defaultValue: true,
      valueLink: true,
      defaultChecked: true,
      checkedLink: true,
      innerHTML: true,
      suppressContentEditableWarning: true,
      onFocusIn: true,
      onFocusOut: true
    };
    var warnedProperties = {};

    var validateProperty = function (tagName, name, debugID) {
      if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
        return true;
      }
      if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
        return true;
      }
      if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      warnedProperties[name] = true;
      var lowerCasedName = name.toLowerCase();

      // data-* attributes should be lowercase; suggest the lowercase version
      var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

      var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

      if (standardName != null) {
        'production' !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        return true;
      } else if (registrationName != null) {
        'production' !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        return true;
      } else {
        // We were unable to guess which prop the user intended.
        // It is likely that the user was just blindly spreading/forwarding props
        // Components should be careful to only render valid props/attributes.
        // Warning will be invoked in warnUnknownProperties to allow grouping.
        return false;
      }
    };
  }

  var warnUnknownProperties = function (debugID, element) {
    var unknownProps = [];
    for (var key in element.props) {
      var isValid = validateProperty(element.type, key, debugID);
      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      'production' !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
    } else if (unknownProps.length > 1) {
      'production' !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
    }
  };

  function handleElement(debugID, element) {
    if (element == null || typeof element.type !== 'string') {
      return;
    }
    if (element.type.indexOf('-') >= 0 || element.props.is) {
      return;
    }
    warnUnknownProperties(debugID, element);
  }

  var ReactDOMUnknownPropertyHook = {
    onBeforeMountComponent: function (debugID, element) {
      handleElement(debugID, element);
    },
    onBeforeUpdateComponent: function (debugID, element) {
      handleElement(debugID, element);
    }
  };

  module.exports = ReactDOMUnknownPropertyHook;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMNullInputValuePropHook.js', ['react/lib/ReactComponentTreeHook', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');

  var warning = $__require('fbjs/lib/warning');

  var didWarnValueNull = false;

  function handleElement(debugID, element) {
    if (element == null) {
      return;
    }
    if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
      return;
    }
    if (element.props != null && element.props.value === null && !didWarnValueNull) {
      'production' !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

      didWarnValueNull = true;
    }
  }

  var ReactDOMNullInputValuePropHook = {
    onBeforeMountComponent: function (debugID, element) {
      handleElement(debugID, element);
    },
    onBeforeUpdateComponent: function (debugID, element) {
      handleElement(debugID, element);
    }
  };

  module.exports = ReactDOMNullInputValuePropHook;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/reactProdInvariant.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/DOMProperty.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }

  var DOMPropertyInjection = {
    /**
     * Mapping from normalized, camelcased property names to a configuration that
     * specifies how the associated DOM property should be accessed or rendered.
     */
    MUST_USE_PROPERTY: 0x1,
    HAS_BOOLEAN_VALUE: 0x4,
    HAS_NUMERIC_VALUE: 0x8,
    HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
    HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

    /**
     * Inject some specialized knowledge about the DOM. This takes a config object
     * with the following properties:
     *
     * isCustomAttribute: function that given an attribute name will return true
     * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
     * attributes where it's impossible to enumerate all of the possible
     * attribute names,
     *
     * Properties: object mapping DOM property name to one of the
     * DOMPropertyInjection constants or null. If your attribute isn't in here,
     * it won't get written to the DOM.
     *
     * DOMAttributeNames: object mapping React attribute name to the DOM
     * attribute name. Attribute names not specified use the **lowercase**
     * normalized name.
     *
     * DOMAttributeNamespaces: object mapping React attribute name to the DOM
     * attribute namespace URL. (Attribute names not specified use no namespace.)
     *
     * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
     * Property names not specified use the normalized name.
     *
     * DOMMutationMethods: Properties that require special mutation methods. If
     * `value` is undefined, the mutation method should unset the property.
     *
     * @param {object} domPropertyConfig the config as described above.
     */
    injectDOMPropertyConfig: function (domPropertyConfig) {
      var Injection = DOMPropertyInjection;
      var Properties = domPropertyConfig.Properties || {};
      var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
      var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
      var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
      var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

      if (domPropertyConfig.isCustomAttribute) {
        DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
      }

      for (var propName in Properties) {
        !!DOMProperty.properties.hasOwnProperty(propName) ? 'production' !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

        var lowerCased = propName.toLowerCase();
        var propConfig = Properties[propName];

        var propertyInfo = {
          attributeName: lowerCased,
          attributeNamespace: null,
          propertyName: propName,
          mutationMethod: null,

          mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
          hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
          hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
          hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
          hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
        };
        !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? 'production' !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

        if ('production' !== 'production') {
          DOMProperty.getPossibleStandardName[lowerCased] = propName;
        }

        if (DOMAttributeNames.hasOwnProperty(propName)) {
          var attributeName = DOMAttributeNames[propName];
          propertyInfo.attributeName = attributeName;
          if ('production' !== 'production') {
            DOMProperty.getPossibleStandardName[attributeName] = propName;
          }
        }

        if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
          propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
        }

        if (DOMPropertyNames.hasOwnProperty(propName)) {
          propertyInfo.propertyName = DOMPropertyNames[propName];
        }

        if (DOMMutationMethods.hasOwnProperty(propName)) {
          propertyInfo.mutationMethod = DOMMutationMethods[propName];
        }

        DOMProperty.properties[propName] = propertyInfo;
      }
    }
  };

  /* eslint-disable max-len */
  var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
  /* eslint-enable max-len */

  /**
   * DOMProperty exports lookup objects that can be used like functions:
   *
   *   > DOMProperty.isValid['id']
   *   true
   *   > DOMProperty.isValid['foobar']
   *   undefined
   *
   * Although this may be confusing, it performs better in general.
   *
   * @see http://jsperf.com/key-exists
   * @see http://jsperf.com/key-missing
   */
  var DOMProperty = {

    ID_ATTRIBUTE_NAME: 'data-reactid',
    ROOT_ATTRIBUTE_NAME: 'data-reactroot',

    ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
    ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

    /**
     * Map from property "standard name" to an object with info about how to set
     * the property in the DOM. Each object contains:
     *
     * attributeName:
     *   Used when rendering markup or with `*Attribute()`.
     * attributeNamespace
     * propertyName:
     *   Used on DOM node instances. (This includes properties that mutate due to
     *   external factors.)
     * mutationMethod:
     *   If non-null, used instead of the property or `setAttribute()` after
     *   initial render.
     * mustUseProperty:
     *   Whether the property must be accessed and mutated as an object property.
     * hasBooleanValue:
     *   Whether the property should be removed when set to a falsey value.
     * hasNumericValue:
     *   Whether the property must be numeric or parse as a numeric and should be
     *   removed when set to a falsey value.
     * hasPositiveNumericValue:
     *   Whether the property must be positive numeric or parse as a positive
     *   numeric and should be removed when set to a falsey value.
     * hasOverloadedBooleanValue:
     *   Whether the property can be used as a flag as well as with a value.
     *   Removed when strictly equal to false; present without a value when
     *   strictly equal to true; present with a value otherwise.
     */
    properties: {},

    /**
     * Mapping from lowercase property names to the properly cased version, used
     * to warn in the case of missing properties. Available only in __DEV__.
     *
     * autofocus is predefined, because adding it to the property whitelist
     * causes unintended side effects.
     *
     * @type {Object}
     */
    getPossibleStandardName: 'production' !== 'production' ? { autofocus: 'autoFocus' } : null,

    /**
     * All of the isCustomAttribute() functions that have been injected.
     */
    _isCustomAttributeFunctions: [],

    /**
     * Checks whether a property name is a custom attribute.
     * @method
     */
    isCustomAttribute: function (attributeName) {
      for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
        var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
        if (isCustomAttributeFn(attributeName)) {
          return true;
        }
      }
      return false;
    },

    injection: DOMPropertyInjection
  };

  module.exports = DOMProperty;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOMInvalidARIAHook.js', ['./DOMProperty', 'react/lib/ReactComponentTreeHook', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('./DOMProperty');
  var ReactComponentTreeHook = $__require('react/lib/ReactComponentTreeHook');

  var warning = $__require('fbjs/lib/warning');

  var warnedProperties = {};
  var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

  function validateProperty(tagName, name, debugID) {
    if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

      // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.
      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      }
      // aria-* attributes should be lowercase; suggest the lowercase version.
      if (name !== standardName) {
        'production' !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        warnedProperties[name] = true;
        return true;
      }
    }

    return true;
  }

  function warnInvalidARIAProps(debugID, element) {
    var invalidProps = [];

    for (var key in element.props) {
      var isValid = validateProperty(element.type, key, debugID);
      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      'production' !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
    } else if (invalidProps.length > 1) {
      'production' !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
    }
  }

  function handleElement(debugID, element) {
    if (element == null || typeof element.type !== 'string') {
      return;
    }
    if (element.type.indexOf('-') >= 0 || element.props.is) {
      return;
    }

    warnInvalidARIAProps(debugID, element);
  }

  var ReactDOMInvalidARIAHook = {
    onBeforeMountComponent: function (debugID, element) {
      if ('production' !== 'production') {
        handleElement(debugID, element);
      }
    },
    onBeforeUpdateComponent: function (debugID, element) {
      if ('production' !== 'production') {
        handleElement(debugID, element);
      }
    }
  };

  module.exports = ReactDOMInvalidARIAHook;
  return module.exports;
});
System.registerDynamic('npm:react-dom@15.4.1/lib/ReactDOM.js', ['./ReactDOMComponentTree', './ReactDefaultInjection', './ReactMount', './ReactReconciler', './ReactUpdates', './ReactVersion', './findDOMNode', './getHostComponentFromComposite', './renderSubtreeIntoContainer', 'fbjs/lib/warning', 'fbjs/lib/ExecutionEnvironment', './ReactInstrumentation', './ReactDOMUnknownPropertyHook', './ReactDOMNullInputValuePropHook', './ReactDOMInvalidARIAHook', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactDOMComponentTree = $__require('./ReactDOMComponentTree');
  var ReactDefaultInjection = $__require('./ReactDefaultInjection');
  var ReactMount = $__require('./ReactMount');
  var ReactReconciler = $__require('./ReactReconciler');
  var ReactUpdates = $__require('./ReactUpdates');
  var ReactVersion = $__require('./ReactVersion');

  var findDOMNode = $__require('./findDOMNode');
  var getHostComponentFromComposite = $__require('./getHostComponentFromComposite');
  var renderSubtreeIntoContainer = $__require('./renderSubtreeIntoContainer');
  var warning = $__require('fbjs/lib/warning');

  ReactDefaultInjection.inject();

  var ReactDOM = {
    findDOMNode: findDOMNode,
    render: ReactMount.render,
    unmountComponentAtNode: ReactMount.unmountComponentAtNode,
    version: ReactVersion,

    /* eslint-disable camelcase */
    unstable_batchedUpdates: ReactUpdates.batchedUpdates,
    unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  };

  // Inject the runtime into a devtools global hook regardless of browser.
  // Allows for debugging when the hook is injected on the page.
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
      ComponentTree: {
        getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
        getNodeFromInstance: function (inst) {
          // inst is an internal instance (but could be a composite)
          if (inst._renderedComponent) {
            inst = getHostComponentFromComposite(inst);
          }
          if (inst) {
            return ReactDOMComponentTree.getNodeFromInstance(inst);
          } else {
            return null;
          }
        }
      },
      Mount: ReactMount,
      Reconciler: ReactReconciler
    });
  }

  if ('production' !== 'production') {
    var ExecutionEnvironment = $__require('fbjs/lib/ExecutionEnvironment');
    if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

      // First check if devtools is not installed
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        // If we're in Chrome or Firefox, provide a download link if not installed.
        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
          // Firefox does not have the issue with devtools loaded over file://
          var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
          console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
        }
      }

      var testFunc = function testFn() {};
      'production' !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

      // If we're in IE8, check to see if we are in compatibility mode and provide
      // information on preventing compatibility mode
      var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

      'production' !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

      var expectedFeatures = [
      // shims
      Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

      for (var i = 0; i < expectedFeatures.length; i++) {
        if (!expectedFeatures[i]) {
          'production' !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
          break;
        }
      }
    }
  }

  if ('production' !== 'production') {
    var ReactInstrumentation = $__require('./ReactInstrumentation');
    var ReactDOMUnknownPropertyHook = $__require('./ReactDOMUnknownPropertyHook');
    var ReactDOMNullInputValuePropHook = $__require('./ReactDOMNullInputValuePropHook');
    var ReactDOMInvalidARIAHook = $__require('./ReactDOMInvalidARIAHook');

    ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
    ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
    ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
  }

  module.exports = ReactDOM;
  return module.exports;
});
System.registerDynamic("npm:react-dom@15.4.1.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "dist/react-dom-server.js": {
        "cjsRequireDetection": false
      },
      "dist/react-dom.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic('npm:react-dom@15.4.1/index.js', ['./lib/ReactDOM', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/ReactDOM');
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/Router.js', ['invariant', 'react', './createTransitionManager', './InternalPropTypes', './RouterContext', './RouteUtils', './RouterUtils', './routerWarning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _createTransitionManager2 = $__require('./createTransitionManager');

  var _createTransitionManager3 = _interopRequireDefault(_createTransitionManager2);

  var _InternalPropTypes = $__require('./InternalPropTypes');

  var _RouterContext = $__require('./RouterContext');

  var _RouterContext2 = _interopRequireDefault(_RouterContext);

  var _RouteUtils = $__require('./RouteUtils');

  var _RouterUtils = $__require('./RouterUtils');

  var _routerWarning = $__require('./routerWarning');

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  var _React$PropTypes = _react2.default.PropTypes,
      func = _React$PropTypes.func,
      object = _React$PropTypes.object;

  /**
   * A <Router> is a high-level API for automatically setting up
   * a router that renders a <RouterContext> with all the props
   * it needs each time the URL changes.
   */

  var Router = _react2.default.createClass({
    displayName: 'Router',

    propTypes: {
      history: object,
      children: _InternalPropTypes.routes,
      routes: _InternalPropTypes.routes, // alias for children
      render: func,
      createElement: func,
      onError: func,
      onUpdate: func,

      // PRIVATE: For client-side rehydration of server match.
      matchContext: object
    },

    getDefaultProps: function getDefaultProps() {
      return {
        render: function render(props) {
          return _react2.default.createElement(_RouterContext2.default, props);
        }
      };
    },
    getInitialState: function getInitialState() {
      return {
        location: null,
        routes: null,
        params: null,
        components: null
      };
    },
    handleError: function handleError(error) {
      if (this.props.onError) {
        this.props.onError.call(this, error);
      } else {
        // Throw errors by default so we don't silently swallow them!
        throw error; // This error probably occurred in getChildRoutes or getComponents.
      }
    },
    createRouterObject: function createRouterObject(state) {
      var matchContext = this.props.matchContext;

      if (matchContext) {
        return matchContext.router;
      }

      var history = this.props.history;

      return (0, _RouterUtils.createRouterObject)(history, this.transitionManager, state);
    },
    createTransitionManager: function createTransitionManager() {
      var matchContext = this.props.matchContext;

      if (matchContext) {
        return matchContext.transitionManager;
      }

      var history = this.props.history;
      var _props = this.props,
          routes = _props.routes,
          children = _props.children;

      !history.getCurrentLocation ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v2.x or ' + 'earlier. This version of React Router is only compatible with v3 ' + 'history objects. Please upgrade to history v3.x.') : (0, _invariant2.default)(false) : void 0;

      return (0, _createTransitionManager3.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
    },
    componentWillMount: function componentWillMount() {
      var _this = this;

      this.transitionManager = this.createTransitionManager();
      this.router = this.createRouterObject(this.state);

      this._unlisten = this.transitionManager.listen(function (error, state) {
        if (error) {
          _this.handleError(error);
        } else {
          // Keep the identity of this.router because of a caveat in ContextUtils:
          // they only work if the object identity is preserved.
          (0, _RouterUtils.assignRouterState)(_this.router, state);
          _this.setState(state, _this.props.onUpdate);
        }
      });
    },

    /* istanbul ignore next: sanity check */
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
      'production' !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;

      'production' !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
    },
    componentWillUnmount: function componentWillUnmount() {
      if (this._unlisten) this._unlisten();
    },
    render: function render() {
      var _state = this.state,
          location = _state.location,
          routes = _state.routes,
          params = _state.params,
          components = _state.components;

      var _props2 = this.props,
          createElement = _props2.createElement,
          render = _props2.render,
          props = _objectWithoutProperties(_props2, ['createElement', 'render']);

      if (location == null) return null; // Async match

      // Only forward non-Router-specific props to routing context, as those are
      // the only ones that might be custom routing context props.
      Object.keys(Router.propTypes).forEach(function (propType) {
        return delete props[propType];
      });

      return render(_extends({}, props, {
        router: this.router,
        location: location,
        routes: routes,
        params: params,
        components: components,
        createElement: createElement
      }));
    }
  });

  exports.default = Router;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/Link.js', ['react', 'invariant', './PropTypes', './ContextUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _PropTypes = $__require('./PropTypes');

  var _ContextUtils = $__require('./ContextUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  var _React$PropTypes = _react2.default.PropTypes,
      bool = _React$PropTypes.bool,
      object = _React$PropTypes.object,
      string = _React$PropTypes.string,
      func = _React$PropTypes.func,
      oneOfType = _React$PropTypes.oneOfType;

  function isLeftClickEvent(event) {
    return event.button === 0;
  }

  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }

  // TODO: De-duplicate against hasAnyProperties in createTransitionManager.
  function isEmptyObject(object) {
    for (var p in object) {
      if (Object.prototype.hasOwnProperty.call(object, p)) return false;
    }return true;
  }

  function resolveToLocation(to, router) {
    return typeof to === 'function' ? to(router.location) : to;
  }

  /**
   * A <Link> is used to create an <a> element that links to a route.
   * When that route is active, the link gets the value of its
   * activeClassName prop.
   *
   * For example, assuming you have the following route:
   *
   *   <Route path="/posts/:postID" component={Post} />
   *
   * You could use the following component to link to that route:
   *
   *   <Link to={`/posts/${post.id}`} />
   *
   * Links may pass along location state and/or query string parameters
   * in the state/query props, respectively.
   *
   *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
   */
  var Link = _react2.default.createClass({
    displayName: 'Link',

    mixins: [(0, _ContextUtils.ContextSubscriber)('router')],

    contextTypes: {
      router: _PropTypes.routerShape
    },

    propTypes: {
      to: oneOfType([string, object, func]),
      query: object,
      hash: string,
      state: object,
      activeStyle: object,
      activeClassName: string,
      onlyActiveOnIndex: bool.isRequired,
      onClick: func,
      target: string
    },

    getDefaultProps: function getDefaultProps() {
      return {
        onlyActiveOnIndex: false,
        style: {}
      };
    },
    handleClick: function handleClick(event) {
      if (this.props.onClick) this.props.onClick(event);

      if (event.defaultPrevented) return;

      var router = this.context.router;

      !router ? 'production' !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;

      if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;

      // If target prop is set (e.g. to "_blank"), let browser handle link.
      /* istanbul ignore if: untestable with Karma */
      if (this.props.target) return;

      event.preventDefault();

      router.push(resolveToLocation(this.props.to, router));
    },
    render: function render() {
      var _props = this.props,
          to = _props.to,
          activeClassName = _props.activeClassName,
          activeStyle = _props.activeStyle,
          onlyActiveOnIndex = _props.onlyActiveOnIndex,
          props = _objectWithoutProperties(_props, ['to', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);

      // Ignore if rendered outside the context of router to simplify unit testing.


      var router = this.context.router;

      if (router) {
        // If user does not specify a `to` prop, return an empty anchor tag.
        if (to == null) {
          return _react2.default.createElement('a', props);
        }

        var toLocation = resolveToLocation(to, router);
        props.href = router.createHref(toLocation);

        if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
          if (router.isActive(toLocation, onlyActiveOnIndex)) {
            if (activeClassName) {
              if (props.className) {
                props.className += ' ' + activeClassName;
              } else {
                props.className = activeClassName;
              }
            }

            if (activeStyle) props.style = _extends({}, props.style, activeStyle);
          }
        }
      }

      return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
    }
  });

  exports.default = Link;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/IndexLink.js', ['react', './Link', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _Link = $__require('./Link');

  var _Link2 = _interopRequireDefault(_Link);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  /**
   * An <IndexLink> is used to link to an <IndexRoute>.
   */
  var IndexLink = _react2.default.createClass({
    displayName: 'IndexLink',
    render: function render() {
      return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
    }
  });

  exports.default = IndexLink;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:hoist-non-react-statics@1.2.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:hoist-non-react-statics@1.2.0/index.js', [], true, function ($__require, exports, module) {
    /**
     * Copyright 2015, Yahoo! Inc.
     * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
     */
    'use strict';

    var define,
        global = this || self,
        GLOBAL = global;
    var REACT_STATICS = {
        childContextTypes: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        mixins: true,
        propTypes: true,
        type: true
    };

    var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        arguments: true,
        arity: true
    };

    var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

    module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
        if (typeof sourceComponent !== 'string') {
            // don't hoist over string (html) components
            var keys = Object.getOwnPropertyNames(sourceComponent);

            /* istanbul ignore else */
            if (isGetOwnPropertySymbolsAvailable) {
                keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
            }

            for (var i = 0; i < keys.length; ++i) {
                if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                    try {
                        targetComponent[keys[i]] = sourceComponent[keys[i]];
                    } catch (error) {}
                }
            }
        }

        return targetComponent;
    };
    return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/PropTypes.js', ['react', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.locationShape = exports.routerShape = undefined;

  var _react = $__require('react');

  var func = _react.PropTypes.func,
      object = _react.PropTypes.object,
      shape = _react.PropTypes.shape,
      string = _react.PropTypes.string;
  var routerShape = exports.routerShape = shape({
    push: func.isRequired,
    replace: func.isRequired,
    go: func.isRequired,
    goBack: func.isRequired,
    goForward: func.isRequired,
    setRouteLeaveHook: func.isRequired,
    isActive: func.isRequired
  });

  var locationShape = exports.locationShape = shape({
    pathname: string.isRequired,
    search: string.isRequired,
    state: object,
    action: string.isRequired,
    key: string
  });
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/withRouter.js', ['invariant', 'react', 'hoist-non-react-statics', './ContextUtils', './PropTypes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.default = withRouter;

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _hoistNonReactStatics = $__require('hoist-non-react-statics');

  var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

  var _ContextUtils = $__require('./ContextUtils');

  var _PropTypes = $__require('./PropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || 'Component';
  }

  function withRouter(WrappedComponent, options) {
    var withRef = options && options.withRef;

    var WithRouter = _react2.default.createClass({
      displayName: 'WithRouter',

      mixins: [(0, _ContextUtils.ContextSubscriber)('router')],

      contextTypes: { router: _PropTypes.routerShape },
      propTypes: { router: _PropTypes.routerShape },

      getWrappedInstance: function getWrappedInstance() {
        !withRef ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;

        return this.wrappedInstance;
      },
      render: function render() {
        var _this = this;

        var router = this.props.router || this.context.router;
        var params = router.params,
            location = router.location,
            routes = router.routes;

        var props = _extends({}, this.props, { router: router, params: params, location: location, routes: routes });

        if (withRef) {
          props.ref = function (c) {
            _this.wrappedInstance = c;
          };
        }

        return _react2.default.createElement(WrappedComponent, props);
      }
    });

    WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
    WithRouter.WrappedComponent = WrappedComponent;

    return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/IndexRedirect.js', ['react', './routerWarning', 'invariant', './Redirect', './InternalPropTypes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _routerWarning = $__require('./routerWarning');

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _Redirect = $__require('./Redirect');

  var _Redirect2 = _interopRequireDefault(_Redirect);

  var _InternalPropTypes = $__require('./InternalPropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var _React$PropTypes = _react2.default.PropTypes,
      string = _React$PropTypes.string,
      object = _React$PropTypes.object;

  /**
   * An <IndexRedirect> is used to redirect from an indexRoute.
   */
  /* eslint-disable react/require-render-return */

  var IndexRedirect = _react2.default.createClass({
    displayName: 'IndexRedirect',

    statics: {
      createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
        /* istanbul ignore else: sanity check */
        if (parentRoute) {
          parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
        } else {
          'production' !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
        }
      }
    },

    propTypes: {
      to: string.isRequired,
      query: object,
      state: object,
      onEnter: _InternalPropTypes.falsy,
      children: _InternalPropTypes.falsy
    },

    /* istanbul ignore next: sanity check */
    render: function render() {
      !false ? 'production' !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
    }
  });

  exports.default = IndexRedirect;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/IndexRoute.js', ['react', './routerWarning', 'invariant', './RouteUtils', './InternalPropTypes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _routerWarning = $__require('./routerWarning');

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _RouteUtils = $__require('./RouteUtils');

  var _InternalPropTypes = $__require('./InternalPropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var func = _react2.default.PropTypes.func;

  /**
   * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
   * a JSX route config.
   */
  /* eslint-disable react/require-render-return */

  var IndexRoute = _react2.default.createClass({
    displayName: 'IndexRoute',

    statics: {
      createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
        /* istanbul ignore else: sanity check */
        if (parentRoute) {
          parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
        } else {
          'production' !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
        }
      }
    },

    propTypes: {
      path: _InternalPropTypes.falsy,
      component: _InternalPropTypes.component,
      components: _InternalPropTypes.components,
      getComponent: func,
      getComponents: func
    },

    /* istanbul ignore next: sanity check */
    render: function render() {
      !false ? 'production' !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
    }
  });

  exports.default = IndexRoute;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/Redirect.js', ['react', 'invariant', './RouteUtils', './PatternUtils', './InternalPropTypes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _RouteUtils = $__require('./RouteUtils');

  var _PatternUtils = $__require('./PatternUtils');

  var _InternalPropTypes = $__require('./InternalPropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var _React$PropTypes = _react2.default.PropTypes,
      string = _React$PropTypes.string,
      object = _React$PropTypes.object;

  /**
   * A <Redirect> is used to declare another URL path a client should
   * be sent to when they request a given URL.
   *
   * Redirects are placed alongside routes in the route configuration
   * and are traversed in the same manner.
   */
  /* eslint-disable react/require-render-return */

  var Redirect = _react2.default.createClass({
    displayName: 'Redirect',

    statics: {
      createRouteFromReactElement: function createRouteFromReactElement(element) {
        var route = (0, _RouteUtils.createRouteFromReactElement)(element);

        if (route.from) route.path = route.from;

        route.onEnter = function (nextState, replace) {
          var location = nextState.location,
              params = nextState.params;

          var pathname = void 0;
          if (route.to.charAt(0) === '/') {
            pathname = (0, _PatternUtils.formatPattern)(route.to, params);
          } else if (!route.to) {
            pathname = location.pathname;
          } else {
            var routeIndex = nextState.routes.indexOf(route);
            var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
            var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
            pathname = (0, _PatternUtils.formatPattern)(pattern, params);
          }

          replace({
            pathname: pathname,
            query: route.query || location.query,
            state: route.state || location.state
          });
        };

        return route;
      },
      getRoutePattern: function getRoutePattern(routes, routeIndex) {
        var parentPattern = '';

        for (var i = routeIndex; i >= 0; i--) {
          var route = routes[i];
          var pattern = route.path || '';

          parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;

          if (pattern.indexOf('/') === 0) break;
        }

        return '/' + parentPattern;
      }
    },

    propTypes: {
      path: string,
      from: string, // Alias for path
      to: string.isRequired,
      query: object,
      state: object,
      onEnter: _InternalPropTypes.falsy,
      children: _InternalPropTypes.falsy
    },

    /* istanbul ignore next: sanity check */
    render: function render() {
      !false ? 'production' !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
    }
  });

  exports.default = Redirect;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/InternalPropTypes.js', ['react', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
  exports.falsy = falsy;

  var _react = $__require('react');

  var func = _react.PropTypes.func,
      object = _react.PropTypes.object,
      arrayOf = _react.PropTypes.arrayOf,
      oneOfType = _react.PropTypes.oneOfType,
      element = _react.PropTypes.element,
      shape = _react.PropTypes.shape,
      string = _react.PropTypes.string;
  function falsy(props, propName, componentName) {
    if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
  }

  var history = exports.history = shape({
    listen: func.isRequired,
    push: func.isRequired,
    replace: func.isRequired,
    go: func.isRequired,
    goBack: func.isRequired,
    goForward: func.isRequired
  });

  var component = exports.component = oneOfType([func, string]);
  var components = exports.components = oneOfType([component, object]);
  var route = exports.route = oneOfType([object, element]);
  var routes = exports.routes = oneOfType([route, arrayOf(route)]);
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/Route.js', ['react', 'invariant', './RouteUtils', './InternalPropTypes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _RouteUtils = $__require('./RouteUtils');

  var _InternalPropTypes = $__require('./InternalPropTypes');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var _React$PropTypes = _react2.default.PropTypes,
      string = _React$PropTypes.string,
      func = _React$PropTypes.func;

  /**
   * A <Route> is used to declare which components are rendered to the
   * page when the URL matches a given pattern.
   *
   * Routes are arranged in a nested tree structure. When a new URL is
   * requested, the tree is searched depth-first to find a route whose
   * path matches the URL.  When one is found, all routes in the tree
   * that lead to it are considered "active" and their components are
   * rendered into the DOM, nested in the same order as in the tree.
   */
  /* eslint-disable react/require-render-return */

  var Route = _react2.default.createClass({
    displayName: 'Route',

    statics: {
      createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
    },

    propTypes: {
      path: string,
      component: _InternalPropTypes.component,
      components: _InternalPropTypes.components,
      getComponent: func,
      getComponents: func
    },

    /* istanbul ignore next: sanity check */
    render: function render() {
      !false ? 'production' !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
    }
  });

  exports.default = Route;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/computeChangedRoutes.js', ['./PatternUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _PatternUtils = $__require('./PatternUtils');

  function routeParamsChanged(route, prevState, nextState) {
    if (!route.path) return false;

    var paramNames = (0, _PatternUtils.getParamNames)(route.path);

    return paramNames.some(function (paramName) {
      return prevState.params[paramName] !== nextState.params[paramName];
    });
  }

  /**
   * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
   * the change from prevState to nextState. We leave routes if either
   * 1) they are not in the next state or 2) they are in the next state
   * but their params have changed (i.e. /users/123 => /users/456).
   *
   * leaveRoutes are ordered starting at the leaf route of the tree
   * we're leaving up to the common parent route. enterRoutes are ordered
   * from the top of the tree we're entering down to the leaf route.
   *
   * changeRoutes are any routes that didn't leave or enter during
   * the transition.
   */
  function computeChangedRoutes(prevState, nextState) {
    var prevRoutes = prevState && prevState.routes;
    var nextRoutes = nextState.routes;

    var leaveRoutes = void 0,
        changeRoutes = void 0,
        enterRoutes = void 0;
    if (prevRoutes) {
      (function () {
        var parentIsLeaving = false;
        leaveRoutes = prevRoutes.filter(function (route) {
          if (parentIsLeaving) {
            return true;
          } else {
            var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
            if (isLeaving) parentIsLeaving = true;
            return isLeaving;
          }
        });

        // onLeave hooks start at the leaf route.
        leaveRoutes.reverse();

        enterRoutes = [];
        changeRoutes = [];

        nextRoutes.forEach(function (route) {
          var isNew = prevRoutes.indexOf(route) === -1;
          var paramsChanged = leaveRoutes.indexOf(route) !== -1;

          if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
        });
      })();
    } else {
      leaveRoutes = [];
      changeRoutes = [];
      enterRoutes = nextRoutes;
    }

    return {
      leaveRoutes: leaveRoutes,
      changeRoutes: changeRoutes,
      enterRoutes: enterRoutes
    };
  }

  exports.default = computeChangedRoutes;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/TransitionUtils.js', ['./AsyncUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.runEnterHooks = runEnterHooks;
  exports.runChangeHooks = runChangeHooks;
  exports.runLeaveHooks = runLeaveHooks;

  var _AsyncUtils = $__require('./AsyncUtils');

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var PendingHooks = function PendingHooks() {
    var _this = this;

    _classCallCheck(this, PendingHooks);

    this.hooks = [];

    this.add = function (hook) {
      return _this.hooks.push(hook);
    };

    this.remove = function (hook) {
      return _this.hooks = _this.hooks.filter(function (h) {
        return h !== hook;
      });
    };

    this.has = function (hook) {
      return _this.hooks.indexOf(hook) !== -1;
    };

    this.clear = function () {
      return _this.hooks = [];
    };
  };

  var enterHooks = new PendingHooks();
  var changeHooks = new PendingHooks();

  function createTransitionHook(hook, route, asyncArity, pendingHooks) {
    var isSync = hook.length < asyncArity;

    var transitionHook = function transitionHook() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      hook.apply(route, args);

      if (isSync) {
        var callback = args[args.length - 1];
        // Assume hook executes synchronously and
        // automatically call the callback.
        callback();
      }
    };

    pendingHooks.add(transitionHook);

    return transitionHook;
  }

  function getEnterHooks(routes) {
    return routes.reduce(function (hooks, route) {
      if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));
      return hooks;
    }, []);
  }

  function getChangeHooks(routes) {
    return routes.reduce(function (hooks, route) {
      if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));
      return hooks;
    }, []);
  }

  function runTransitionHooks(length, iter, callback) {
    if (!length) {
      callback();
      return;
    }

    var redirectInfo = void 0;
    function replace(location) {
      redirectInfo = location;
    }

    (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
      iter(index, replace, function (error) {
        if (error || redirectInfo) {
          done(error, redirectInfo); // No need to continue.
        } else {
          next();
        }
      });
    }, callback);
  }

  /**
   * Runs all onEnter hooks in the given array of routes in order
   * with onEnter(nextState, replace, callback) and calls
   * callback(error, redirectInfo) when finished. The first hook
   * to use replace short-circuits the loop.
   *
   * If a hook needs to run asynchronously, it may use the callback
   * function. However, doing so will cause the transition to pause,
   * which could lead to a non-responsive UI if the hook is slow.
   */
  function runEnterHooks(routes, nextState, callback) {
    enterHooks.clear();
    var hooks = getEnterHooks(routes);
    return runTransitionHooks(hooks.length, function (index, replace, next) {
      var wrappedNext = function wrappedNext() {
        if (enterHooks.has(hooks[index])) {
          next();
          enterHooks.remove(hooks[index]);
        }
      };
      hooks[index](nextState, replace, wrappedNext);
    }, callback);
  }

  /**
   * Runs all onChange hooks in the given array of routes in order
   * with onChange(prevState, nextState, replace, callback) and calls
   * callback(error, redirectInfo) when finished. The first hook
   * to use replace short-circuits the loop.
   *
   * If a hook needs to run asynchronously, it may use the callback
   * function. However, doing so will cause the transition to pause,
   * which could lead to a non-responsive UI if the hook is slow.
   */
  function runChangeHooks(routes, state, nextState, callback) {
    changeHooks.clear();
    var hooks = getChangeHooks(routes);
    return runTransitionHooks(hooks.length, function (index, replace, next) {
      var wrappedNext = function wrappedNext() {
        if (changeHooks.has(hooks[index])) {
          next();
          changeHooks.remove(hooks[index]);
        }
      };
      hooks[index](state, nextState, replace, wrappedNext);
    }, callback);
  }

  /**
   * Runs all onLeave hooks in the given array of routes in order.
   */
  function runLeaveHooks(routes, prevState) {
    for (var i = 0, len = routes.length; i < len; ++i) {
      if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
    }
  }
  return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0/lib/isActive.js", ["./PatternUtils", "process"], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  exports.default = isActive;

  var _PatternUtils = $__require("./PatternUtils");

  function deepEqual(a, b) {
    if (a == b) return true;

    if (a == null || b == null) return false;

    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
        return deepEqual(item, b[index]);
      });
    }

    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
      for (var p in a) {
        if (!Object.prototype.hasOwnProperty.call(a, p)) {
          continue;
        }

        if (a[p] === undefined) {
          if (b[p] !== undefined) {
            return false;
          }
        } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
          return false;
        } else if (!deepEqual(a[p], b[p])) {
          return false;
        }
      }

      return true;
    }

    return String(a) === String(b);
  }

  /**
   * Returns true if the current pathname matches the supplied one, net of
   * leading and trailing slash normalization. This is sufficient for an
   * indexOnly route match.
   */
  function pathIsActive(pathname, currentPathname) {
    // Normalize leading slash for consistency. Leading slash on pathname has
    // already been normalized in isActive. See caveat there.
    if (currentPathname.charAt(0) !== '/') {
      currentPathname = '/' + currentPathname;
    }

    // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
    // `/foo` as active, but in this case, we would already have failed the
    // match.
    if (pathname.charAt(pathname.length - 1) !== '/') {
      pathname += '/';
    }
    if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
      currentPathname += '/';
    }

    return currentPathname === pathname;
  }

  /**
   * Returns true if the given pathname matches the active routes and params.
   */
  function routeIsActive(pathname, routes, params) {
    var remainingPathname = pathname,
        paramNames = [],
        paramValues = [];

    // for...of would work here but it's probably slower post-transpilation.
    for (var i = 0, len = routes.length; i < len; ++i) {
      var route = routes[i];
      var pattern = route.path || '';

      if (pattern.charAt(0) === '/') {
        remainingPathname = pathname;
        paramNames = [];
        paramValues = [];
      }

      if (remainingPathname !== null && pattern) {
        var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
        if (matched) {
          remainingPathname = matched.remainingPathname;
          paramNames = [].concat(paramNames, matched.paramNames);
          paramValues = [].concat(paramValues, matched.paramValues);
        } else {
          remainingPathname = null;
        }

        if (remainingPathname === '') {
          // We have an exact match on the route. Just check that all the params
          // match.
          // FIXME: This doesn't work on repeated params.
          return paramNames.every(function (paramName, index) {
            return String(paramValues[index]) === String(params[paramName]);
          });
        }
      }
    }

    return false;
  }

  /**
   * Returns true if all key/value pairs in the given query are
   * currently active.
   */
  function queryIsActive(query, activeQuery) {
    if (activeQuery == null) return query == null;

    if (query == null) return true;

    return deepEqual(query, activeQuery);
  }

  /**
   * Returns true if a <Link> to the given pathname/query combination is
   * currently active.
   */
  function isActive(_ref, indexOnly, currentLocation, routes, params) {
    var pathname = _ref.pathname,
        query = _ref.query;

    if (currentLocation == null) return false;

    // TODO: This is a bit ugly. It keeps around support for treating pathnames
    // without preceding slashes as absolute paths, but possibly also works
    // around the same quirks with basenames as in matchRoutes.
    if (pathname.charAt(0) !== '/') {
      pathname = '/' + pathname;
    }

    if (!pathIsActive(pathname, currentLocation.pathname)) {
      // The path check is necessary and sufficient for indexOnly, but otherwise
      // we still need to check the routes.
      if (indexOnly || !routeIsActive(pathname, routes, params)) {
        return false;
      }
    }

    return queryIsActive(query, currentLocation.query);
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/getComponents.js', ['./AsyncUtils', './PromiseUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _AsyncUtils = $__require('./AsyncUtils');

  var _PromiseUtils = $__require('./PromiseUtils');

  function getComponentsForRoute(nextState, route, callback) {
    if (route.component || route.components) {
      callback(null, route.component || route.components);
      return;
    }

    var getComponent = route.getComponent || route.getComponents;
    if (getComponent) {
      var componentReturn = getComponent.call(route, nextState, callback);
      if ((0, _PromiseUtils.isPromise)(componentReturn)) componentReturn.then(function (component) {
        return callback(null, component);
      }, callback);
    } else {
      callback();
    }
  }

  /**
   * Asynchronously fetches all components needed for the given router
   * state and calls callback(error, components) when finished.
   *
   * Note: This operation may finish synchronously if no routes have an
   * asynchronous getComponents method.
   */
  function getComponents(nextState, callback) {
    (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
      getComponentsForRoute(nextState, route, callback);
    }, callback);
  }

  exports.default = getComponents;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0/lib/AsyncUtils.js", ["process"], true, function ($__require, exports, module) {
  "use strict";

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.loopAsync = loopAsync;
  exports.mapAsync = mapAsync;
  function loopAsync(turns, work, callback) {
    var currentTurn = 0,
        isDone = false;
    var sync = false,
        hasNext = false,
        doneArgs = void 0;

    function done() {
      isDone = true;
      if (sync) {
        // Iterate instead of recursing if possible.
        doneArgs = [].concat(Array.prototype.slice.call(arguments));
        return;
      }

      callback.apply(this, arguments);
    }

    function next() {
      if (isDone) {
        return;
      }

      hasNext = true;
      if (sync) {
        // Iterate instead of recursing if possible.
        return;
      }

      sync = true;

      while (!isDone && currentTurn < turns && hasNext) {
        hasNext = false;
        work.call(this, currentTurn++, next, done);
      }

      sync = false;

      if (isDone) {
        // This means the loop finished synchronously.
        callback.apply(this, doneArgs);
        return;
      }

      if (currentTurn >= turns && hasNext) {
        isDone = true;
        callback();
      }
    }

    next();
  }

  function mapAsync(array, work, callback) {
    var length = array.length;
    var values = [];

    if (length === 0) return callback(null, values);

    var isDone = false,
        doneCount = 0;

    function done(index, error, value) {
      if (isDone) return;

      if (error) {
        isDone = true;
        callback(error);
      } else {
        values[index] = value;

        isDone = ++doneCount === length;

        if (isDone) callback(null, values);
      }
    }

    array.forEach(function (item, index) {
      work(item, index, function (error, value) {
        done(index, error, value);
      });
    });
  }
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/PromiseUtils.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.isPromise = isPromise;
  function isPromise(obj) {
    return obj && typeof obj.then === 'function';
  }
  return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0/lib/matchRoutes.js", ["./AsyncUtils", "./PromiseUtils", "./PatternUtils", "./routerWarning", "./RouteUtils", "process"], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  exports.default = matchRoutes;

  var _AsyncUtils = $__require("./AsyncUtils");

  var _PromiseUtils = $__require("./PromiseUtils");

  var _PatternUtils = $__require("./PatternUtils");

  var _routerWarning = $__require("./routerWarning");

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  var _RouteUtils = $__require("./RouteUtils");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function getChildRoutes(route, location, paramNames, paramValues, callback) {
    if (route.childRoutes) {
      return [null, route.childRoutes];
    }
    if (!route.getChildRoutes) {
      return [];
    }

    var sync = true,
        result = void 0;

    var partialNextState = {
      location: location,
      params: createParams(paramNames, paramValues)
    };

    var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {
      childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
      if (sync) {
        result = [error, childRoutes];
        return;
      }

      callback(error, childRoutes);
    });

    if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {
      return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));
    }, callback);

    sync = false;
    return result; // Might be undefined.
  }

  function getIndexRoute(route, location, paramNames, paramValues, callback) {
    if (route.indexRoute) {
      callback(null, route.indexRoute);
    } else if (route.getIndexRoute) {
      var partialNextState = {
        location: location,
        params: createParams(paramNames, paramValues)
      };

      var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {
        callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
      });

      if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {
        return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);
      }, callback);
    } else if (route.childRoutes) {
      (function () {
        var pathless = route.childRoutes.filter(function (childRoute) {
          return !childRoute.path;
        });

        (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
          getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
            if (error || indexRoute) {
              var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
              done(error, routes);
            } else {
              next();
            }
          });
        }, function (err, routes) {
          callback(null, routes);
        });
      })();
    } else {
      callback();
    }
  }

  function assignParams(params, paramNames, paramValues) {
    return paramNames.reduce(function (params, paramName, index) {
      var paramValue = paramValues && paramValues[index];

      if (Array.isArray(params[paramName])) {
        params[paramName].push(paramValue);
      } else if (paramName in params) {
        params[paramName] = [params[paramName], paramValue];
      } else {
        params[paramName] = paramValue;
      }

      return params;
    }, params);
  }

  function createParams(paramNames, paramValues) {
    return assignParams({}, paramNames, paramValues);
  }

  function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
    var pattern = route.path || '';

    if (pattern.charAt(0) === '/') {
      remainingPathname = location.pathname;
      paramNames = [];
      paramValues = [];
    }

    // Only try to match the path if the route actually has a pattern, and if
    // we're not just searching for potential nested absolute paths.
    if (remainingPathname !== null && pattern) {
      try {
        var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
        if (matched) {
          remainingPathname = matched.remainingPathname;
          paramNames = [].concat(paramNames, matched.paramNames);
          paramValues = [].concat(paramValues, matched.paramValues);
        } else {
          remainingPathname = null;
        }
      } catch (error) {
        callback(error);
      }

      // By assumption, pattern is non-empty here, which is the prerequisite for
      // actually terminating a match.
      if (remainingPathname === '') {
        var _ret2 = function () {
          var match = {
            routes: [route],
            params: createParams(paramNames, paramValues)
          };

          getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
            if (error) {
              callback(error);
            } else {
              if (Array.isArray(indexRoute)) {
                var _match$routes;

                "production" !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
                  return !route.path;
                }), 'Index routes should not have paths') : void 0;
                (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
              } else if (indexRoute) {
                "production" !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
                match.routes.push(indexRoute);
              }

              callback(null, match);
            }
          });

          return {
            v: void 0
          };
        }();

        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
      }
    }

    if (remainingPathname != null || route.childRoutes) {
      // Either a) this route matched at least some of the path or b)
      // we don't have to load this route's children asynchronously. In
      // either case continue checking for matches in the subtree.
      var onChildRoutes = function onChildRoutes(error, childRoutes) {
        if (error) {
          callback(error);
        } else if (childRoutes) {
          // Check the child routes to see if any of them match.
          matchRoutes(childRoutes, location, function (error, match) {
            if (error) {
              callback(error);
            } else if (match) {
              // A child route matched! Augment the match and pass it up the stack.
              match.routes.unshift(route);
              callback(null, match);
            } else {
              callback();
            }
          }, remainingPathname, paramNames, paramValues);
        } else {
          callback();
        }
      };

      var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
      if (result) {
        onChildRoutes.apply(undefined, result);
      }
    } else {
      callback();
    }
  }

  /**
   * Asynchronously matches the given location to a set of routes and calls
   * callback(error, state) when finished. The state object will have the
   * following properties:
   *
   * - routes       An array of routes that matched, in hierarchical order
   * - params       An object of URL parameters
   *
   * Note: This operation may finish synchronously if no routes have an
   * asynchronous getChildRoutes method.
   */
  function matchRoutes(routes, location, callback, remainingPathname) {
    var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];

    if (remainingPathname === undefined) {
      // TODO: This is a little bit ugly, but it works around a quirk in history
      // that strips the leading slash from pathnames when using basenames with
      // trailing slashes.
      if (location.pathname.charAt(0) !== '/') {
        location = _extends({}, location, {
          pathname: '/' + location.pathname
        });
      }
      remainingPathname = location.pathname;
    }

    (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
      matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
        if (error || match) {
          done(error, match);
        } else {
          next();
        }
      });
    }, callback);
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/createTransitionManager.js', ['./routerWarning', './computeChangedRoutes', './TransitionUtils', './isActive', './getComponents', './matchRoutes', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.default = createTransitionManager;

  var _routerWarning = $__require('./routerWarning');

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  var _computeChangedRoutes2 = $__require('./computeChangedRoutes');

  var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);

  var _TransitionUtils = $__require('./TransitionUtils');

  var _isActive2 = $__require('./isActive');

  var _isActive3 = _interopRequireDefault(_isActive2);

  var _getComponents = $__require('./getComponents');

  var _getComponents2 = _interopRequireDefault(_getComponents);

  var _matchRoutes = $__require('./matchRoutes');

  var _matchRoutes2 = _interopRequireDefault(_matchRoutes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function hasAnyProperties(object) {
    for (var p in object) {
      if (Object.prototype.hasOwnProperty.call(object, p)) return true;
    }return false;
  }

  function createTransitionManager(history, routes) {
    var state = {};

    // Signature should be (location, indexOnly), but needs to support (path,
    // query, indexOnly)
    function isActive(location, indexOnly) {
      location = history.createLocation(location);

      return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
    }

    var partialNextState = void 0;

    function match(location, callback) {
      if (partialNextState && partialNextState.location === location) {
        // Continue from where we left off.
        finishMatch(partialNextState, callback);
      } else {
        (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
          if (error) {
            callback(error);
          } else if (nextState) {
            finishMatch(_extends({}, nextState, { location: location }), callback);
          } else {
            callback();
          }
        });
      }
    }

    function finishMatch(nextState, callback) {
      var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState),
          leaveRoutes = _computeChangedRoutes.leaveRoutes,
          changeRoutes = _computeChangedRoutes.changeRoutes,
          enterRoutes = _computeChangedRoutes.enterRoutes;

      (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);

      // Tear down confirmation hooks for left routes
      leaveRoutes.filter(function (route) {
        return enterRoutes.indexOf(route) === -1;
      }).forEach(removeListenBeforeHooksForRoute);

      // change and enter hooks are run in series
      (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
        if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

        (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
      });

      function finishEnterHooks(error, redirectInfo) {
        if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

        // TODO: Fetch components after state is updated.
        (0, _getComponents2.default)(nextState, function (error, components) {
          if (error) {
            callback(error);
          } else {
            // TODO: Make match a pure function and have some other API
            // for "match and update state".
            callback(null, null, state = _extends({}, nextState, { components: components }));
          }
        });
      }

      function handleErrorOrRedirect(error, redirectInfo) {
        if (error) callback(error);else callback(null, redirectInfo);
      }
    }

    var RouteGuid = 1;

    function getRouteID(route) {
      var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      return route.__id__ || create && (route.__id__ = RouteGuid++);
    }

    var RouteHooks = Object.create(null);

    function getRouteHooksForRoutes(routes) {
      return routes.map(function (route) {
        return RouteHooks[getRouteID(route)];
      }).filter(function (hook) {
        return hook;
      });
    }

    function transitionHook(location, callback) {
      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
        if (nextState == null) {
          // TODO: We didn't actually match anything, but hang
          // onto error/nextState so we don't have to matchRoutes
          // again in the listen callback.
          callback();
          return;
        }

        // Cache some state here so we don't have to
        // matchRoutes() again in the listen callback.
        partialNextState = _extends({}, nextState, { location: location });

        var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);

        var result = void 0;
        for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
          // Passing the location arg here indicates to
          // the user that this is a transition hook.
          result = hooks[i](location);
        }

        callback(result);
      });
    }

    /* istanbul ignore next: untestable with Karma */
    function beforeUnloadHook() {
      // Synchronously check to see if any route hooks want
      // to prevent the current window/tab from closing.
      if (state.routes) {
        var hooks = getRouteHooksForRoutes(state.routes);

        var message = void 0;
        for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
          // Passing no args indicates to the user that this is a
          // beforeunload hook. We don't know the next location.
          message = hooks[i]();
        }

        return message;
      }
    }

    var unlistenBefore = void 0,
        unlistenBeforeUnload = void 0;

    function removeListenBeforeHooksForRoute(route) {
      var routeID = getRouteID(route);
      if (!routeID) {
        return;
      }

      delete RouteHooks[routeID];

      if (!hasAnyProperties(RouteHooks)) {
        // teardown transition & beforeunload hooks
        if (unlistenBefore) {
          unlistenBefore();
          unlistenBefore = null;
        }

        if (unlistenBeforeUnload) {
          unlistenBeforeUnload();
          unlistenBeforeUnload = null;
        }
      }
    }

    /**
     * Registers the given hook function to run before leaving the given route.
     *
     * During a normal transition, the hook function receives the next location
     * as its only argument and can return either a prompt message (string) to show the user,
     * to make sure they want to leave the page; or `false`, to prevent the transition.
     * Any other return value will have no effect.
     *
     * During the beforeunload event (in browsers) the hook receives no arguments.
     * In this case it must return a prompt message to prevent the transition.
     *
     * Returns a function that may be used to unbind the listener.
     */
    function listenBeforeLeavingRoute(route, hook) {
      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
      var routeID = getRouteID(route, true);

      RouteHooks[routeID] = hook;

      if (thereWereNoRouteHooks) {
        // setup transition & beforeunload hooks
        unlistenBefore = history.listenBefore(transitionHook);

        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
      }

      return function () {
        removeListenBeforeHooksForRoute(route);
      };
    }

    /**
     * This is the API for stateful environments. As the location
     * changes, we update state and call the listener. We can also
     * gracefully handle errors and redirects.
     */
    function listen(listener) {
      function historyListener(location) {
        if (state.location === location) {
          listener(null, state);
        } else {
          match(location, function (error, redirectLocation, nextState) {
            if (error) {
              listener(error);
            } else if (redirectLocation) {
              history.replace(redirectLocation);
            } else if (nextState) {
              listener(null, nextState);
            } else {
              'production' !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
            }
          });
        }
      }

      // TODO: Only use a single history listener. Otherwise we'll end up with
      // multiple concurrent calls to match.

      // Set up the history listener first in case the initial match redirects.
      var unsubscribe = history.listen(historyListener);

      if (state.location) {
        // Picking up on a matchContext.
        listener(null, state);
      } else {
        historyListener(history.getCurrentLocation());
      }

      return unsubscribe;
    }

    return {
      isActive: isActive,
      match: match,
      listenBeforeLeavingRoute: listenBeforeLeavingRoute,
      listen: listen
    };
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0/lib/RouterUtils.js", ["process"], true, function ($__require, exports, module) {
  "use strict";

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.createRouterObject = createRouterObject;
  exports.assignRouterState = assignRouterState;
  function createRouterObject(history, transitionManager, state) {
    var router = _extends({}, history, {
      setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
      isActive: transitionManager.isActive
    });

    return assignRouterState(router, state);
  }

  function assignRouterState(router, _ref) {
    var location = _ref.location,
        params = _ref.params,
        routes = _ref.routes;

    router.location = location;
    router.params = params;
    router.routes = routes;

    return router;
  }
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/match.js', ['history/lib/Actions', 'invariant', './createMemoryHistory', './createTransitionManager', './RouteUtils', './RouterUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _Actions = $__require('history/lib/Actions');

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _createMemoryHistory = $__require('./createMemoryHistory');

  var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

  var _createTransitionManager = $__require('./createTransitionManager');

  var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

  var _RouteUtils = $__require('./RouteUtils');

  var _RouterUtils = $__require('./RouterUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  }

  /**
   * A high-level API to be used for server-side rendering.
   *
   * This function matches a location to a set of routes and calls
   * callback(error, redirectLocation, renderProps) when finished.
   *
   * Note: You probably don't want to use this in a browser unless you're using
   * server-side rendering with async routes.
   */
  function match(_ref, callback) {
    var history = _ref.history,
        routes = _ref.routes,
        location = _ref.location,
        options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);

    !(history || location) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;

    history = history ? history : (0, _createMemoryHistory2.default)(options);
    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));

    if (location) {
      // Allow match({ location: '/the/path', ... })
      location = history.createLocation(location);
    } else {
      location = history.getCurrentLocation();
    }

    transitionManager.match(location, function (error, redirectLocation, nextState) {
      var renderProps = void 0;

      if (nextState) {
        var router = (0, _RouterUtils.createRouterObject)(history, transitionManager, nextState);
        renderProps = _extends({}, nextState, {
          router: router,
          matchContext: { transitionManager: transitionManager, router: router }
        });
      }

      callback(error, redirectLocation && history.createLocation(redirectLocation, _Actions.REPLACE), renderProps);
    });
  }

  exports.default = match;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/PatternUtils.js', ['invariant', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.compilePattern = compilePattern;
  exports.matchPattern = matchPattern;
  exports.getParamNames = getParamNames;
  exports.getParams = getParams;
  exports.formatPattern = formatPattern;

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function _compilePattern(pattern) {
    var regexpSource = '';
    var paramNames = [];
    var tokens = [];

    var match = void 0,
        lastIndex = 0,
        matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
    while (match = matcher.exec(pattern)) {
      if (match.index !== lastIndex) {
        tokens.push(pattern.slice(lastIndex, match.index));
        regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
      }

      if (match[1]) {
        regexpSource += '([^/]+)';
        paramNames.push(match[1]);
      } else if (match[0] === '**') {
        regexpSource += '(.*)';
        paramNames.push('splat');
      } else if (match[0] === '*') {
        regexpSource += '(.*?)';
        paramNames.push('splat');
      } else if (match[0] === '(') {
        regexpSource += '(?:';
      } else if (match[0] === ')') {
        regexpSource += ')?';
      }

      tokens.push(match[0]);

      lastIndex = matcher.lastIndex;
    }

    if (lastIndex !== pattern.length) {
      tokens.push(pattern.slice(lastIndex, pattern.length));
      regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
    }

    return {
      pattern: pattern,
      regexpSource: regexpSource,
      paramNames: paramNames,
      tokens: tokens
    };
  }

  var CompiledPatternsCache = Object.create(null);

  function compilePattern(pattern) {
    if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);

    return CompiledPatternsCache[pattern];
  }

  /**
   * Attempts to match a pattern on the given pathname. Patterns may use
   * the following special characters:
   *
   * - :paramName     Matches a URL segment up to the next /, ?, or #. The
   *                  captured string is considered a "param"
   * - ()             Wraps a segment of the URL that is optional
   * - *              Consumes (non-greedy) all characters up to the next
   *                  character in the pattern, or to the end of the URL if
   *                  there is none
   * - **             Consumes (greedy) all characters up to the next character
   *                  in the pattern, or to the end of the URL if there is none
   *
   *  The function calls callback(error, matched) when finished.
   * The return value is an object with the following properties:
   *
   * - remainingPathname
   * - paramNames
   * - paramValues
   */
  function matchPattern(pattern, pathname) {
    // Ensure pattern starts with leading slash for consistency with pathname.
    if (pattern.charAt(0) !== '/') {
      pattern = '/' + pattern;
    }

    var _compilePattern2 = compilePattern(pattern),
        regexpSource = _compilePattern2.regexpSource,
        paramNames = _compilePattern2.paramNames,
        tokens = _compilePattern2.tokens;

    if (pattern.charAt(pattern.length - 1) !== '/') {
      regexpSource += '/?'; // Allow optional path separator at end.
    }

    // Special-case patterns like '*' for catch-all routes.
    if (tokens[tokens.length - 1] === '*') {
      regexpSource += '$';
    }

    var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
    if (match == null) {
      return null;
    }

    var matchedPath = match[0];
    var remainingPathname = pathname.substr(matchedPath.length);

    if (remainingPathname) {
      // Require that the match ends at a path separator, if we didn't match
      // the full path, so any remaining pathname is a new path segment.
      if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
        return null;
      }

      // If there is a remaining pathname, treat the path separator as part of
      // the remaining pathname for properly continuing the match.
      remainingPathname = '/' + remainingPathname;
    }

    return {
      remainingPathname: remainingPathname,
      paramNames: paramNames,
      paramValues: match.slice(1).map(function (v) {
        return v && decodeURIComponent(v);
      })
    };
  }

  function getParamNames(pattern) {
    return compilePattern(pattern).paramNames;
  }

  function getParams(pattern, pathname) {
    var match = matchPattern(pattern, pathname);
    if (!match) {
      return null;
    }

    var paramNames = match.paramNames,
        paramValues = match.paramValues;

    var params = {};

    paramNames.forEach(function (paramName, index) {
      params[paramName] = paramValues[index];
    });

    return params;
  }

  /**
   * Returns a version of the given pattern with params interpolated. Throws
   * if there is a dynamic segment of the pattern for which there is no param.
   */
  function formatPattern(pattern, params) {
    params = params || {};

    var _compilePattern3 = compilePattern(pattern),
        tokens = _compilePattern3.tokens;

    var parenCount = 0,
        pathname = '',
        splatIndex = 0,
        parenHistory = [];

    var token = void 0,
        paramName = void 0,
        paramValue = void 0;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];

      if (token === '*' || token === '**') {
        paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;

        !(paramValue != null || parenCount > 0) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;

        if (paramValue != null) pathname += encodeURI(paramValue);
      } else if (token === '(') {
        parenHistory[parenCount] = '';
        parenCount += 1;
      } else if (token === ')') {
        var parenText = parenHistory.pop();
        parenCount -= 1;

        if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;
      } else if (token.charAt(0) === ':') {
        paramName = token.substring(1);
        paramValue = params[paramName];

        !(paramValue != null || parenCount > 0) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;

        if (paramValue == null) {
          if (parenCount) {
            parenHistory[parenCount - 1] = '';

            var curTokenIdx = tokens.indexOf(token);
            var tokensSubset = tokens.slice(curTokenIdx, tokens.length);
            var nextParenIdx = -1;

            for (var _i = 0; _i < tokensSubset.length; _i++) {
              if (tokensSubset[_i] == ')') {
                nextParenIdx = _i;
                break;
              }
            }

            !(nextParenIdx > 0) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren at segment "%s"', pattern, tokensSubset.join('')) : (0, _invariant2.default)(false) : void 0;

            // jump to ending paren
            i = curTokenIdx + nextParenIdx - 1;
          }
        } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);
      } else {
        if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;
      }
    }

    !(parenCount <= 0) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren', pattern) : (0, _invariant2.default)(false) : void 0;

    return pathname.replace(/\/+/g, '/');
  }
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/getRouteParams.js', ['./PatternUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _PatternUtils = $__require('./PatternUtils');

  /**
   * Extracts an object of params the given route cares about from
   * the given params object.
   */
  function getRouteParams(route, params) {
    var routeParams = {};

    if (!route.path) return routeParams;

    (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
      if (Object.prototype.hasOwnProperty.call(params, p)) {
        routeParams[p] = params[p];
      }
    });

    return routeParams;
  }

  exports.default = getRouteParams;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/ContextUtils.js', ['react', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.ContextProvider = ContextProvider;
  exports.ContextSubscriber = ContextSubscriber;

  var _react = $__require('react');

  // Works around issues with context updates failing to propagate.
  // Caveat: the context value is expected to never change its identity.
  // https://github.com/facebook/react/issues/2517
  // https://github.com/reactjs/react-router/issues/470

  var contextProviderShape = _react.PropTypes.shape({
    subscribe: _react.PropTypes.func.isRequired,
    eventIndex: _react.PropTypes.number.isRequired
  });

  function makeContextName(name) {
    return '@@contextSubscriber/' + name;
  }

  function ContextProvider(name) {
    var _childContextTypes, _ref2;

    var contextName = makeContextName(name);
    var listenersKey = contextName + '/listeners';
    var eventIndexKey = contextName + '/eventIndex';
    var subscribeKey = contextName + '/subscribe';

    return _ref2 = {
      childContextTypes: (_childContextTypes = {}, _childContextTypes[contextName] = contextProviderShape.isRequired, _childContextTypes),

      getChildContext: function getChildContext() {
        var _ref;

        return _ref = {}, _ref[contextName] = {
          eventIndex: this[eventIndexKey],
          subscribe: this[subscribeKey]
        }, _ref;
      },
      componentWillMount: function componentWillMount() {
        this[listenersKey] = [];
        this[eventIndexKey] = 0;
      },
      componentWillReceiveProps: function componentWillReceiveProps() {
        this[eventIndexKey]++;
      },
      componentDidUpdate: function componentDidUpdate() {
        var _this = this;

        this[listenersKey].forEach(function (listener) {
          return listener(_this[eventIndexKey]);
        });
      }
    }, _ref2[subscribeKey] = function (listener) {
      var _this2 = this;

      // No need to immediately call listener here.
      this[listenersKey].push(listener);

      return function () {
        _this2[listenersKey] = _this2[listenersKey].filter(function (item) {
          return item !== listener;
        });
      };
    }, _ref2;
  }

  function ContextSubscriber(name) {
    var _contextTypes, _ref4;

    var contextName = makeContextName(name);
    var lastRenderedEventIndexKey = contextName + '/lastRenderedEventIndex';
    var handleContextUpdateKey = contextName + '/handleContextUpdate';
    var unsubscribeKey = contextName + '/unsubscribe';

    return _ref4 = {
      contextTypes: (_contextTypes = {}, _contextTypes[contextName] = contextProviderShape, _contextTypes),

      getInitialState: function getInitialState() {
        var _ref3;

        if (!this.context[contextName]) {
          return {};
        }

        return _ref3 = {}, _ref3[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _ref3;
      },
      componentDidMount: function componentDidMount() {
        if (!this.context[contextName]) {
          return;
        }

        this[unsubscribeKey] = this.context[contextName].subscribe(this[handleContextUpdateKey]);
      },
      componentWillReceiveProps: function componentWillReceiveProps() {
        var _setState;

        if (!this.context[contextName]) {
          return;
        }

        this.setState((_setState = {}, _setState[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _setState));
      },
      componentWillUnmount: function componentWillUnmount() {
        if (!this[unsubscribeKey]) {
          return;
        }

        this[unsubscribeKey]();
        this[unsubscribeKey] = null;
      }
    }, _ref4[handleContextUpdateKey] = function (eventIndex) {
      if (eventIndex !== this.state[lastRenderedEventIndexKey]) {
        var _setState2;

        this.setState((_setState2 = {}, _setState2[lastRenderedEventIndexKey] = eventIndex, _setState2));
      }
    }, _ref4;
  }
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/PooledClass.js', ['./reactProdInvariant', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Static poolers. Several custom versions for each potential number of
   * arguments. A completely generic pooler is easy to implement, but would
   * require accessing the `arguments` object. In each of these, `this` refers to
   * the Class itself, not an instance. If any others are needed, simply add them
   * here, or in their own files.
   */
  var oneArgumentPooler = function (copyFieldsFrom) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, copyFieldsFrom);
      return instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };

  var twoArgumentPooler = function (a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };

  var threeArgumentPooler = function (a1, a2, a3) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3);
      return instance;
    } else {
      return new Klass(a1, a2, a3);
    }
  };

  var fourArgumentPooler = function (a1, a2, a3, a4) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };

  var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2, a3, a4, a5);
      return instance;
    } else {
      return new Klass(a1, a2, a3, a4, a5);
    }
  };

  var standardReleaser = function (instance) {
    var Klass = this;
    !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };

  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;

  /**
   * Augments `CopyConstructor` to be a poolable class, augmenting only the class
   * itself (statically) not adding any prototypical fields. Any CopyConstructor
   * you give this may have a `poolSize` property, and will look for a
   * prototypical `destructor` on instances.
   *
   * @param {Function} CopyConstructor Constructor that can be used to reset.
   * @param {Function} pooler Customizable pooler.
   */
  var addPoolingTo = function (CopyConstructor, pooler) {
    // Casting as any so that flow ignores the actual implementation and trusts
    // it to match the type we declared
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };

  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler,
    fiveArgumentPooler: fiveArgumentPooler
  };

  module.exports = PooledClass;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/KeyEscapeUtils.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/traverseAllChildren.js', ['./reactProdInvariant', './ReactCurrentOwner', './ReactElementSymbol', './getIteratorFn', 'fbjs/lib/invariant', './KeyEscapeUtils', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var REACT_ELEMENT_TYPE = $__require('./ReactElementSymbol');

  var getIteratorFn = $__require('./getIteratorFn');
  var invariant = $__require('fbjs/lib/invariant');
  var KeyEscapeUtils = $__require('./KeyEscapeUtils');
  var warning = $__require('fbjs/lib/warning');

  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';

  /**
   * This is inlined from ReactElement since this file is shared between
   * isomorphic and renderers. We could extract this to a
   *
   */

  /**
   * TODO: Test that a single child and an array with one item have the same key
   * pattern.
   */

  var didWarnAboutMaps = false;

  /**
   * Generate a key string that identifies a component within a set.
   *
   * @param {*} component A component that could contain a manual key.
   * @param {number} index Index that is used if a manual key is not provided.
   * @return {string}
   */
  function getComponentKey(component, index) {
    // Do some typechecking here since we call this blindly. We want to ensure
    // that we don't block potential future ES APIs.
    if (component && typeof component === 'object' && component.key != null) {
      // Explicit key
      return KeyEscapeUtils.escape(component.key);
    }
    // Implicit key determined by the index in the set
    return index.toString(36);
  }

  /**
   * @param {?*} children Children tree container.
   * @param {!string} nameSoFar Name of the key path so far.
   * @param {!function} callback Callback to invoke with each child found.
   * @param {?*} traverseContext Used to pass information throughout the traversal
   * process.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
    var type = typeof children;

    if (type === 'undefined' || type === 'boolean') {
      // All of the above are perceived as null.
      children = null;
    }

    if (children === null || type === 'string' || type === 'number' ||
    // The following is inlined from ReactElement. This means we can optimize
    // some checks. React Fiber also inlines this logic for similar purposes.
    type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
      callback(traverseContext, children,
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows.
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
      return 1;
    }

    var child;
    var nextName;
    var subtreeCount = 0; // Count of children found in the current subtree.
    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        nextName = nextNamePrefix + getComponentKey(child, i);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else {
      var iteratorFn = getIteratorFn(children);
      if (iteratorFn) {
        var iterator = iteratorFn.call(children);
        var step;
        if (iteratorFn !== children.entries) {
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else {
          if ('production' !== 'production') {
            var mapsAsChildrenAddendum = '';
            if (ReactCurrentOwner.current) {
              var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
              if (mapsAsChildrenOwnerName) {
                mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
              }
            }
            'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
            didWarnAboutMaps = true;
          }
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              child = entry[1];
              nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          }
        }
      } else if (type === 'object') {
        var addendum = '';
        if ('production' !== 'production') {
          addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
          if (children._isReactElement) {
            addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
          }
          if (ReactCurrentOwner.current) {
            var name = ReactCurrentOwner.current.getName();
            if (name) {
              addendum += ' Check the render method of `' + name + '`.';
            }
          }
        }
        var childrenString = String(children);
        !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
      }
    }

    return subtreeCount;
  }

  /**
   * Traverses children that are typically specified as `props.children`, but
   * might also be specified through attributes:
   *
   * - `traverseAllChildren(this.props.children, ...)`
   * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
   *
   * The `traverseContext` is an optional argument that is passed through the
   * entire traversal. It can be used to store accumulations or anything else that
   * the callback might find relevant.
   *
   * @param {?*} children Children tree object.
   * @param {!function} callback To invoke upon traversing each child.
   * @param {?*} traverseContext Context for traversal.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildren(children, callback, traverseContext) {
    if (children == null) {
      return 0;
    }

    return traverseAllChildrenImpl(children, '', callback, traverseContext);
  }

  module.exports = traverseAllChildren;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactChildren.js', ['./PooledClass', './ReactElement', 'fbjs/lib/emptyFunction', './traverseAllChildren', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var PooledClass = $__require('./PooledClass');
  var ReactElement = $__require('./ReactElement');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var traverseAllChildren = $__require('./traverseAllChildren');

  var twoArgumentPooler = PooledClass.twoArgumentPooler;
  var fourArgumentPooler = PooledClass.fourArgumentPooler;

  var userProvidedKeyEscapeRegex = /\/+/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
  }

  /**
   * PooledClass representing the bookkeeping associated with performing a child
   * traversal. Allows avoiding binding callbacks.
   *
   * @constructor ForEachBookKeeping
   * @param {!function} forEachFunction Function to perform traversal with.
   * @param {?*} forEachContext Context to perform context with.
   */
  function ForEachBookKeeping(forEachFunction, forEachContext) {
    this.func = forEachFunction;
    this.context = forEachContext;
    this.count = 0;
  }
  ForEachBookKeeping.prototype.destructor = function () {
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func,
        context = bookKeeping.context;

    func.call(context, child, bookKeeping.count++);
  }

  /**
   * Iterates through children that are typically specified as `props.children`.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
   *
   * The provided forEachFunc(child, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} forEachFunc
   * @param {*} forEachContext Context for forEachContext.
   */
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    ForEachBookKeeping.release(traverseContext);
  }

  /**
   * PooledClass representing the bookkeeping associated with performing a child
   * mapping. Allows avoiding binding callbacks.
   *
   * @constructor MapBookKeeping
   * @param {!*} mapResult Object containing the ordered map of results.
   * @param {!function} mapFunction Function to perform mapping with.
   * @param {?*} mapContext Context to perform mapping with.
   */
  function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
    this.result = mapResult;
    this.keyPrefix = keyPrefix;
    this.func = mapFunction;
    this.context = mapContext;
    this.count = 0;
  }
  MapBookKeeping.prototype.destructor = function () {
    this.result = null;
    this.keyPrefix = null;
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result,
        keyPrefix = bookKeeping.keyPrefix,
        func = bookKeeping.func,
        context = bookKeeping.context;

    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (ReactElement.isValidElement(mappedChild)) {
        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
        // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }

  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    MapBookKeeping.release(traverseContext);
  }

  /**
   * Maps children that are typically specified as `props.children`.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
   *
   * The provided mapFunction(child, key, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} func The map function.
   * @param {*} context Context for mapFunction.
   * @return {object} Object containing the ordered map of results.
   */
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }

  function forEachSingleChildDummy(traverseContext, child, name) {
    return null;
  }

  /**
   * Count the number of children that are typically specified as
   * `props.children`.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
   *
   * @param {?*} children Children tree container.
   * @return {number} The number of children.
   */
  function countChildren(children, context) {
    return traverseAllChildren(children, forEachSingleChildDummy, null);
  }

  /**
   * Flatten a children object (typically specified as `props.children`) and
   * return an array with appropriately re-keyed children.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
   */
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }

  var ReactChildren = {
    forEach: forEachChildren,
    map: mapChildren,
    mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
    count: countChildren,
    toArray: toArray
  };

  module.exports = ReactChildren;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactPureComponent.js', ['object-assign', './ReactComponent', './ReactNoopUpdateQueue', 'fbjs/lib/emptyObject', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var ReactComponent = $__require('./ReactComponent');
  var ReactNoopUpdateQueue = $__require('./ReactNoopUpdateQueue');

  var emptyObject = $__require('fbjs/lib/emptyObject');

  /**
   * Base class helpers for the updating state of a component.
   */
  function ReactPureComponent(props, context, updater) {
    // Duplicated from ReactComponent.
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    // We initialize the default updater but the real one gets injected by the
    // renderer.
    this.updater = updater || ReactNoopUpdateQueue;
  }

  function ComponentDummy() {}
  ComponentDummy.prototype = ReactComponent.prototype;
  ReactPureComponent.prototype = new ComponentDummy();
  ReactPureComponent.prototype.constructor = ReactPureComponent;
  // Avoid an extra prototype jump for these methods.
  _assign(ReactPureComponent.prototype, ReactComponent.prototype);
  ReactPureComponent.prototype.isPureReactComponent = true;

  module.exports = ReactPureComponent;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactComponent.js', ['./reactProdInvariant', './ReactNoopUpdateQueue', './canDefineProperty', 'fbjs/lib/emptyObject', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactNoopUpdateQueue = $__require('./ReactNoopUpdateQueue');

  var canDefineProperty = $__require('./canDefineProperty');
  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  /**
   * Base class helpers for the updating state of a component.
   */
  function ReactComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    // We initialize the default updater but the real one gets injected by the
    // renderer.
    this.updater = updater || ReactNoopUpdateQueue;
  }

  ReactComponent.prototype.isReactComponent = {};

  /**
   * Sets a subset of the state. Always use this to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * When a function is provided to setState, it will be called at some point in
   * the future (not synchronously). It will be called with the up to date
   * component arguments (state, props, context). These values can be different
   * from this.* because your function may be called after receiveProps but before
   * shouldComponentUpdate, and this new state, props, and context will not yet be
   * assigned to this.
   *
   * @param {object|function} partialState Next partial state or function to
   *        produce next partial state to be merged with current state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  ReactComponent.prototype.setState = function (partialState, callback) {
    !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? 'production' !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
    this.updater.enqueueSetState(this, partialState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'setState');
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */
  ReactComponent.prototype.forceUpdate = function (callback) {
    this.updater.enqueueForceUpdate(this);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'forceUpdate');
    }
  };

  /**
   * Deprecated APIs. These APIs used to exist on classic React classes but since
   * we would like to deprecate them, we're not going to move them over to this
   * modern base class. Instead, we define a getter that warns if it's accessed.
   */
  if ('production' !== 'production') {
    var deprecatedAPIs = {
      isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
      replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
    };
    var defineDeprecationWarning = function (methodName, info) {
      if (canDefineProperty) {
        Object.defineProperty(ReactComponent.prototype, methodName, {
          get: function () {
            'production' !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
            return undefined;
          }
        });
      }
    };
    for (var fnName in deprecatedAPIs) {
      if (deprecatedAPIs.hasOwnProperty(fnName)) {
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
    }
  }

  module.exports = ReactComponent;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactNoopUpdateQueue.js', ['fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = $__require('fbjs/lib/warning');

  function warnNoop(publicInstance, callerName) {
    if ('production' !== 'production') {
      var constructor = publicInstance.constructor;
      'production' !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
    }
  }

  /**
   * This is the abstract API for an update queue.
   */
  var ReactNoopUpdateQueue = {

    /**
     * Checks whether or not this composite component is mounted.
     * @param {ReactClass} publicInstance The instance we want to test.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function (publicInstance) {
      return false;
    },

    /**
     * Enqueue a callback that will be executed after all the pending updates
     * have processed.
     *
     * @param {ReactClass} publicInstance The instance to use as `this` context.
     * @param {?function} callback Called after state is updated.
     * @internal
     */
    enqueueCallback: function (publicInstance, callback) {},

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @internal
     */
    enqueueForceUpdate: function (publicInstance) {
      warnNoop(publicInstance, 'forceUpdate');
    },

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} completeState Next state.
     * @internal
     */
    enqueueReplaceState: function (publicInstance, completeState) {
      warnNoop(publicInstance, 'replaceState');
    },

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} partialState Next partial state to be merged with state.
     * @internal
     */
    enqueueSetState: function (publicInstance, partialState) {
      warnNoop(publicInstance, 'setState');
    }
  };

  module.exports = ReactNoopUpdateQueue;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/emptyObject.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyObject = {};

  if ('production' !== 'production') {
    Object.freeze(emptyObject);
  }

  module.exports = emptyObject;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactClass.js', ['./reactProdInvariant', 'object-assign', './ReactComponent', './ReactElement', './ReactPropTypeLocationNames', './ReactNoopUpdateQueue', 'fbjs/lib/emptyObject', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant'),
      _assign = $__require('object-assign');

  var ReactComponent = $__require('./ReactComponent');
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var ReactNoopUpdateQueue = $__require('./ReactNoopUpdateQueue');

  var emptyObject = $__require('fbjs/lib/emptyObject');
  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var MIXINS_KEY = 'mixins';

  // Helper function to allow the creation of anonymous functions which do not
  // have .name set to the name of the variable being assigned to.
  function identity(fn) {
    return fn;
  }

  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {

    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @nosideeffects
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'

  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function (Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function (Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function (Constructor, childContextTypes) {
      if ('production' !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
    },
    contextTypes: function (Constructor, contextTypes) {
      if ('production' !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function (Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function (Constructor, propTypes) {
      if ('production' !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function (Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function () {} };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an invariant so components
        // don't show up in prod but only in __DEV__
        'production' !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      !(specPolicy === 'OVERRIDE_BASE') ? 'production' !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? 'production' !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if ('production' !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        'production' !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
      }

      return;
    }

    !(typeof spec !== 'function') ? 'production' !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
    !!ReactElement.isValidElement(spec) ? 'production' !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? 'production' !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if ('production' !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      !!isReserved ? 'production' !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

      var isInherited = name in Constructor;
      !!isInherited ? 'production' !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    !(one && two && typeof one === 'object' && typeof two === 'object') ? 'production' !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        !(one[key] === undefined) ? 'production' !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if ('production' !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function (newThis) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          'production' !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
        } else if (!args.length) {
          'production' !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {

    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function (newState, callback) {
      this.updater.enqueueReplaceState(this, newState);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'replaceState');
      }
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function () {
      return this.updater.isMounted(this);
    }
  };

  var ReactClassComponent = function () {};
  _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

  /**
   * Module for creating composite components.
   *
   * @class ReactClass
   */
  var ReactClass = {

    /**
     * Creates a composite component class given a class specification.
     * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
     *
     * @param {object} spec Class specification (which must define `render`).
     * @return {function} Component constructor function.
     * @public
     */
    createClass: function (spec) {
      // To keep our warnings more understandable, we'll use a little hack here to
      // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
      // unnecessarily identify a class without displayName as 'Constructor'.
      var Constructor = identity(function (props, context, updater) {
        // This constructor gets overridden by mocks. The argument is used
        // by mocks to assert on what gets mounted.

        if ('production' !== 'production') {
          'production' !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
        }

        // Wire up auto-binding
        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }

        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;

        this.state = null;

        // ReactClasses doesn't have constructors. Instead, they use the
        // getInitialState and componentWillMount methods for initialization.

        var initialState = this.getInitialState ? this.getInitialState() : null;
        if ('production' !== 'production') {
          // We allow auto-mocks to proceed as if they're returning null.
          if (initialState === undefined && this.getInitialState._isMockFunction) {
            // This is probably bad practice. Consider warning here and
            // deprecating this convenience.
            initialState = null;
          }
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

        this.state = initialState;
      });
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];

      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

      mixSpecIntoComponent(Constructor, spec);

      // Initialize the defaultProps property after all mixins have been merged.
      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }

      if ('production' !== 'production') {
        // This is a tag to indicate that the use of these method names is ok,
        // since it's used with createClass. If it's not, then it's likely a
        // mistake so we'll warn you to use the static property, property
        // initializer or constructor respectively.
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps.isReactClassApproved = {};
        }
        if (Constructor.prototype.getInitialState) {
          Constructor.prototype.getInitialState.isReactClassApproved = {};
        }
      }

      !Constructor.prototype.render ? 'production' !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

      if ('production' !== 'production') {
        'production' !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
        'production' !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
      }

      // Reduce time spent doing lookups by setting these on the prototype.
      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }

      return Constructor;
    },

    injection: {
      injectMixin: function (mixin) {
        injectedMixins.push(mixin);
      }
    }

  };

  module.exports = ReactClass;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactDOMFactories.js', ['./ReactElement', './ReactElementValidator', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactElement = $__require('./ReactElement');

  /**
   * Create a factory that creates HTML tag elements.
   *
   * @private
   */
  var createDOMFactory = ReactElement.createFactory;
  if ('production' !== 'production') {
    var ReactElementValidator = $__require('./ReactElementValidator');
    createDOMFactory = ReactElementValidator.createFactory;
  }

  /**
   * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
   * This is also accessible via `React.DOM`.
   *
   * @public
   */
  var ReactDOMFactories = {
    a: createDOMFactory('a'),
    abbr: createDOMFactory('abbr'),
    address: createDOMFactory('address'),
    area: createDOMFactory('area'),
    article: createDOMFactory('article'),
    aside: createDOMFactory('aside'),
    audio: createDOMFactory('audio'),
    b: createDOMFactory('b'),
    base: createDOMFactory('base'),
    bdi: createDOMFactory('bdi'),
    bdo: createDOMFactory('bdo'),
    big: createDOMFactory('big'),
    blockquote: createDOMFactory('blockquote'),
    body: createDOMFactory('body'),
    br: createDOMFactory('br'),
    button: createDOMFactory('button'),
    canvas: createDOMFactory('canvas'),
    caption: createDOMFactory('caption'),
    cite: createDOMFactory('cite'),
    code: createDOMFactory('code'),
    col: createDOMFactory('col'),
    colgroup: createDOMFactory('colgroup'),
    data: createDOMFactory('data'),
    datalist: createDOMFactory('datalist'),
    dd: createDOMFactory('dd'),
    del: createDOMFactory('del'),
    details: createDOMFactory('details'),
    dfn: createDOMFactory('dfn'),
    dialog: createDOMFactory('dialog'),
    div: createDOMFactory('div'),
    dl: createDOMFactory('dl'),
    dt: createDOMFactory('dt'),
    em: createDOMFactory('em'),
    embed: createDOMFactory('embed'),
    fieldset: createDOMFactory('fieldset'),
    figcaption: createDOMFactory('figcaption'),
    figure: createDOMFactory('figure'),
    footer: createDOMFactory('footer'),
    form: createDOMFactory('form'),
    h1: createDOMFactory('h1'),
    h2: createDOMFactory('h2'),
    h3: createDOMFactory('h3'),
    h4: createDOMFactory('h4'),
    h5: createDOMFactory('h5'),
    h6: createDOMFactory('h6'),
    head: createDOMFactory('head'),
    header: createDOMFactory('header'),
    hgroup: createDOMFactory('hgroup'),
    hr: createDOMFactory('hr'),
    html: createDOMFactory('html'),
    i: createDOMFactory('i'),
    iframe: createDOMFactory('iframe'),
    img: createDOMFactory('img'),
    input: createDOMFactory('input'),
    ins: createDOMFactory('ins'),
    kbd: createDOMFactory('kbd'),
    keygen: createDOMFactory('keygen'),
    label: createDOMFactory('label'),
    legend: createDOMFactory('legend'),
    li: createDOMFactory('li'),
    link: createDOMFactory('link'),
    main: createDOMFactory('main'),
    map: createDOMFactory('map'),
    mark: createDOMFactory('mark'),
    menu: createDOMFactory('menu'),
    menuitem: createDOMFactory('menuitem'),
    meta: createDOMFactory('meta'),
    meter: createDOMFactory('meter'),
    nav: createDOMFactory('nav'),
    noscript: createDOMFactory('noscript'),
    object: createDOMFactory('object'),
    ol: createDOMFactory('ol'),
    optgroup: createDOMFactory('optgroup'),
    option: createDOMFactory('option'),
    output: createDOMFactory('output'),
    p: createDOMFactory('p'),
    param: createDOMFactory('param'),
    picture: createDOMFactory('picture'),
    pre: createDOMFactory('pre'),
    progress: createDOMFactory('progress'),
    q: createDOMFactory('q'),
    rp: createDOMFactory('rp'),
    rt: createDOMFactory('rt'),
    ruby: createDOMFactory('ruby'),
    s: createDOMFactory('s'),
    samp: createDOMFactory('samp'),
    script: createDOMFactory('script'),
    section: createDOMFactory('section'),
    select: createDOMFactory('select'),
    small: createDOMFactory('small'),
    source: createDOMFactory('source'),
    span: createDOMFactory('span'),
    strong: createDOMFactory('strong'),
    style: createDOMFactory('style'),
    sub: createDOMFactory('sub'),
    summary: createDOMFactory('summary'),
    sup: createDOMFactory('sup'),
    table: createDOMFactory('table'),
    tbody: createDOMFactory('tbody'),
    td: createDOMFactory('td'),
    textarea: createDOMFactory('textarea'),
    tfoot: createDOMFactory('tfoot'),
    th: createDOMFactory('th'),
    thead: createDOMFactory('thead'),
    time: createDOMFactory('time'),
    title: createDOMFactory('title'),
    tr: createDOMFactory('tr'),
    track: createDOMFactory('track'),
    u: createDOMFactory('u'),
    ul: createDOMFactory('ul'),
    'var': createDOMFactory('var'),
    video: createDOMFactory('video'),
    wbr: createDOMFactory('wbr'),

    // SVG
    circle: createDOMFactory('circle'),
    clipPath: createDOMFactory('clipPath'),
    defs: createDOMFactory('defs'),
    ellipse: createDOMFactory('ellipse'),
    g: createDOMFactory('g'),
    image: createDOMFactory('image'),
    line: createDOMFactory('line'),
    linearGradient: createDOMFactory('linearGradient'),
    mask: createDOMFactory('mask'),
    path: createDOMFactory('path'),
    pattern: createDOMFactory('pattern'),
    polygon: createDOMFactory('polygon'),
    polyline: createDOMFactory('polyline'),
    radialGradient: createDOMFactory('radialGradient'),
    rect: createDOMFactory('rect'),
    stop: createDOMFactory('stop'),
    svg: createDOMFactory('svg'),
    text: createDOMFactory('text'),
    tspan: createDOMFactory('tspan')
  };

  module.exports = ReactDOMFactories;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactPropTypes.js', ['./ReactElement', './ReactPropTypeLocationNames', './ReactPropTypesSecret', 'fbjs/lib/emptyFunction', './getIteratorFn', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var ReactPropTypesSecret = $__require('./ReactPropTypesSecret');

  var emptyFunction = $__require('fbjs/lib/emptyFunction');
  var getIteratorFn = $__require('./getIteratorFn');
  var warning = $__require('fbjs/lib/warning');

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ('production' !== 'production') {
      var manualPropTypeCallCache = {};
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;
      if ('production' !== 'production') {
        if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey]) {
            'production' !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
            manualPropTypeCallCache[cacheKey] = true;
          }
        }
      }
      if (props[propName] == null) {
        var locationName = ReactPropTypeLocationNames[location];
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        var locationName = ReactPropTypeLocationNames[location];
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturns(null));
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactElement.isValidElement(propValue)) {
        var locationName = ReactPropTypeLocationNames[location];
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var locationName = ReactPropTypeLocationNames[location];
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var locationName = ReactPropTypeLocationNames[location];
      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        var locationName = ReactPropTypeLocationNames[location];
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        var locationName = ReactPropTypeLocationNames[location];
        return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || ReactElement.isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  module.exports = ReactPropTypes;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactVersion.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = '15.4.1';
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/onlyChild.js', ['./reactProdInvariant', './ReactElement', 'fbjs/lib/invariant', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactElement = $__require('./ReactElement');

  var invariant = $__require('fbjs/lib/invariant');

  /**
   * Returns the first child in a collection of children and verifies that there
   * is only one child in the collection.
   *
   * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
   *
   * The current implementation of this function assumes that a single child gets
   * passed without a wrapper, but the purpose of this helper function is to
   * abstract away the particular structure of children.
   *
   * @param {?object} children Child collection structure.
   * @return {ReactElement} The first and only `ReactElement` contained in the
   * structure.
   */
  function onlyChild(children) {
    !ReactElement.isValidElement(children) ? 'production' !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
    return children;
  }

  module.exports = onlyChild;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactElementSymbol.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactElement.js', ['object-assign', './ReactCurrentOwner', 'fbjs/lib/warning', './canDefineProperty', './ReactElementSymbol', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var ReactCurrentOwner = $__require('./ReactCurrentOwner');

  var warning = $__require('fbjs/lib/warning');
  var canDefineProperty = $__require('./canDefineProperty');
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var REACT_ELEMENT_TYPE = $__require('./ReactElementSymbol');

  var RESERVED_PROPS = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };

  var specialPropKeyWarningShown, specialPropRefWarningShown;

  function hasValidRef(config) {
    if ('production' !== 'production') {
      if (hasOwnProperty.call(config, 'ref')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.ref !== undefined;
  }

  function hasValidKey(config) {
    if ('production' !== 'production') {
      if (hasOwnProperty.call(config, 'key')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.key !== undefined;
  }

  function defineKeyPropWarningGetter(props, displayName) {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;
        'production' !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
      }
    };
    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }

  function defineRefPropWarningGetter(props, displayName) {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;
        'production' !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
      }
    };
    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }

  /**
   * Factory method to create a new React element. This no longer adheres to
   * the class pattern, so do not use new to call it. Also, no instanceof check
   * will work. Instead test $$typeof field against Symbol.for('react.element') to check
   * if something is a React Element.
   *
   * @param {*} type
   * @param {*} key
   * @param {string|object} ref
   * @param {*} self A *temporary* helper to detect places where `this` is
   * different from the `owner` when React.createElement is called, so that we
   * can warn. We want to get rid of owner and replace string `ref`s with arrow
   * functions, and as long as `this` and owner are the same, there will be no
   * change in behavior.
   * @param {*} source An annotation object (added by a transpiler or otherwise)
   * indicating filename, line number, and/or other information.
   * @param {*} owner
   * @param {*} props
   * @internal
   */
  var ReactElement = function (type, key, ref, self, source, owner, props) {
    var element = {
      // This tag allow us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,

      // Built-in properties that belong on the element
      type: type,
      key: key,
      ref: ref,
      props: props,

      // Record the component responsible for creating this element.
      _owner: owner
    };

    if ('production' !== 'production') {
      // The validation flag is currently mutative. We put it on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      element._store = {};

      // To make comparing ReactElements easier for testing purposes, we make
      // the validation flag non-enumerable (where possible, which should
      // include every environment we run tests in), so the test framework
      // ignores it.
      if (canDefineProperty) {
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
      } else {
        element._store.validated = false;
        element._self = self;
        element._source = source;
      }
      if (Object.freeze) {
        Object.freeze(element.props);
        Object.freeze(element);
      }
    }

    return element;
  };

  /**
   * Create and return a new ReactElement of the given type.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
   */
  ReactElement.createElement = function (type, config, children) {
    var propName;

    // Reserved names are extracted
    var props = {};

    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) {
      if (hasValidRef(config)) {
        ref = config.ref;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source;
      // Remaining properties are added to a new props object
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      if ('production' !== 'production') {
        if (Object.freeze) {
          Object.freeze(childArray);
        }
      }
      props.children = childArray;
    }

    // Resolve default props
    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;
      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }
    if ('production' !== 'production') {
      if (key || ref) {
        if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
    }
    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  };

  /**
   * Return a function that produces ReactElements of a given type.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
   */
  ReactElement.createFactory = function (type) {
    var factory = ReactElement.createElement.bind(null, type);
    // Expose the type on the factory and the prototype so that it can be
    // easily accessed on elements. E.g. `<Foo />.type === Foo`.
    // This should not be named `constructor` since this may not be the function
    // that created the element, and it may not even be a constructor.
    // Legacy hook TODO: Warn if this is accessed
    factory.type = type;
    return factory;
  };

  ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

    return newElement;
  };

  /**
   * Clone and return a new ReactElement using element as the starting point.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
   */
  ReactElement.cloneElement = function (element, config, children) {
    var propName;

    // Original props are copied
    var props = _assign({}, element.props);

    // Reserved names are extracted
    var key = element.key;
    var ref = element.ref;
    // Self is preserved since the owner is preserved.
    var self = element._self;
    // Source is preserved since cloneElement is unlikely to be targeted by a
    // transpiler, and the original source is probably a better indicator of the
    // true owner.
    var source = element._source;

    // Owner will be preserved, unless ref is overridden
    var owner = element._owner;

    if (config != null) {
      if (hasValidRef(config)) {
        // Silently steal the ref from the parent.
        ref = config.ref;
        owner = ReactCurrentOwner.current;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      // Remaining properties override existing props
      var defaultProps;
      if (element.type && element.type.defaultProps) {
        defaultProps = element.type.defaultProps;
      }
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          if (config[propName] === undefined && defaultProps !== undefined) {
            // Resolve default props
            props[propName] = defaultProps[propName];
          } else {
            props[propName] = config[propName];
          }
        }
      }
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      props.children = childArray;
    }

    return ReactElement(element.type, key, ref, self, source, owner, props);
  };

  /**
   * Verifies the object is a ReactElement.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
   * @param {?object} object
   * @return {boolean} True if `object` is a valid component.
   * @final
   */
  ReactElement.isValidElement = function (object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  module.exports = ReactElement;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactPropTypeLocationNames.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypeLocationNames = {};

  if ('production' !== 'production') {
    ReactPropTypeLocationNames = {
      prop: 'prop',
      context: 'context',
      childContext: 'child context'
    };
  }

  module.exports = ReactPropTypeLocationNames;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactPropTypesSecret.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/reactProdInvariant.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactCurrentOwner.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = {

    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null

  };

  module.exports = ReactCurrentOwner;
  return module.exports;
});
System.registerDynamic('npm:fbjs@0.8.6/lib/invariant.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  function invariant(condition, format, a, b, c, d, e, f) {
    if ('production' !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  }

  module.exports = invariant;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactComponentTreeHook.js', ['./reactProdInvariant', './ReactCurrentOwner', 'fbjs/lib/invariant', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactCurrentOwner = $__require('./ReactCurrentOwner');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  function isNative(fn) {
    // Based on isNative() from Lodash
    var funcToString = Function.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var reIsNative = RegExp('^' + funcToString
    // Take an example native function source for comparison
    .call(hasOwnProperty)
    // Strip regex characters so we can use it for regex
    .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
    // Remove hasOwnProperty from the template to make it generic
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    try {
      var source = funcToString.call(fn);
      return reIsNative.test(source);
    } catch (err) {
      return false;
    }
  }

  var canUseCollections =
  // Array.from
  typeof Array.from === 'function' &&
  // Map
  typeof Map === 'function' && isNative(Map) &&
  // Map.prototype.keys
  Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
  // Set
  typeof Set === 'function' && isNative(Set) &&
  // Set.prototype.keys
  Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

  var setItem;
  var getItem;
  var removeItem;
  var getItemIDs;
  var addRoot;
  var removeRoot;
  var getRootIDs;

  if (canUseCollections) {
    var itemMap = new Map();
    var rootIDSet = new Set();

    setItem = function (id, item) {
      itemMap.set(id, item);
    };
    getItem = function (id) {
      return itemMap.get(id);
    };
    removeItem = function (id) {
      itemMap['delete'](id);
    };
    getItemIDs = function () {
      return Array.from(itemMap.keys());
    };

    addRoot = function (id) {
      rootIDSet.add(id);
    };
    removeRoot = function (id) {
      rootIDSet['delete'](id);
    };
    getRootIDs = function () {
      return Array.from(rootIDSet.keys());
    };
  } else {
    var itemByKey = {};
    var rootByKey = {};

    // Use non-numeric keys to prevent V8 performance issues:
    // https://github.com/facebook/react/pull/7232
    var getKeyFromID = function (id) {
      return '.' + id;
    };
    var getIDFromKey = function (key) {
      return parseInt(key.substr(1), 10);
    };

    setItem = function (id, item) {
      var key = getKeyFromID(id);
      itemByKey[key] = item;
    };
    getItem = function (id) {
      var key = getKeyFromID(id);
      return itemByKey[key];
    };
    removeItem = function (id) {
      var key = getKeyFromID(id);
      delete itemByKey[key];
    };
    getItemIDs = function () {
      return Object.keys(itemByKey).map(getIDFromKey);
    };

    addRoot = function (id) {
      var key = getKeyFromID(id);
      rootByKey[key] = true;
    };
    removeRoot = function (id) {
      var key = getKeyFromID(id);
      delete rootByKey[key];
    };
    getRootIDs = function () {
      return Object.keys(rootByKey).map(getIDFromKey);
    };
  }

  var unmountedIDs = [];

  function purgeDeep(id) {
    var item = getItem(id);
    if (item) {
      var childIDs = item.childIDs;

      removeItem(id);
      childIDs.forEach(purgeDeep);
    }
  }

  function describeComponentFrame(name, source, ownerName) {
    return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
  }

  function getDisplayName(element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  }

  function describeID(id) {
    var name = ReactComponentTreeHook.getDisplayName(id);
    var element = ReactComponentTreeHook.getElement(id);
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var ownerName;
    if (ownerID) {
      ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
    }
    'production' !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
    return describeComponentFrame(name, element && element._source, ownerName);
  }

  var ReactComponentTreeHook = {
    onSetChildren: function (id, nextChildIDs) {
      var item = getItem(id);
      !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
      item.childIDs = nextChildIDs;

      for (var i = 0; i < nextChildIDs.length; i++) {
        var nextChildID = nextChildIDs[i];
        var nextChild = getItem(nextChildID);
        !nextChild ? 'production' !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
        !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? 'production' !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
        !nextChild.isMounted ? 'production' !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
        if (nextChild.parentID == null) {
          nextChild.parentID = id;
          // TODO: This shouldn't be necessary but mounting a new root during in
          // componentWillMount currently causes not-yet-mounted components to
          // be purged from our tree data so their parent id is missing.
        }
        !(nextChild.parentID === id) ? 'production' !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
      }
    },
    onBeforeMountComponent: function (id, element, parentID) {
      var item = {
        element: element,
        parentID: parentID,
        text: null,
        childIDs: [],
        isMounted: false,
        updateCount: 0
      };
      setItem(id, item);
    },
    onBeforeUpdateComponent: function (id, element) {
      var item = getItem(id);
      if (!item || !item.isMounted) {
        // We may end up here as a result of setState() in componentWillUnmount().
        // In this case, ignore the element.
        return;
      }
      item.element = element;
    },
    onMountComponent: function (id) {
      var item = getItem(id);
      !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
      item.isMounted = true;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        addRoot(id);
      }
    },
    onUpdateComponent: function (id) {
      var item = getItem(id);
      if (!item || !item.isMounted) {
        // We may end up here as a result of setState() in componentWillUnmount().
        // In this case, ignore the element.
        return;
      }
      item.updateCount++;
    },
    onUnmountComponent: function (id) {
      var item = getItem(id);
      if (item) {
        // We need to check if it exists.
        // `item` might not exist if it is inside an error boundary, and a sibling
        // error boundary child threw while mounting. Then this instance never
        // got a chance to mount, but it still gets an unmounting event during
        // the error boundary cleanup.
        item.isMounted = false;
        var isRoot = item.parentID === 0;
        if (isRoot) {
          removeRoot(id);
        }
      }
      unmountedIDs.push(id);
    },
    purgeUnmountedComponents: function () {
      if (ReactComponentTreeHook._preventPurging) {
        // Should only be used for testing.
        return;
      }

      for (var i = 0; i < unmountedIDs.length; i++) {
        var id = unmountedIDs[i];
        purgeDeep(id);
      }
      unmountedIDs.length = 0;
    },
    isMounted: function (id) {
      var item = getItem(id);
      return item ? item.isMounted : false;
    },
    getCurrentStackAddendum: function (topElement) {
      var info = '';
      if (topElement) {
        var name = getDisplayName(topElement);
        var owner = topElement._owner;
        info += describeComponentFrame(name, topElement._source, owner && owner.getName());
      }

      var currentOwner = ReactCurrentOwner.current;
      var id = currentOwner && currentOwner._debugID;

      info += ReactComponentTreeHook.getStackAddendumByID(id);
      return info;
    },
    getStackAddendumByID: function (id) {
      var info = '';
      while (id) {
        info += describeID(id);
        id = ReactComponentTreeHook.getParentID(id);
      }
      return info;
    },
    getChildIDs: function (id) {
      var item = getItem(id);
      return item ? item.childIDs : [];
    },
    getDisplayName: function (id) {
      var element = ReactComponentTreeHook.getElement(id);
      if (!element) {
        return null;
      }
      return getDisplayName(element);
    },
    getElement: function (id) {
      var item = getItem(id);
      return item ? item.element : null;
    },
    getOwnerID: function (id) {
      var element = ReactComponentTreeHook.getElement(id);
      if (!element || !element._owner) {
        return null;
      }
      return element._owner._debugID;
    },
    getParentID: function (id) {
      var item = getItem(id);
      return item ? item.parentID : null;
    },
    getSource: function (id) {
      var item = getItem(id);
      var element = item ? item.element : null;
      var source = element != null ? element._source : null;
      return source;
    },
    getText: function (id) {
      var element = ReactComponentTreeHook.getElement(id);
      if (typeof element === 'string') {
        return element;
      } else if (typeof element === 'number') {
        return '' + element;
      } else {
        return null;
      }
    },
    getUpdateCount: function (id) {
      var item = getItem(id);
      return item ? item.updateCount : 0;
    },

    getRootIDs: getRootIDs,
    getRegisteredIDs: getItemIDs
  };

  module.exports = ReactComponentTreeHook;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/checkReactTypeSpec.js', ['./reactProdInvariant', './ReactPropTypeLocationNames', './ReactPropTypesSecret', 'fbjs/lib/invariant', 'fbjs/lib/warning', './ReactComponentTreeHook', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _prodInvariant = $__require('./reactProdInvariant');

  var ReactPropTypeLocationNames = $__require('./ReactPropTypeLocationNames');
  var ReactPropTypesSecret = $__require('./ReactPropTypesSecret');

  var invariant = $__require('fbjs/lib/invariant');
  var warning = $__require('fbjs/lib/warning');

  var ReactComponentTreeHook;

  if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
    // Temporary hack.
    // Inline requires don't work well with Jest:
    // https://github.com/facebook/react/issues/7240
    // Remove the inline requires when we don't need them anymore:
    // https://github.com/facebook/react/pull/7178
    ReactComponentTreeHook = $__require('./ReactComponentTreeHook');
  }

  var loggedTypeFailures = {};

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?object} element The React element that is being type-checked
   * @param {?number} debugID The React component instance that is being type-checked
   * @private
   */
  function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var componentStackInfo = '';

          if ('production' !== 'production') {
            if (!ReactComponentTreeHook) {
              ReactComponentTreeHook = $__require('./ReactComponentTreeHook');
            }
            if (debugID !== null) {
              componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
            } else if (element !== null) {
              componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
            }
          }

          'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
        }
      }
    }
  }

  module.exports = checkReactTypeSpec;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/canDefineProperty.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var canDefineProperty = false;
  if ('production' !== 'production') {
    try {
      // $FlowFixMe https://github.com/facebook/flow/issues/285
      Object.defineProperty({}, 'x', { get: function () {} });
      canDefineProperty = true;
    } catch (x) {
      // IE will fail on defineProperty
    }
  }

  module.exports = canDefineProperty;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/getIteratorFn.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
  return module.exports;
});
System.registerDynamic("npm:fbjs@0.8.6/lib/emptyFunction.js", ["process"], true, function ($__require, exports, module) {
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
  return module.exports;
});
System.registerDynamic("npm:fbjs@0.8.6.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:fbjs@0.8.6/lib/warning.js', ['./emptyFunction', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var emptyFunction = $__require('./emptyFunction');

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var warning = emptyFunction;

  if ('production' !== 'production') {
    (function () {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      warning = function warning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (format.indexOf('Failed Composite propType: ') === 0) {
          return; // Ignore CompositeComponent proptype check.
        }

        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    })();
  }

  module.exports = warning;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/ReactElementValidator.js', ['./ReactCurrentOwner', './ReactComponentTreeHook', './ReactElement', './checkReactTypeSpec', './canDefineProperty', './getIteratorFn', 'fbjs/lib/warning', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /**
   * ReactElementValidator provides a wrapper around a element factory
   * which validates the props passed to the element. This is intended to be
   * used only in DEV and could be replaced by a static type checker for languages
   * that support it.
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = $__require('./ReactCurrentOwner');
  var ReactComponentTreeHook = $__require('./ReactComponentTreeHook');
  var ReactElement = $__require('./ReactElement');

  var checkReactTypeSpec = $__require('./checkReactTypeSpec');

  var canDefineProperty = $__require('./canDefineProperty');
  var getIteratorFn = $__require('./getIteratorFn');
  var warning = $__require('fbjs/lib/warning');

  function getDeclarationErrorAddendum() {
    if (ReactCurrentOwner.current) {
      var name = ReactCurrentOwner.current.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  }

  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};

  function getCurrentComponentErrorInfo(parentType) {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
      if (parentName) {
        info = ' Check the top-level render call using <' + parentName + '>.';
      }
    }
    return info;
  }

  /**
   * Warn if the element doesn't have an explicit key assigned to it.
   * This element is in an array. The array could grow and shrink or be
   * reordered. All children that haven't already been validated are required to
   * have a "key" property assigned to it. Error statuses are cached so a warning
   * will only be shown once.
   *
   * @internal
   * @param {ReactElement} element Element that requires a key.
   * @param {*} parentType element's parent's type.
   */
  function validateExplicitKey(element, parentType) {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }
    element._store.validated = true;

    var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
    if (memoizer[currentComponentErrorInfo]) {
      return;
    }
    memoizer[currentComponentErrorInfo] = true;

    // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.
    var childOwner = '';
    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
      // Give the component that originally created this child.
      childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
    }

    'production' !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
  }

  /**
   * Ensure that every element either is passed in a static location, in an
   * array with an explicit keys property defined, or in an object literal
   * with valid key property.
   *
   * @internal
   * @param {ReactNode} node Statically passed child of any type.
   * @param {*} parentType node's parent's type.
   */
  function validateChildKeys(node, parentType) {
    if (typeof node !== 'object') {
      return;
    }
    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];
        if (ReactElement.isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (ReactElement.isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);
      // Entry iterators provide implicit keys.
      if (iteratorFn) {
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;
          while (!(step = iterator.next()).done) {
            if (ReactElement.isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }

  /**
   * Given an element, validate that its props follow the propTypes definition,
   * provided by the type.
   *
   * @param {ReactElement} element
   */
  function validatePropTypes(element) {
    var componentClass = element.type;
    if (typeof componentClass !== 'function') {
      return;
    }
    var name = componentClass.displayName || componentClass.name;
    if (componentClass.propTypes) {
      checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
    }
    if (typeof componentClass.getDefaultProps === 'function') {
      'production' !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
    }
  }

  var ReactElementValidator = {

    createElement: function (type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        'production' !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
      }

      var element = ReactElement.createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      validatePropTypes(element);

      return element;
    },

    createFactory: function (type) {
      var validatedFactory = ReactElementValidator.createElement.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      if ('production' !== 'production') {
        if (canDefineProperty) {
          Object.defineProperty(validatedFactory, 'type', {
            enumerable: false,
            get: function () {
              'production' !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
              Object.defineProperty(this, 'type', {
                value: type
              });
              return type;
            }
          });
        }
      }

      return validatedFactory;
    },

    cloneElement: function (element, props, children) {
      var newElement = ReactElement.cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

  };

  module.exports = ReactElementValidator;
  return module.exports;
});
System.registerDynamic('npm:react@15.4.1/lib/React.js', ['object-assign', './ReactChildren', './ReactComponent', './ReactPureComponent', './ReactClass', './ReactDOMFactories', './ReactElement', './ReactPropTypes', './ReactVersion', './onlyChild', 'fbjs/lib/warning', './ReactElementValidator', 'process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var _assign = $__require('object-assign');

  var ReactChildren = $__require('./ReactChildren');
  var ReactComponent = $__require('./ReactComponent');
  var ReactPureComponent = $__require('./ReactPureComponent');
  var ReactClass = $__require('./ReactClass');
  var ReactDOMFactories = $__require('./ReactDOMFactories');
  var ReactElement = $__require('./ReactElement');
  var ReactPropTypes = $__require('./ReactPropTypes');
  var ReactVersion = $__require('./ReactVersion');

  var onlyChild = $__require('./onlyChild');
  var warning = $__require('fbjs/lib/warning');

  var createElement = ReactElement.createElement;
  var createFactory = ReactElement.createFactory;
  var cloneElement = ReactElement.cloneElement;

  if ('production' !== 'production') {
    var ReactElementValidator = $__require('./ReactElementValidator');
    createElement = ReactElementValidator.createElement;
    createFactory = ReactElementValidator.createFactory;
    cloneElement = ReactElementValidator.cloneElement;
  }

  var __spread = _assign;

  if ('production' !== 'production') {
    var warned = false;
    __spread = function () {
      'production' !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
      warned = true;
      return _assign.apply(null, arguments);
    };
  }

  var React = {

    // Modern

    Children: {
      map: ReactChildren.map,
      forEach: ReactChildren.forEach,
      count: ReactChildren.count,
      toArray: ReactChildren.toArray,
      only: onlyChild
    },

    Component: ReactComponent,
    PureComponent: ReactPureComponent,

    createElement: createElement,
    cloneElement: cloneElement,
    isValidElement: ReactElement.isValidElement,

    // Classic

    PropTypes: ReactPropTypes,
    createClass: ReactClass.createClass,
    createFactory: createFactory,
    createMixin: function (mixin) {
      // Currently a noop. Will be used to validate and trace mixins.
      return mixin;
    },

    // This looks DOM specific but these are actually isomorphic helpers
    // since they are just generating DOM strings.
    DOM: ReactDOMFactories,

    version: ReactVersion,

    // Deprecated hook for JSX spread, don't use this for anything.
    __spread: __spread
  };

  module.exports = React;
  return module.exports;
});
System.registerDynamic("npm:react@15.4.1.json", [], false, function() {
  return {
    "main": "react.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "dist/react-with-addons.js": {
        "cjsRequireDetection": false
      },
      "dist/react.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic('npm:react@15.4.1/react.js', ['./lib/React', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  module.exports = $__require('./lib/React');
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/RouteUtils.js', ['react', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.isReactChildren = isReactChildren;
  exports.createRouteFromReactElement = createRouteFromReactElement;
  exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
  exports.createRoutes = createRoutes;

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function isValidChild(object) {
    return object == null || _react2.default.isValidElement(object);
  }

  function isReactChildren(object) {
    return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
  }

  function createRoute(defaultProps, props) {
    return _extends({}, defaultProps, props);
  }

  function createRouteFromReactElement(element) {
    var type = element.type;
    var route = createRoute(type.defaultProps, element.props);

    if (route.children) {
      var childRoutes = createRoutesFromReactChildren(route.children, route);

      if (childRoutes.length) route.childRoutes = childRoutes;

      delete route.children;
    }

    return route;
  }

  /**
   * Creates and returns a routes object from the given ReactChildren. JSX
   * provides a convenient way to visualize how routes in the hierarchy are
   * nested.
   *
   *   import { Route, createRoutesFromReactChildren } from 'react-router'
   *
   *   const routes = createRoutesFromReactChildren(
   *     <Route component={App}>
   *       <Route path="home" component={Dashboard}/>
   *       <Route path="news" component={NewsFeed}/>
   *     </Route>
   *   )
   *
   * Note: This method is automatically used when you provide <Route> children
   * to a <Router> component.
   */
  function createRoutesFromReactChildren(children, parentRoute) {
    var routes = [];

    _react2.default.Children.forEach(children, function (element) {
      if (_react2.default.isValidElement(element)) {
        // Component classes may have a static create* method.
        if (element.type.createRouteFromReactElement) {
          var route = element.type.createRouteFromReactElement(element, parentRoute);

          if (route) routes.push(route);
        } else {
          routes.push(createRouteFromReactElement(element));
        }
      }
    });

    return routes;
  }

  /**
   * Creates and returns an array of routes from the given object which
   * may be a JSX route, a plain object route, or an array of either.
   */
  function createRoutes(routes) {
    if (isReactChildren(routes)) {
      routes = createRoutesFromReactChildren(routes);
    } else if (routes && !Array.isArray(routes)) {
      routes = [routes];
    }

    return routes;
  }
  return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0/lib/RouterContext.js", ["invariant", "react", "./getRouteParams", "./ContextUtils", "./RouteUtils", "process"], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _invariant = $__require("invariant");

  var _invariant2 = _interopRequireDefault(_invariant);

  var _react = $__require("react");

  var _react2 = _interopRequireDefault(_react);

  var _getRouteParams = $__require("./getRouteParams");

  var _getRouteParams2 = _interopRequireDefault(_getRouteParams);

  var _ContextUtils = $__require("./ContextUtils");

  var _RouteUtils = $__require("./RouteUtils");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var _React$PropTypes = _react2.default.PropTypes,
      array = _React$PropTypes.array,
      func = _React$PropTypes.func,
      object = _React$PropTypes.object;

  /**
   * A <RouterContext> renders the component tree for a given router state
   * and sets the history object and the current location in context.
   */

  var RouterContext = _react2.default.createClass({
    displayName: 'RouterContext',

    mixins: [(0, _ContextUtils.ContextProvider)('router')],

    propTypes: {
      router: object.isRequired,
      location: object.isRequired,
      routes: array.isRequired,
      params: object.isRequired,
      components: array.isRequired,
      createElement: func.isRequired
    },

    getDefaultProps: function getDefaultProps() {
      return {
        createElement: _react2.default.createElement
      };
    },

    childContextTypes: {
      router: object.isRequired
    },

    getChildContext: function getChildContext() {
      return {
        router: this.props.router
      };
    },
    createElement: function createElement(component, props) {
      return component == null ? null : this.props.createElement(component, props);
    },
    render: function render() {
      var _this = this;

      var _props = this.props,
          location = _props.location,
          routes = _props.routes,
          params = _props.params,
          components = _props.components,
          router = _props.router;

      var element = null;

      if (components) {
        element = components.reduceRight(function (element, components, index) {
          if (components == null) return element; // Don't create new children; use the grandchildren.

          var route = routes[index];
          var routeParams = (0, _getRouteParams2.default)(route, params);
          var props = {
            location: location,
            params: params,
            route: route,
            router: router,
            routeParams: routeParams,
            routes: routes
          };

          if ((0, _RouteUtils.isReactChildren)(element)) {
            props.children = element;
          } else if (element) {
            for (var prop in element) {
              if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
            }
          }

          if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
            var elements = {};

            for (var key in components) {
              if (Object.prototype.hasOwnProperty.call(components, key)) {
                // Pass through the key as a prop to createElement to allow
                // custom createElement functions to know which named component
                // they're rendering, for e.g. matching up to fetched data.
                elements[key] = _this.createElement(components[key], _extends({
                  key: key }, props));
              }
            }

            return elements;
          }

          return _this.createElement(components, props);
        }, element);
      }

      !(element === null || element === false || _react2.default.isValidElement(element)) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;

      return element;
    }
  });

  exports.default = RouterContext;
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/routerWarning.js', ['warning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.default = routerWarning;
  exports._resetWarned = _resetWarned;

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var warned = {};

  function routerWarning(falseToWarn, message) {
    // Only issue deprecation warnings once.
    if (message.indexOf('deprecated') !== -1) {
      if (warned[message]) {
        return;
      }

      warned[message] = true;
    }

    message = '[react-router] ' + message;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
  }

  function _resetWarned() {
    warned = {};
  }
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/applyRouterMiddleware.js', ['react', './RouterContext', './routerWarning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _react = $__require('react');

  var _react2 = _interopRequireDefault(_react);

  var _RouterContext = $__require('./RouterContext');

  var _RouterContext2 = _interopRequireDefault(_RouterContext);

  var _routerWarning = $__require('./routerWarning');

  var _routerWarning2 = _interopRequireDefault(_routerWarning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  exports.default = function () {
    for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    if ('production' !== 'production') {
      middlewares.forEach(function (middleware, index) {
        'production' !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
      });
    }

    var withContext = middlewares.map(function (middleware) {
      return middleware.renderRouterContext;
    }).filter(Boolean);
    var withComponent = middlewares.map(function (middleware) {
      return middleware.renderRouteComponent;
    }).filter(Boolean);

    var makeCreateElement = function makeCreateElement() {
      var baseCreateElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _react.createElement;
      return function (Component, props) {
        return withComponent.reduceRight(function (previous, renderRouteComponent) {
          return renderRouteComponent(previous, props);
        }, baseCreateElement(Component, props));
      };
    };

    return function (renderProps) {
      return withContext.reduceRight(function (previous, renderRouterContext) {
        return renderRouterContext(previous, renderProps);
      }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
        createElement: makeCreateElement(renderProps.createElement)
      })));
    };
  };

  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/RefreshProtocol.js', ['./BrowserProtocol', './LocationUtils', './PathUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

  var _BrowserProtocol = $__require('./BrowserProtocol');

  Object.defineProperty(exports, 'getUserConfirmation', {
    enumerable: true,
    get: function get() {
      return _BrowserProtocol.getUserConfirmation;
    }
  });
  Object.defineProperty(exports, 'go', {
    enumerable: true,
    get: function get() {
      return _BrowserProtocol.go;
    }
  });

  var _LocationUtils = $__require('./LocationUtils');

  var _PathUtils = $__require('./PathUtils');

  var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
    return (0, _LocationUtils.createLocation)(window.location);
  };

  var pushLocation = exports.pushLocation = function pushLocation(location) {
    window.location.href = (0, _PathUtils.createPath)(location);
    return false; // Don't update location
  };

  var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
    window.location.replace((0, _PathUtils.createPath)(location));
    return false; // Don't update location
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/createBrowserHistory.js', ['invariant', './ExecutionEnvironment', './BrowserProtocol', './RefreshProtocol', './DOMUtils', './createHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var _BrowserProtocol = $__require('./BrowserProtocol');

  var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);

  var _RefreshProtocol = $__require('./RefreshProtocol');

  var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);

  var _DOMUtils = $__require('./DOMUtils');

  var _createHistory = $__require('./createHistory');

  var _createHistory2 = _interopRequireDefault(_createHistory);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }newObj.default = obj;return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  /**
   * Creates and returns a history object that uses HTML5's history API
   * (pushState, replaceState, and the popstate event) to manage history.
   * This is the recommended method of managing history in browsers because
   * it provides the cleanest URLs.
   *
   * Note: In browsers that do not support the HTML5 history API full
   * page reloads will be used to preserve clean URLs. You can force this
   * behavior using { forceRefresh: true } in options.
   */
  var createBrowserHistory = function createBrowserHistory() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    !_ExecutionEnvironment.canUseDOM ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;

    var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
    var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;

    var getUserConfirmation = Protocol.getUserConfirmation;
    var getCurrentLocation = Protocol.getCurrentLocation;
    var pushLocation = Protocol.pushLocation;
    var replaceLocation = Protocol.replaceLocation;
    var go = Protocol.go;

    var history = (0, _createHistory2.default)(_extends({
      getUserConfirmation: getUserConfirmation }, options, {
      getCurrentLocation: getCurrentLocation,
      pushLocation: pushLocation,
      replaceLocation: replaceLocation,
      go: go
    }));

    var listenerCount = 0,
        stopListener = void 0;

    var startListener = function startListener(listener, before) {
      if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);

      var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

      return function () {
        unlisten();

        if (--listenerCount === 0) stopListener();
      };
    };

    var listenBefore = function listenBefore(listener) {
      return startListener(listener, true);
    };

    var listen = function listen(listener) {
      return startListener(listener, false);
    };

    return _extends({}, history, {
      listenBefore: listenBefore,
      listen: listen
    });
  };

  exports.default = createBrowserHistory;
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/browserHistory.js', ['history/lib/createBrowserHistory', './createRouterHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _createBrowserHistory = $__require('history/lib/createBrowserHistory');

  var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

  var _createRouterHistory = $__require('./createRouterHistory');

  var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/ExecutionEnvironment.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/BrowserProtocol.js', ['./LocationUtils', './DOMUtils', './DOMStateStorage', './PathUtils', './ExecutionEnvironment', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;

  var _LocationUtils = $__require('./LocationUtils');

  var _DOMUtils = $__require('./DOMUtils');

  var _DOMStateStorage = $__require('./DOMStateStorage');

  var _PathUtils = $__require('./PathUtils');

  var _ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var PopStateEvent = 'popstate';
  var HashChangeEvent = 'hashchange';

  var needsHashchangeListener = _ExecutionEnvironment.canUseDOM && !(0, _DOMUtils.supportsPopstateOnHashchange)();

  var _createLocation = function _createLocation(historyState) {
    var key = historyState && historyState.key;

    return (0, _LocationUtils.createLocation)({
      pathname: window.location.pathname,
      search: window.location.search,
      hash: window.location.hash,
      state: key ? (0, _DOMStateStorage.readState)(key) : undefined
    }, undefined, key);
  };

  var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
    var historyState = void 0;
    try {
      historyState = window.history.state || {};
    } catch (error) {
      // IE 11 sometimes throws when accessing window.history.state
      // See https://github.com/ReactTraining/history/pull/289
      historyState = {};
    }

    return _createLocation(historyState);
  };

  var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
    return callback(window.confirm(message));
  }; // eslint-disable-line no-alert

  var startListener = exports.startListener = function startListener(listener) {
    var handlePopState = function handlePopState(event) {
      if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
        listener(_createLocation(event.state));
    };

    (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

    var handleUnpoppedHashChange = function handleUnpoppedHashChange() {
      return listener(getCurrentLocation());
    };

    if (needsHashchangeListener) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
    }

    return function () {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashchangeListener) {
        (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
      }
    };
  };

  var updateLocation = function updateLocation(location, updateState) {
    var state = location.state;
    var key = location.key;

    if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);

    updateState({ key: key }, (0, _PathUtils.createPath)(location));
  };

  var pushLocation = exports.pushLocation = function pushLocation(location) {
    return updateLocation(location, function (state, path) {
      return window.history.pushState(state, null, path);
    });
  };

  var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
    return updateLocation(location, function (state, path) {
      return window.history.replaceState(state, null, path);
    });
  };

  var go = exports.go = function go(n) {
    if (n) window.history.go(n);
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/DOMUtils.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
    return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
  };

  var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
    return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
  };

  /**
   * Returns true if the HTML5 history API is supported. Taken from Modernizr.
   *
   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
   * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
   */
  var supportsHistory = exports.supportsHistory = function supportsHistory() {
    var ua = window.navigator.userAgent;

    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

    return window.history && 'pushState' in window.history;
  };

  /**
   * Returns false if using go(n) with hash history causes a full page reload.
   */
  var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf('Firefox') === -1;
  };

  /**
   * Returns true if browser fires popstate on hash change.
   * IE10 and IE11 do not.
   */
  var supportsPopstateOnHashchange = exports.supportsPopstateOnHashchange = function supportsPopstateOnHashchange() {
    return window.navigator.userAgent.indexOf('Trident') === -1;
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/DOMStateStorage.js', ['warning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.readState = exports.saveState = undefined;

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var QuotaExceededErrors = {
    QuotaExceededError: true,
    QUOTA_EXCEEDED_ERR: true
  };

  var SecurityErrors = {
    SecurityError: true
  };

  var KeyPrefix = '@@History/';

  var createKey = function createKey(key) {
    return KeyPrefix + key;
  };

  var saveState = exports.saveState = function saveState(key, state) {
    if (!window.sessionStorage) {
      // Session storage is not available or hidden.
      // sessionStorage is undefined in Internet Explorer when served via file protocol.
      'production' !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;

      return;
    }

    try {
      if (state == null) {
        window.sessionStorage.removeItem(createKey(key));
      } else {
        window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
      }
    } catch (error) {
      if (SecurityErrors[error.name]) {
        // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
        // attempt to access window.sessionStorage.
        'production' !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;

        return;
      }

      if (QuotaExceededErrors[error.name] && window.sessionStorage.length === 0) {
        // Safari "private mode" throws QuotaExceededError.
        'production' !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;

        return;
      }

      throw error;
    }
  };

  var readState = exports.readState = function readState(key) {
    var json = void 0;
    try {
      json = window.sessionStorage.getItem(createKey(key));
    } catch (error) {
      if (SecurityErrors[error.name]) {
        // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
        // attempt to access window.sessionStorage.
        'production' !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;

        return undefined;
      }
    }

    if (json) {
      try {
        return JSON.parse(json);
      } catch (error) {
        // Ignore invalid JSON.
      }
    }

    return undefined;
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/HashProtocol.js', ['./BrowserProtocol', 'warning', './LocationUtils', './DOMUtils', './DOMStateStorage', './PathUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

  var _BrowserProtocol = $__require('./BrowserProtocol');

  Object.defineProperty(exports, 'getUserConfirmation', {
    enumerable: true,
    get: function get() {
      return _BrowserProtocol.getUserConfirmation;
    }
  });
  Object.defineProperty(exports, 'go', {
    enumerable: true,
    get: function get() {
      return _BrowserProtocol.go;
    }
  });

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  var _LocationUtils = $__require('./LocationUtils');

  var _DOMUtils = $__require('./DOMUtils');

  var _DOMStateStorage = $__require('./DOMStateStorage');

  var _PathUtils = $__require('./PathUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var HashChangeEvent = 'hashchange';

  var getHashPath = function getHashPath() {
    // We can't use window.location.hash here because it's not
    // consistent across browsers - Firefox will pre-decode it!
    var href = window.location.href;
    var hashIndex = href.indexOf('#');
    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
  };

  var pushHashPath = function pushHashPath(path) {
    return window.location.hash = path;
  };

  var replaceHashPath = function replaceHashPath(path) {
    var hashIndex = window.location.href.indexOf('#');

    window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
  };

  var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(pathCoder, queryKey) {
    var path = pathCoder.decodePath(getHashPath());
    var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);

    var state = void 0;
    if (key) {
      path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
      state = (0, _DOMStateStorage.readState)(key);
    }

    var init = (0, _PathUtils.parsePath)(path);
    init.state = state;

    return (0, _LocationUtils.createLocation)(init, undefined, key);
  };

  var prevLocation = void 0;

  var startListener = exports.startListener = function startListener(listener, pathCoder, queryKey) {
    var handleHashChange = function handleHashChange() {
      var path = getHashPath();
      var encodedPath = pathCoder.encodePath(path);

      if (path !== encodedPath) {
        // Always be sure we have a properly-encoded hash.
        replaceHashPath(encodedPath);
      } else {
        var currentLocation = getCurrentLocation(pathCoder, queryKey);

        if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events

        prevLocation = currentLocation;

        listener(currentLocation);
      }
    };

    // Ensure the hash is encoded properly.
    var path = getHashPath();
    var encodedPath = pathCoder.encodePath(path);

    if (path !== encodedPath) replaceHashPath(encodedPath);

    (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);

    return function () {
      return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    };
  };

  var updateLocation = function updateLocation(location, pathCoder, queryKey, updateHash) {
    var state = location.state;
    var key = location.key;

    var path = pathCoder.encodePath((0, _PathUtils.createPath)(location));

    if (state !== undefined) {
      path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
      (0, _DOMStateStorage.saveState)(key, state);
    }

    prevLocation = location;

    updateHash(path);
  };

  var pushLocation = exports.pushLocation = function pushLocation(location, pathCoder, queryKey) {
    return updateLocation(location, pathCoder, queryKey, function (path) {
      if (getHashPath() !== path) {
        pushHashPath(path);
      } else {
        'production' !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
      }
    });
  };

  var replaceLocation = exports.replaceLocation = function replaceLocation(location, pathCoder, queryKey) {
    return updateLocation(location, pathCoder, queryKey, function (path) {
      if (getHashPath() !== path) replaceHashPath(path);
    });
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/createHashHistory.js', ['warning', 'invariant', './ExecutionEnvironment', './DOMUtils', './HashProtocol', './createHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _ExecutionEnvironment = $__require('./ExecutionEnvironment');

  var _DOMUtils = $__require('./DOMUtils');

  var _HashProtocol = $__require('./HashProtocol');

  var HashProtocol = _interopRequireWildcard(_HashProtocol);

  var _createHistory = $__require('./createHistory');

  var _createHistory2 = _interopRequireDefault(_createHistory);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }newObj.default = obj;return newObj;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var DefaultQueryKey = '_k';

  var addLeadingSlash = function addLeadingSlash(path) {
    return path.charAt(0) === '/' ? path : '/' + path;
  };

  var HashPathCoders = {
    hashbang: {
      encodePath: function encodePath(path) {
        return path.charAt(0) === '!' ? path : '!' + path;
      },
      decodePath: function decodePath(path) {
        return path.charAt(0) === '!' ? path.substring(1) : path;
      }
    },
    noslash: {
      encodePath: function encodePath(path) {
        return path.charAt(0) === '/' ? path.substring(1) : path;
      },
      decodePath: addLeadingSlash
    },
    slash: {
      encodePath: addLeadingSlash,
      decodePath: addLeadingSlash
    }
  };

  var createHashHistory = function createHashHistory() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    !_ExecutionEnvironment.canUseDOM ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;

    var queryKey = options.queryKey;
    var hashType = options.hashType;

    'production' !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;

    if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;

    if (hashType == null) hashType = 'slash';

    if (!(hashType in HashPathCoders)) {
      'production' !== 'production' ? (0, _warning2.default)(false, 'Invalid hash type: %s', hashType) : void 0;

      hashType = 'slash';
    }

    var pathCoder = HashPathCoders[hashType];

    var getUserConfirmation = HashProtocol.getUserConfirmation;

    var getCurrentLocation = function getCurrentLocation() {
      return HashProtocol.getCurrentLocation(pathCoder, queryKey);
    };

    var pushLocation = function pushLocation(location) {
      return HashProtocol.pushLocation(location, pathCoder, queryKey);
    };

    var replaceLocation = function replaceLocation(location) {
      return HashProtocol.replaceLocation(location, pathCoder, queryKey);
    };

    var history = (0, _createHistory2.default)(_extends({
      getUserConfirmation: getUserConfirmation }, options, {
      getCurrentLocation: getCurrentLocation,
      pushLocation: pushLocation,
      replaceLocation: replaceLocation,
      go: HashProtocol.go
    }));

    var listenerCount = 0,
        stopListener = void 0;

    var startListener = function startListener(listener, before) {
      if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, pathCoder, queryKey);

      var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

      return function () {
        unlisten();

        if (--listenerCount === 0) stopListener();
      };
    };

    var listenBefore = function listenBefore(listener) {
      return startListener(listener, true);
    };

    var listen = function listen(listener) {
      return startListener(listener, false);
    };

    var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

    var go = function go(n) {
      'production' !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;

      history.go(n);
    };

    var createHref = function createHref(path) {
      return '#' + pathCoder.encodePath(history.createHref(path));
    };

    return _extends({}, history, {
      listenBefore: listenBefore,
      listen: listen,
      go: go,
      createHref: createHref
    });
  };

  exports.default = createHashHistory;
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/useRouterHistory.js', ['history/lib/useQueries', 'history/lib/useBasename', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.default = useRouterHistory;

  var _useQueries = $__require('history/lib/useQueries');

  var _useQueries2 = _interopRequireDefault(_useQueries);

  var _useBasename = $__require('history/lib/useBasename');

  var _useBasename2 = _interopRequireDefault(_useBasename);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function useRouterHistory(createHistory) {
    return function (options) {
      var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
      return history;
    };
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/createRouterHistory.js', ['./useRouterHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  exports.default = function (createHistory) {
    var history = void 0;
    if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
    return history;
  };

  var _useRouterHistory = $__require('./useRouterHistory');

  var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/hashHistory.js', ['history/lib/createHashHistory', './createRouterHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _createHashHistory = $__require('history/lib/createHashHistory');

  var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

  var _createRouterHistory = $__require('./createRouterHistory');

  var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:strict-uri-encode@1.1.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:strict-uri-encode@1.1.0/index.js', [], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};
	return module.exports;
});
System.registerDynamic("npm:object-assign@4.1.0.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:object-assign@4.1.0/index.js', [], true, function ($__require, exports, module) {
	'use strict';
	/* eslint-disable no-unused-vars */

	var define,
	    global = this || self,
	    GLOBAL = global;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return module.exports;
});
System.registerDynamic("npm:query-string@4.2.3.json", [], false, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:query-string@4.2.3/index.js', ['strict-uri-encode', 'object-assign'], true, function ($__require, exports, module) {
	'use strict';

	var define,
	    global = this || self,
	    GLOBAL = global;
	var strictUriEncode = $__require('strict-uri-encode');
	var objectAssign = $__require('object-assign');

	function encode(value, opts) {
		if (opts.encode) {
			return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}

		return value;
	}

	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};

	exports.parse = function (str) {
		// Create an object with no prototype
		// https://github.com/sindresorhus/query-string/issues/47
		var ret = Object.create(null);

		if (typeof str !== 'string') {
			return ret;
		}

		str = str.trim().replace(/^(\?|#|&)/, '');

		if (!str) {
			return ret;
		}

		str.split('&').forEach(function (param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;

			key = decodeURIComponent(key);

			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);

			if (ret[key] === undefined) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
		});

		return ret;
	};

	exports.stringify = function (obj, opts) {
		var defaults = {
			encode: true,
			strict: true
		};

		opts = objectAssign(defaults, opts);

		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];

			if (val === undefined) {
				return '';
			}

			if (val === null) {
				return encode(key, opts);
			}

			if (Array.isArray(val)) {
				var result = [];

				val.slice().forEach(function (val2) {
					if (val2 === undefined) {
						return;
					}

					if (val2 === null) {
						result.push(encode(key, opts));
					} else {
						result.push(encode(key, opts) + '=' + encode(val2, opts));
					}
				});

				return result.join('&');
			}

			return encode(key, opts) + '=' + encode(val, opts);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};
	return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/useQueries.js', ['query-string', './runTransitionHook', './LocationUtils', './PathUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _queryString = $__require('query-string');

  var _runTransitionHook = $__require('./runTransitionHook');

  var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

  var _LocationUtils = $__require('./LocationUtils');

  var _PathUtils = $__require('./PathUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var defaultStringifyQuery = function defaultStringifyQuery(query) {
    return (0, _queryString.stringify)(query).replace(/%20/g, '+');
  };

  var defaultParseQueryString = _queryString.parse;

  /**
   * Returns a new createHistory function that may be used to create
   * history objects that know how to handle URL queries.
   */
  var useQueries = function useQueries(createHistory) {
    return function () {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var history = createHistory(options);
      var stringifyQuery = options.stringifyQuery;
      var parseQueryString = options.parseQueryString;

      if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

      if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

      var decodeQuery = function decodeQuery(location) {
        if (!location) return location;

        if (location.query == null) location.query = parseQueryString(location.search.substring(1));

        return location;
      };

      var encodeQuery = function encodeQuery(location, query) {
        if (query == null) return location;

        var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
        var queryString = stringifyQuery(query);
        var search = queryString ? '?' + queryString : '';

        return _extends({}, object, {
          search: search
        });
      };

      // Override all read methods with query-aware versions.
      var getCurrentLocation = function getCurrentLocation() {
        return decodeQuery(history.getCurrentLocation());
      };

      var listenBefore = function listenBefore(hook) {
        return history.listenBefore(function (location, callback) {
          return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
        });
      };

      var listen = function listen(listener) {
        return history.listen(function (location) {
          return listener(decodeQuery(location));
        });
      };

      // Override all write methods with query-aware versions.
      var push = function push(location) {
        return history.push(encodeQuery(location, location.query));
      };

      var replace = function replace(location) {
        return history.replace(encodeQuery(location, location.query));
      };

      var createPath = function createPath(location) {
        return history.createPath(encodeQuery(location, location.query));
      };

      var createHref = function createHref(location) {
        return history.createHref(encodeQuery(location, location.query));
      };

      var createLocation = function createLocation(location) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));

        if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);

        return decodeQuery(newLocation);
      };

      return _extends({}, history, {
        getCurrentLocation: getCurrentLocation,
        listenBefore: listenBefore,
        listen: listen,
        push: push,
        replace: replace,
        createPath: createPath,
        createHref: createHref,
        createLocation: createLocation
      });
    };
  };

  exports.default = useQueries;
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/useBasename.js', ['./runTransitionHook', './PathUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _runTransitionHook = $__require('./runTransitionHook');

  var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

  var _PathUtils = $__require('./PathUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var useBasename = function useBasename(createHistory) {
    return function () {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var history = createHistory(options);
      var basename = options.basename;

      var addBasename = function addBasename(location) {
        if (!location) return location;

        if (basename && location.basename == null) {
          if (location.pathname.indexOf(basename) === 0) {
            location.pathname = location.pathname.substring(basename.length);
            location.basename = basename;

            if (location.pathname === '') location.pathname = '/';
          } else {
            location.basename = '';
          }
        }

        return location;
      };

      var prependBasename = function prependBasename(location) {
        if (!basename) return location;

        var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
        var pname = object.pathname;
        var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
        var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
        var pathname = normalizedBasename + normalizedPathname;

        return _extends({}, object, {
          pathname: pathname
        });
      };

      // Override all read methods with basename-aware versions.
      var getCurrentLocation = function getCurrentLocation() {
        return addBasename(history.getCurrentLocation());
      };

      var listenBefore = function listenBefore(hook) {
        return history.listenBefore(function (location, callback) {
          return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
        });
      };

      var listen = function listen(listener) {
        return history.listen(function (location) {
          return listener(addBasename(location));
        });
      };

      // Override all write methods with basename-aware versions.
      var push = function push(location) {
        return history.push(prependBasename(location));
      };

      var replace = function replace(location) {
        return history.replace(prependBasename(location));
      };

      var createPath = function createPath(location) {
        return history.createPath(prependBasename(location));
      };

      var createHref = function createHref(location) {
        return history.createHref(prependBasename(location));
      };

      var createLocation = function createLocation(location) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
      };

      return _extends({}, history, {
        getCurrentLocation: getCurrentLocation,
        listenBefore: listenBefore,
        listen: listen,
        push: push,
        replace: replace,
        createPath: createPath,
        createHref: createHref,
        createLocation: createLocation
      });
    };
  };

  exports.default = useBasename;
  return module.exports;
});
System.registerDynamic("npm:history@3.2.1/lib/AsyncUtils.js", ["process"], true, function ($__require, exports, module) {
  "use strict";

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
    var currentTurn = 0,
        isDone = false;
    var isSync = false,
        hasNext = false,
        doneArgs = void 0;

    var done = function done() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      isDone = true;

      if (isSync) {
        // Iterate instead of recursing if possible.
        doneArgs = args;
        return;
      }

      callback.apply(undefined, args);
    };

    var next = function next() {
      if (isDone) return;

      hasNext = true;

      if (isSync) return; // Iterate instead of recursing if possible.

      isSync = true;

      while (!isDone && currentTurn < turns && hasNext) {
        hasNext = false;
        work(currentTurn++, next, done);
      }

      isSync = false;

      if (isDone) {
        // This means the loop finished synchronously.
        callback.apply(undefined, doneArgs);
        return;
      }

      if (currentTurn >= turns && hasNext) {
        isDone = true;
        callback();
      }
    };

    next();
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/runTransitionHook.js', ['warning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var runTransitionHook = function runTransitionHook(hook, location, callback) {
    var result = hook(location, callback);

    if (hook.length < 2) {
      // Assume the hook runs synchronously and automatically
      // call the callback with the return value.
      callback(result);
    } else {
      'production' !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
    }
  };

  exports.default = runTransitionHook;
  return module.exports;
});
System.registerDynamic("npm:invariant@2.2.2.json", [], false, function() {
  return {
    "main": "invariant.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./invariant.js": {
        "browser": "./browser.js"
      }
    }
  };
});

System.registerDynamic('npm:invariant@2.2.2/browser.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var invariant = function (condition, format, a, b, c, d, e, f) {
    if ('production' !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };

  module.exports = invariant;
  return module.exports;
});
System.registerDynamic("npm:warning@3.0.0.json", [], false, function() {
  return {
    "main": "warning.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./warning.js": {
        "browser": "./browser.js"
      }
    }
  };
});

System.registerDynamic('npm:warning@3.0.0/browser.js', ['process'], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  'use strict';

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  var warning = function () {};

  if ('production' !== 'production') {
    warning = function (condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);
      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.length < 10 || /^[s\W]*$/.test(format)) {
        throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
      }

      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      }
    };
  }

  module.exports = warning;
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/PathUtils.js', ['warning', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = undefined;

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
    var _parsePath = parsePath(path);

    var pathname = _parsePath.pathname;
    var search = _parsePath.search;
    var hash = _parsePath.hash;

    return createPath({
      pathname: pathname,
      search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
      hash: hash
    });
  };

  var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
    var _parsePath2 = parsePath(path);

    var pathname = _parsePath2.pathname;
    var search = _parsePath2.search;
    var hash = _parsePath2.hash;

    return createPath({
      pathname: pathname,
      search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
        return prefix === '?' ? prefix : suffix;
      }),
      hash: hash
    });
  };

  var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
    var _parsePath3 = parsePath(path);

    var search = _parsePath3.search;

    var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
    return match && match[1];
  };

  var extractPath = function extractPath(string) {
    var match = string.match(/^(https?:)?\/\/[^\/]*/);
    return match == null ? string : string.substring(match[0].length);
  };

  var parsePath = exports.parsePath = function parsePath(path) {
    var pathname = extractPath(path);
    var search = '';
    var hash = '';

    'production' !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;

    var hashIndex = pathname.indexOf('#');
    if (hashIndex !== -1) {
      hash = pathname.substring(hashIndex);
      pathname = pathname.substring(0, hashIndex);
    }

    var searchIndex = pathname.indexOf('?');
    if (searchIndex !== -1) {
      search = pathname.substring(searchIndex);
      pathname = pathname.substring(0, searchIndex);
    }

    if (pathname === '') pathname = '/';

    return {
      pathname: pathname,
      search: search,
      hash: hash
    };
  };

  var createPath = exports.createPath = function createPath(location) {
    if (location == null || typeof location === 'string') return location;

    var basename = location.basename;
    var pathname = location.pathname;
    var search = location.search;
    var hash = location.hash;

    var path = (basename || '') + pathname;

    if (search && search !== '?') path += search;

    if (hash) path += hash;

    return path;
  };
  return module.exports;
});
System.registerDynamic("npm:history@3.2.1/lib/LocationUtils.js", ["invariant", "warning", "./PathUtils", "./Actions", "process"], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require("process");
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _invariant = $__require("invariant");

  var _invariant2 = _interopRequireDefault(_invariant);

  var _warning = $__require("warning");

  var _warning2 = _interopRequireDefault(_warning);

  var _PathUtils = $__require("./PathUtils");

  var _Actions = $__require("./Actions");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var createQuery = exports.createQuery = function createQuery(props) {
    return _extends(Object.create(null), props);
  };

  var createLocation = exports.createLocation = function createLocation() {
    var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
    var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
    var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;

    "production" !== 'production' ? (0, _warning2.default)(!object.path, 'Location descriptor objects should have a `pathname`, not a `path`.') : void 0;

    var pathname = object.pathname || '/';
    var search = object.search || '';
    var hash = object.hash || '';
    var state = object.state;

    return {
      pathname: pathname,
      search: search,
      hash: hash,
      state: state,
      action: action,
      key: key
    };
  };

  var isDate = function isDate(object) {
    return Object.prototype.toString.call(object) === '[object Date]';
  };

  var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
    if (a === b) return true;

    var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
    var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

    if (typeofA !== typeofB) return false;

    !(typeofA !== 'function') ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;

    // Not the same object, but same type.
    if (typeofA === 'object') {
      !!(isDate(a) && isDate(b)) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;

      if (!Array.isArray(a)) {
        var keysofA = Object.keys(a);
        var keysofB = Object.keys(b);
        return keysofA.length === keysofB.length && keysofA.every(function (key) {
          return statesAreEqual(a[key], b[key]);
        });
      }

      return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
        return statesAreEqual(item, b[index]);
      });
    }

    // All other serializable types (string, number, boolean)
    // should be strict equal.
    return false;
  };

  var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
    return a.key === b.key &&
    // a.action === b.action && // Different action !== location change.
    a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
  };
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/createHistory.js', ['./AsyncUtils', './PathUtils', './runTransitionHook', './Actions', './LocationUtils', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _AsyncUtils = $__require('./AsyncUtils');

  var _PathUtils = $__require('./PathUtils');

  var _runTransitionHook = $__require('./runTransitionHook');

  var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

  var _Actions = $__require('./Actions');

  var _LocationUtils = $__require('./LocationUtils');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var createHistory = function createHistory() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var getCurrentLocation = options.getCurrentLocation;
    var getUserConfirmation = options.getUserConfirmation;
    var pushLocation = options.pushLocation;
    var replaceLocation = options.replaceLocation;
    var go = options.go;
    var keyLength = options.keyLength;

    var currentLocation = void 0;
    var pendingLocation = void 0;
    var beforeListeners = [];
    var listeners = [];
    var allKeys = [];

    var getCurrentIndex = function getCurrentIndex() {
      if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);

      if (currentLocation) return allKeys.indexOf(currentLocation.key);

      return -1;
    };

    var updateLocation = function updateLocation(nextLocation) {
      var currentIndex = getCurrentIndex();

      currentLocation = nextLocation;

      if (currentLocation.action === _Actions.PUSH) {
        allKeys = [].concat(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
      } else if (currentLocation.action === _Actions.REPLACE) {
        allKeys[currentIndex] = currentLocation.key;
      }

      listeners.forEach(function (listener) {
        return listener(currentLocation);
      });
    };

    var listenBefore = function listenBefore(listener) {
      beforeListeners.push(listener);

      return function () {
        return beforeListeners = beforeListeners.filter(function (item) {
          return item !== listener;
        });
      };
    };

    var listen = function listen(listener) {
      listeners.push(listener);

      return function () {
        return listeners = listeners.filter(function (item) {
          return item !== listener;
        });
      };
    };

    var confirmTransitionTo = function confirmTransitionTo(location, callback) {
      (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
        (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
          return result != null ? done(result) : next();
        });
      }, function (message) {
        if (getUserConfirmation && typeof message === 'string') {
          getUserConfirmation(message, function (ok) {
            return callback(ok !== false);
          });
        } else {
          callback(message !== false);
        }
      });
    };

    var transitionTo = function transitionTo(nextLocation) {
      if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do

      pendingLocation = nextLocation;

      confirmTransitionTo(nextLocation, function (ok) {
        if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation

        pendingLocation = null;

        if (ok) {
          // Treat PUSH to same path like REPLACE to be consistent with browsers
          if (nextLocation.action === _Actions.PUSH) {
            var prevPath = (0, _PathUtils.createPath)(currentLocation);
            var nextPath = (0, _PathUtils.createPath)(nextLocation);

            if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
          }

          if (nextLocation.action === _Actions.POP) {
            updateLocation(nextLocation);
          } else if (nextLocation.action === _Actions.PUSH) {
            if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
          } else if (nextLocation.action === _Actions.REPLACE) {
            if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
          }
        } else if (currentLocation && nextLocation.action === _Actions.POP) {
          var prevIndex = allKeys.indexOf(currentLocation.key);
          var nextIndex = allKeys.indexOf(nextLocation.key);

          if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
        }
      });
    };

    var push = function push(input) {
      return transitionTo(createLocation(input, _Actions.PUSH));
    };

    var replace = function replace(input) {
      return transitionTo(createLocation(input, _Actions.REPLACE));
    };

    var goBack = function goBack() {
      return go(-1);
    };

    var goForward = function goForward() {
      return go(1);
    };

    var createKey = function createKey() {
      return Math.random().toString(36).substr(2, keyLength || 6);
    };

    var createHref = function createHref(location) {
      return (0, _PathUtils.createPath)(location);
    };

    var createLocation = function createLocation(location, action) {
      var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
      return (0, _LocationUtils.createLocation)(location, action, key);
    };

    return {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      transitionTo: transitionTo,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      createKey: createKey,
      createPath: _PathUtils.createPath,
      createHref: createHref,
      createLocation: createLocation
    };
  };

  exports.default = createHistory;
  return module.exports;
});
System.registerDynamic('npm:history@3.2.1/lib/Actions.js', ['process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  /**
   * Indicates that navigation was caused by a call to history.push.
   */
  var PUSH = exports.PUSH = 'PUSH';

  /**
   * Indicates that navigation was caused by a call to history.replace.
   */
  var REPLACE = exports.REPLACE = 'REPLACE';

  /**
   * Indicates that navigation was caused by some other action such
   * as using a browser's back/forward buttons and/or manually manipulating
   * the URL in a browser's location bar. This is the default.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
   * for more information.
   */
  var POP = exports.POP = 'POP';
  return module.exports;
});
System.registerDynamic("npm:history@3.2.1.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic('npm:history@3.2.1/lib/createMemoryHistory.js', ['warning', 'invariant', './LocationUtils', './PathUtils', './createHistory', './Actions', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _warning = $__require('warning');

  var _warning2 = _interopRequireDefault(_warning);

  var _invariant = $__require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _LocationUtils = $__require('./LocationUtils');

  var _PathUtils = $__require('./PathUtils');

  var _createHistory = $__require('./createHistory');

  var _createHistory2 = _interopRequireDefault(_createHistory);

  var _Actions = $__require('./Actions');

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var createStateStorage = function createStateStorage(entries) {
    return entries.filter(function (entry) {
      return entry.state;
    }).reduce(function (memo, entry) {
      memo[entry.key] = entry.state;
      return memo;
    }, {});
  };

  var createMemoryHistory = function createMemoryHistory() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    if (Array.isArray(options)) {
      options = { entries: options };
    } else if (typeof options === 'string') {
      options = { entries: [options] };
    }

    var getCurrentLocation = function getCurrentLocation() {
      var entry = entries[current];
      var path = (0, _PathUtils.createPath)(entry);

      var key = void 0,
          state = void 0;
      if (entry.key) {
        key = entry.key;
        state = readState(key);
      }

      var init = (0, _PathUtils.parsePath)(path);

      return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
    };

    var canGo = function canGo(n) {
      var index = current + n;
      return index >= 0 && index < entries.length;
    };

    var go = function go(n) {
      if (!n) return;

      if (!canGo(n)) {
        'production' !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;

        return;
      }

      current += n;
      var currentLocation = getCurrentLocation();

      // Change action to POP
      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
    };

    var pushLocation = function pushLocation(location) {
      current += 1;

      if (current < entries.length) entries.splice(current);

      entries.push(location);

      saveState(location.key, location.state);
    };

    var replaceLocation = function replaceLocation(location) {
      entries[current] = location;
      saveState(location.key, location.state);
    };

    var history = (0, _createHistory2.default)(_extends({}, options, {
      getCurrentLocation: getCurrentLocation,
      pushLocation: pushLocation,
      replaceLocation: replaceLocation,
      go: go
    }));

    var _options = options;
    var entries = _options.entries;
    var current = _options.current;

    if (typeof entries === 'string') {
      entries = [entries];
    } else if (!Array.isArray(entries)) {
      entries = ['/'];
    }

    entries = entries.map(function (entry) {
      return (0, _LocationUtils.createLocation)(entry);
    });

    if (current == null) {
      current = entries.length - 1;
    } else {
      !(current >= 0 && current < entries.length) ? 'production' !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
    }

    var storage = createStateStorage(entries);

    var saveState = function saveState(key, state) {
      return storage[key] = state;
    };

    var readState = function readState(key) {
      return storage[key];
    };

    return _extends({}, history, {
      canGo: canGo
    });
  };

  exports.default = createMemoryHistory;
  return module.exports;
});
System.registerDynamic('npm:react-router@3.0.0/lib/createMemoryHistory.js', ['history/lib/useQueries', 'history/lib/useBasename', 'history/lib/createMemoryHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.default = createMemoryHistory;

  var _useQueries = $__require('history/lib/useQueries');

  var _useQueries2 = _interopRequireDefault(_useQueries);

  var _useBasename = $__require('history/lib/useBasename');

  var _useBasename2 = _interopRequireDefault(_useBasename);

  var _createMemoryHistory = $__require('history/lib/createMemoryHistory');

  var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function createMemoryHistory(options) {
    // signatures and type checking differ between `useQueries` and
    // `createMemoryHistory`, have to create `memoryHistory` first because
    // `useQueries` doesn't understand the signature
    var memoryHistory = (0, _createMemoryHistory2.default)(options);
    var createHistory = function createHistory() {
      return memoryHistory;
    };
    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
    return history;
  }
  module.exports = exports['default'];
  return module.exports;
});
System.registerDynamic("npm:jspm-nodelibs-process@0.2.0.json", [], false, function() {
  return {
    "main": "./process.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-process@0.2.0/process.js', ['@system-env'], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
    return module.exports;
});
System.registerDynamic("npm:react-router@3.0.0.json", [], false, function() {
  return {
    "main": "lib/index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "es/*": {
        "format": "esm"
      }
    },
    "map": {
      "./lib": "./lib/index.js"
    }
  };
});

System.registerDynamic('npm:react-router@3.0.0/lib/index.js', ['./RouteUtils', './PropTypes', './PatternUtils', './Router', './Link', './IndexLink', './withRouter', './IndexRedirect', './IndexRoute', './Redirect', './Route', './RouterContext', './match', './useRouterHistory', './applyRouterMiddleware', './browserHistory', './hashHistory', './createMemoryHistory', 'process'], true, function ($__require, exports, module) {
  'use strict';

  var process = $__require('process');
  var define,
      global = this || self,
      GLOBAL = global;
  exports.__esModule = true;
  exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.RouterContext = exports.createRoutes = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;

  var _RouteUtils = $__require('./RouteUtils');

  Object.defineProperty(exports, 'createRoutes', {
    enumerable: true,
    get: function get() {
      return _RouteUtils.createRoutes;
    }
  });

  var _PropTypes = $__require('./PropTypes');

  Object.defineProperty(exports, 'locationShape', {
    enumerable: true,
    get: function get() {
      return _PropTypes.locationShape;
    }
  });
  Object.defineProperty(exports, 'routerShape', {
    enumerable: true,
    get: function get() {
      return _PropTypes.routerShape;
    }
  });

  var _PatternUtils = $__require('./PatternUtils');

  Object.defineProperty(exports, 'formatPattern', {
    enumerable: true,
    get: function get() {
      return _PatternUtils.formatPattern;
    }
  });

  var _Router2 = $__require('./Router');

  var _Router3 = _interopRequireDefault(_Router2);

  var _Link2 = $__require('./Link');

  var _Link3 = _interopRequireDefault(_Link2);

  var _IndexLink2 = $__require('./IndexLink');

  var _IndexLink3 = _interopRequireDefault(_IndexLink2);

  var _withRouter2 = $__require('./withRouter');

  var _withRouter3 = _interopRequireDefault(_withRouter2);

  var _IndexRedirect2 = $__require('./IndexRedirect');

  var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);

  var _IndexRoute2 = $__require('./IndexRoute');

  var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);

  var _Redirect2 = $__require('./Redirect');

  var _Redirect3 = _interopRequireDefault(_Redirect2);

  var _Route2 = $__require('./Route');

  var _Route3 = _interopRequireDefault(_Route2);

  var _RouterContext2 = $__require('./RouterContext');

  var _RouterContext3 = _interopRequireDefault(_RouterContext2);

  var _match2 = $__require('./match');

  var _match3 = _interopRequireDefault(_match2);

  var _useRouterHistory2 = $__require('./useRouterHistory');

  var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);

  var _applyRouterMiddleware2 = $__require('./applyRouterMiddleware');

  var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);

  var _browserHistory2 = $__require('./browserHistory');

  var _browserHistory3 = _interopRequireDefault(_browserHistory2);

  var _hashHistory2 = $__require('./hashHistory');

  var _hashHistory3 = _interopRequireDefault(_hashHistory2);

  var _createMemoryHistory2 = $__require('./createMemoryHistory');

  var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  exports.Router = _Router3.default; /* components */

  exports.Link = _Link3.default;
  exports.IndexLink = _IndexLink3.default;
  exports.withRouter = _withRouter3.default;

  /* components (configuration) */

  exports.IndexRedirect = _IndexRedirect3.default;
  exports.IndexRoute = _IndexRoute3.default;
  exports.Redirect = _Redirect3.default;
  exports.Route = _Route3.default;

  /* utils */

  exports.RouterContext = _RouterContext3.default;
  exports.match = _match3.default;
  exports.useRouterHistory = _useRouterHistory3.default;
  exports.applyRouterMiddleware = _applyRouterMiddleware3.default;

  /* histories */

  exports.browserHistory = _browserHistory3.default;
  exports.hashHistory = _hashHistory3.default;
  exports.createMemoryHistory = _createMemoryHistory3.default;
  return module.exports;
});
System.registerDynamic("npm:jquery@3.1.1.json", [], false, function() {
  return {
    "main": "dist/jquery.js",
    "format": "amd",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

(function() {
var define = System.amdDefine;
(function(global, factory) {
  "use strict";
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  "use strict";
  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};
  function DOMEval(code, doc) {
    doc = doc || document;
    var script = doc.createElement("script");
    script.text = code;
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  var version = "3.1.1",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      if (num == null) {
        return slice.call(this);
      }
      return num < 0 ? this[num + this.length] : this[num];
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
    },
    isPlainObject: function(obj) {
      var proto,
          Ctor;
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);
      if (!proto) {
        return true;
      }
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      DOMEval(code);
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        },
        unloadHandler = function() {
          setDocument();
        },
        disabledAncestor = addCombinator(function(elem) {
          return elem.disabled === true && ("form" in elem || "label" in elem);
        }, {
          dir: "parentNode",
          next: "legend"
        });
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var el = document.createElement("fieldset");
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);
            if (elem) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i = 0;
              while ((elem = elems[i++])) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(el) {
          support.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[key] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(el) {
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });
    if (!assert(function(el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function(elem) {
        return (indexOf.call(qualifier, elem) > -1) !== not;
      });
    }
    if (risSimple.test(qualifier)) {
      return jQuery.filter(qualifier, elements, not);
    }
    qualifier = jQuery.filter(qualifier, elements);
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          ret,
          len = this.length,
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors);
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject) {
    var method;
    try {
      if (value && jQuery.isFunction((method = value.promise))) {
        method.call(value).done(resolve).fail(reject);
      } else if (value && jQuery.isFunction((method = value.then))) {
        method.call(value, resolve, reject);
      } else {
        resolve.call(undefined, value);
      }
    } catch (value) {
      reject.call(undefined, value);
    }
  }
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred, handler, special) {
                return function() {
                  var that = this,
                      args = arguments,
                      mightThrow = function() {
                        var returned,
                            then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (jQuery.isFunction(then)) {
                          if (special) {
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                          } else {
                            maxDepth++;
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                          }
                        } else {
                          if (handler !== Identity) {
                            that = undefined;
                            args = [returned];
                          }
                          (special || deferred.resolveWith)(that, args);
                        }
                      },
                      process = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(e, process.stackTrace);
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }
                            deferred.rejectWith(that, args);
                          }
                        }
                      };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery.Deferred.getStackHook) {
                      process.stackTrace = jQuery.Deferred.getStackHook();
                    }
                    window.setTimeout(process);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));
                tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[5];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[3 - i][2].disable, tuples[0][2].lock);
        }
        list.add(tuple[3].fire);
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(singleValue) {
      var remaining = arguments.length,
          i = remaining,
          resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          master = jQuery.Deferred(),
          updateFunc = function(i) {
            return function(value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!(--remaining)) {
                master.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject);
        if (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  jQuery.Deferred.exceptionHook = function(error, stack) {
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
  jQuery.readyException = function(error) {
    window.setTimeout(function() {
      throw error;
    });
  };
  var readyList = jQuery.Deferred();
  jQuery.fn.ready = function(fn) {
    readyList.then(fn).catch(function(error) {
      jQuery.readyException(error);
    });
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then;
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
    window.setTimeout(jQuery.ready);
  } else {
    document.addEventListener("DOMContentLoaded", completed);
    window.addEventListener("load", completed);
  }
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function(owner) {
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[jQuery.camelCase(data)] = value;
      } else {
        for (prop in data) {
          cache[jQuery.camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
    },
    access: function(owner, key, value) {
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        if (jQuery.isArray(key)) {
          key = key.map(jQuery.camelCase);
        } else {
          key = jQuery.camelCase(key);
          key = key in cache ? [key] : (key.match(rnothtmlwhite) || []);
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHiddenWithinTree = function(elem, el) {
    elem = el || elem;
    return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";
          dataPriv.set(elem, "display", display);
        }
      }
    }
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && jQuery.nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }
    return ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(nativeEvent) {
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }
      cur = this;
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: jQuery.isFunction(hook) ? function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
      this.target = (src.target && src.target.nodeType === 3) ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function(event) {
      var button = event.button;
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, jQuery.event.addProp);
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    if (jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return elem.getElementsByTagName("tbody")[0] || elem;
    }
    return elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  (function() {
    function computeStyleTests() {
      if (!div) {
        return;
      }
      div.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
      div = null;
    }
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        computeStyleTests();
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i,
        val = 0;
    if (extra === (isBorderBox ? "border" : "content")) {
      i = 4;
    } else {
      i = name === "width" ? 1 : 0;
    }
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var val,
        valueIsBorderBox = true,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (elem.getClientRects().length) {
      val = elem.getBoundingClientRect()[name];
    }
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }});
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function raf() {
    if (timerId) {
      window.requestAnimationFrame(raf);
      jQuery.fx.tick();
    }
  }
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }
    if (isBox && elem.nodeType === 1) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          if (!propTween) {
            anim.done(function() {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    propTween = false;
    for (prop in orig) {
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          showHide([elem], true);
        }
        anim.done(function() {
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    if (jQuery.fx.off || document.hidden) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    if (window.cancelAnimationFrame) {
      window.cancelAnimationFrame(timerId);
    } else {
      window.clearInterval(timerId);
    }
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          i = 0,
          attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();
      if (!isXML) {
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnothtmlwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }
          return ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : stripAndCollapse(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, valueOrFunction) {
          var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        if (val == null) {
          return null;
        }
        if (jQuery.isArray(val)) {
          return jQuery.map(val, function(val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": JSON.parse,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          completed,
          fireGlobals,
          i,
          uncached,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return completed ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (completed == null) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (completed) {
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR);
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (completed) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url.replace(rhash, "");
      if (!s.hasContent) {
        uncached = s.url.slice(cacheURL.length);
        if (s.data) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
        }
        s.url = cacheURL + uncached;
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (completed) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (completed) {
            throw e;
          }
          done(-1, e);
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (completed) {
          return;
        }
        completed = true;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (this[0]) {
        if (jQuery.isFunction(html)) {
          html = html.call(this[0]);
        }
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function(selector) {
      this.parent(selector).not("body").each(function() {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  jQuery.expr.pseudos.hidden = function(elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function(elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxPrefilter(function(s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base,
        parsed,
        scripts;
    if (!context) {
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  jQuery.fn.load = function(url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.pseudos.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          rect,
          doc,
          elem = this[0];
      if (!elem) {
        return;
      }
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      rect = elem.getBoundingClientRect();
      if (rect.width || rect.height) {
        doc = elem.ownerDocument;
        win = getWindow(doc);
        docElem = doc.documentElement;
        return {
          top: rect.top + win.pageYOffset - docElem.clientTop,
          left: rect.left + win.pageXOffset - docElem.clientLeft
        };
      }
      return rect;
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset = {
          top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
          left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
        };
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  jQuery.parseJSON = JSON.parse;
  if (typeof define === "function" && define.amd) {
    define("npm:jquery@3.1.1/dist/jquery.js", [], function() {
      return jQuery;
    }) && define("jquery", ["npm:jquery@3.1.1/dist/jquery.js"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});

})();
System.registerDynamic("npm:ss-utils@0.1.4.json", [], false, function() {
  return {
    "main": "ss-utils.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:ss-utils@0.1.4/ss-utils.js", ["jquery"], true, function ($__require, exports, module) {
    var define,
        global = this || self,
        GLOBAL = global;
    ;(function (root, f) {
        if (typeof define === "function" && define.amd) {
            define(["jquery"], f);
        } else if (typeof exports === "object") {
            module.exports = f($__require("jquery"));
        } else {
            f(root.jQuery);
        }
    })(this, function ($) {

        if (!$.ss) $.ss = {};
        $.ss.handlers = {};
        $.ss.onSubmitDisable = "[type=submit]";
        $.ss.validation = {
            overrideMessages: false,
            messages: {
                NotEmpty: "Required",
                NotNull: "Required",
                Email: "Invalid email",
                AlreadyExists: "Already exists"
            },
            errorFilter: function (errorMsg, errorCode, type) {
                return this.overrideMessages ? this.messages[errorCode] || errorMsg || splitCase(errorCode) : errorMsg || splitCase(errorCode);
            }
        };
        $.ss.clearAdjacentError = function () {
            $(this).removeClass("error");
            $(this).prev(".help-inline,.help-block").removeClass("error").html("");
            $(this).next(".help-inline,.help-block").removeClass("error").html("");
        };
        $.ss.todate = function (s) {
            return new Date(parseFloat(/Date\(([^)]+)\)/.exec(s)[1]));
        };
        $.ss.todfmt = function (s) {
            return $.ss.dfmt($.ss.todate(s));
        };
        function pad(d) {
            return d < 10 ? '0' + d : d;
        };
        $.ss.dfmt = function (d) {
            return d.getFullYear() + '/' + pad(d.getMonth() + 1) + '/' + pad(d.getDate());
        };
        $.ss.dfmthm = function (d) {
            return d.getFullYear() + '/' + pad(d.getMonth() + 1) + '/' + pad(d.getDate()) + ' ' + pad(d.getHours()) + ":" + pad(d.getMinutes());
        };
        $.ss.tfmt12 = function (d) {
            return pad(d.getHours()) + ":" + pad(d.getMinutes()) + ":" + pad(d.getSeconds()) + " " + (d.getHours() > 12 ? "PM" : "AM");
        };
        $.ss.splitOnFirst = function (s, c) {
            if (!s) return [s];var pos = s.indexOf(c);return pos >= 0 ? [s.substring(0, pos), s.substring(pos + 1)] : [s];
        };
        $.ss.splitOnLast = function (s, c) {
            if (!s) return [s];var pos = s.lastIndexOf(c);return pos >= 0 ? [s.substring(0, pos), s.substring(pos + 1)] : [s];
        };
        $.ss.getSelection = function () {
            return window.getSelection ? window.getSelection().toString() : document.selection && document.selection.type != "Control" ? document.selection.createRange().text : "";
        };
        $.ss.combinePaths = function () {
            var parts = [],
                i,
                l;
            for (i = 0, l = arguments.length; i < l; i++) {
                var arg = arguments[i];
                parts = arg.indexOf("://") === -1 ? parts.concat(arg.split("/")) : parts.concat(arg.lastIndexOf("/") === arg.length - 1 ? arg.substring(0, arg.length - 1) : arg);
            }
            var paths = [];
            for (i = 0, l = parts.length; i < l; i++) {
                var part = parts[i];
                if (!part || part === ".") continue;
                if (part === "..") paths.pop();else paths.push(part);
            }
            if (parts[0] === "") paths.unshift("");
            return paths.join("/") || (paths.length ? "/" : ".");
        };
        $.ss.queryString = function (url) {
            if (!url || url.indexOf('?') === -1) return {};
            var pairs = $.ss.splitOnFirst(url, '?')[1].split('&');
            var map = {};
            for (var i = 0; i < pairs.length; ++i) {
                var p = pairs[i].split('=');
                map[p[0]] = p.length > 1 ? decodeURIComponent(p[1].replace(/\+/g, ' ')) : null;
            }
            return map;
        };
        $.ss.bindAll = function (o) {
            for (var k in o) {
                if (typeof o[k] == 'function') o[k] = o[k].bind(o);
            }
            return o;
        };
        $.ss.createPath = function (route, args) {
            var argKeys = {};
            for (var k in args) {
                argKeys[k.toLowerCase()] = k;
            }
            var parts = route.split('/');
            var url = '';
            for (var i = 0; i < parts.length; i++) {
                var p = parts[i];
                if (p == null) p = '';
                if (p[0] == '{' && p[p.length - 1] == '}') {
                    var key = argKeys[p.substring(1, p.length - 1).toLowerCase()];
                    if (key) {
                        p = args[key];
                        delete args[key];
                    }
                }
                if (url.length > 0) url += '/';
                url += p;
            }
            return url;
        };
        $.ss.createUrl = function (route, args) {
            var url = $.ss.createPath(route, args);
            for (var k in args) {
                url += url.indexOf('?') >= 0 ? '&' : '?';
                url += k + "=" + encodeURIComponent(args[k]);
            }
            return url;
        };
        function splitCase(t) {
            return typeof t != 'string' ? t : t.replace(/([A-Z]|[0-9]+)/g, ' $1').replace(/_/g, ' ');
        };
        $.ss.humanize = function (s) {
            return !s || s.indexOf(' ') >= 0 ? s : splitCase(s);
        };

        function toCamelCase(key) {
            return !key ? key : key.charAt(0).toLowerCase() + key.substring(1);
        }
        $.ss.normalizeKey = function (key) {
            return typeof key == "string" ? key.toLowerCase().replace(/_/g, '') : key;
        };
        $.ss.normalize = function (dto, deep) {
            if ($.isArray(dto)) {
                if (!deep) return dto;
                var to = [];
                for (var i = 0; i < dto.length; i++) {
                    to[i] = $.ss.normalize(dto[i], deep);
                }
                return to;
            }
            if (typeof dto != "object") return dto;
            var o = {};
            for (var k in dto) {
                o[$.ss.normalizeKey(k)] = deep ? $.ss.normalize(dto[k], deep) : dto[k];
            }
            return o;
        };
        function sanitize(status) {
            if (status["errors"]) return status;
            var to = {};
            for (var k in status) to[toCamelCase(k)] = status[k];
            to.errors = [];
            $.each(status.Errors || [], function (i, o) {
                var err = {};
                for (var k in o) err[toCamelCase(k)] = o[k];
                to.errors.push(err);
            });
            return to;
        }
        $.ss.parseResponseStatus = function (json, defaultMsg) {
            try {
                var err = JSON.parse(json);
                return sanitize(err.ResponseStatus || err.responseStatus);
            } catch (e) {
                return {
                    message: defaultMsg,
                    __error: { error: e, json: json }
                };
            }
        };
        $.ss.postJSON = function (url, data, success, error) {
            return $.ajax({
                type: "POST", url: url, dataType: "json", contentType: "application/json",
                data: typeof data == "string" ? data : JSON.stringify(data),
                success: success, error: error
            });
        };

        $.fn.setFieldError = function (name, msg) {
            $(this).applyErrors({
                errors: [{
                    fieldName: name,
                    message: msg
                }]
            });
        };
        $.fn.serializeMap = function () {
            var o = {};
            $.each($(this).serializeArray(), function (i, e) {
                o[e.name] = e.value;
            });
            return o;
        };
        $.fn.applyErrors = function (status, opt) {
            this.clearErrors();
            if (!status) return this;
            status = sanitize(status);

            this.addClass("has-errors");

            var o = $.extend({}, $.ss.validation, opt);
            if (opt && opt.messages) {
                o.overrideMessages = true;
                $.extend(o.messages, $.ss.validation.messages);
            }

            var filter = $.proxy(o.errorFilter, o),
                errors = status.errors;

            if (errors && errors.length) {
                var fieldMap = {},
                    fieldLabelMap = {};
                this.find("input,textarea,select,button").each(function () {
                    var $el = $(this);
                    var $prev = $el.prev(),
                        $next = $el.next();
                    var fieldId = this.id || $el.attr("name");
                    if (!fieldId) return;

                    var key = fieldId.toLowerCase();

                    fieldMap[key] = $el;
                    if ($prev.hasClass("help-inline") || $prev.hasClass("help-block")) {
                        fieldLabelMap[key] = $prev;
                    } else if ($next.hasClass("help-inline") || $next.hasClass("help-block")) {
                        fieldLabelMap[key] = $next;
                    }
                });
                this.find(".help-inline[data-for],.help-block[data-for]").each(function () {
                    var $el = $(this);
                    var key = $el.data("for").toLowerCase();
                    fieldLabelMap[key] = $el;
                });
                $.each(errors, function (i, error) {
                    var key = (error.fieldName || "").toLowerCase();
                    var $field = fieldMap[key];
                    if ($field) {
                        $field.addClass("error");
                        $field.parent().addClass("has-error");
                    }
                    var $lblErr = fieldLabelMap[key];
                    if (!$lblErr) return;

                    $lblErr.addClass("error");
                    $lblErr.html(filter(error.message, error.errorCode, "field"));
                    $lblErr.show();
                });
            } else {
                this.find(".error-summary").html(filter(status.message || splitCase(status.errorCode), status.errorCode, "summary")).show();
            }
            return this;
        };
        $.fn.clearErrors = function () {
            this.removeClass("has-errors");
            this.find(".error-summary").html("").hide();
            this.find(".help-inline.error, .help-block.error").each(function () {
                $(this).html("");
            });
            this.find(".error").each(function () {
                $(this).removeClass("error");
            });
            return this.find(".has-error").each(function () {
                $(this).removeClass("has-error");
            });
        };
        $.fn.bindForm = function (orig) {
            return this.each(function () {
                var f = $(this);
                f.submit(function (e) {
                    e.preventDefault();
                    return $(f).ajaxSubmit(orig);
                });
            });
        };
        $.fn.ajaxSubmit = function (orig) {
            orig = orig || {};
            if (orig.validation) {
                $.extend($.ss.validation, orig.validation);
            }

            return this.each(function () {
                var f = $(this);
                f.clearErrors();
                try {
                    if (orig.validate && orig.validate.call(f) === false) return false;
                } catch (e) {
                    return false;
                }
                f.addClass("loading");
                var $disable = $(orig.onSubmitDisable || $.ss.onSubmitDisable, f);
                $disable.attr("disabled", "disabled");
                var opt = $.extend({}, orig, {
                    type: f.attr('method') || "POST",
                    url: f.attr('action'),
                    data: f.serialize(),
                    accept: "application/json",
                    error: function (jq, jqStatus, statusText) {
                        var err,
                            errMsg = "The request failed with " + statusText;
                        try {
                            err = JSON.parse(jq.responseText);
                        } catch (e) {}
                        if (!err) {
                            f.addClass("has-errors");
                            f.find(".error-summary").html(errMsg);
                        } else {
                            f.applyErrors(err.ResponseStatus || err.responseStatus);
                        }
                        if (orig.error) {
                            orig.error.apply(this, arguments);
                        }
                    },
                    complete: function (jq) {
                        f.removeClass("loading");
                        $disable.removeAttr("disabled");
                        if (orig.complete) {
                            orig.complete.apply(this, arguments);
                        }
                        var loc = jq.getResponseHeader("X-Location");
                        if (loc) {
                            location.href = loc;
                        }
                        var evt = jq.getResponseHeader("X-Trigger");
                        if (evt) {
                            var pos = attr.indexOf(':');
                            var cmd = pos >= 0 ? evt.substring(0, pos) : evt;
                            var data = pos >= 0 ? evt.substring(pos + 1) : null;
                            f.trigger(cmd, data ? [data] : []);
                        }
                    },
                    dataType: "json"
                });
                $.ajax(opt);
                return false;
            });
        };
        $.fn.applyValues = function (map) {
            return this.each(function () {
                var $el = $(this);
                $.each(map, function (k, v) {
                    $el.find("#" + k + ",[name=" + k + "]").val(v);
                });
                $el.find("[data-html]").each(function () {
                    $(this).html(map[$(this).data("html")] || "");
                });
                $el.find("[data-val]").each(function () {
                    $(this).val(map[$(this).data("val")] || "");
                });
                $el.find("[data-src]").each(function () {
                    $(this).attr("src", map[$(this).data("src")] || "");
                });
                $el.find("[data-href]").each(function () {
                    $(this).attr("href", map[$(this).data("href")] || "");
                });
            });
        };
        $.ss.__call = $.ss.__call || function (e) {
            var $el = $(e.target);
            var attr = $el.data(e.type) || $el.closest("[data-" + e.type + "]").data(e.type);
            if (!attr) return;

            var pos = attr.indexOf(':'),
                fn;
            if (pos >= 0) {
                var cmd = attr.substring(0, pos);
                var data = attr.substring(pos + 1);
                if (cmd == 'trigger') {
                    $el.trigger(data, [e.target]);
                } else {
                    fn = $.ss.handlers[cmd];
                    if (fn) {
                        fn.apply(e.target, data.split(','));
                    }
                }
            } else {
                fn = $.ss.handlers[attr];
                if (fn) {
                    fn.apply(e.target, [].splice(arguments));
                }
            }
        };
        $.ss.listenOn = 'click dblclick change focus blur focusin focusout select keydown keypress keyup hover toggle';
        $.fn.bindHandlers = function (handlers) {
            $.extend($.ss.handlers, handlers || {});
            return this.each(function () {
                var $el = $(this);
                $el.off($.ss.listenOn, $.ss.__call);
                $el.on($.ss.listenOn, $.ss.__call);
            });
        };

        $.fn.setActiveLinks = function () {
            var url = window.location.href;
            return this.each(function () {
                $(this).filter(function () {
                    return this.href == url;
                }).addClass('active').closest("li").addClass('active');
            });
        };

        $.ss.eventSourceStop = false;
        $.ss.eventOptions = {};
        $.ss.eventReceivers = {};
        $.ss.eventChannels = [];
        $.ss.eventSourceUrl = null;
        $.ss.updateSubscriberUrl = null;
        $.ss.updateChannels = function (channels) {
            $.ss.eventChannels = channels;
            if (!$.ss.eventSource) return;
            var url = $.ss.eventSource.url;
            $.ss.eventSourceUrl = url.substring(0, Math.min(url.indexOf('?'), url.length)) + "?channels=" + channels.join(',');
        };
        $.ss.updateSubscriberInfo = function (subscribe, unsubscribe) {
            var sub = typeof subscribe == "string" ? subscribe.split(',') : subscribe;
            var unsub = typeof unsubscribe == "string" ? unsubscribe.split(',') : unsubscribe;
            var channels = [];
            for (var i in $.ss.eventChannels) {
                var c = $.ss.eventChannels[i];
                if (unsub == null || $.inArray(c, unsub) === -1) {
                    channels.push(c);
                }
            }
            if (sub) {
                for (var i in sub) {
                    var c = sub[i];
                    if ($.inArray(c, channels) === -1) {
                        channels.push(c);
                    }
                }
            }
            $.ss.updateChannels(channels);
        };
        $.ss.subscribeToChannels = function (channels, cb, cbError) {
            return $.ss.updateSubscriber({ SubscribeChannels: channels.join(',') }, cb, cbError);
        };
        $.ss.unsubscribeFromChannels = function (channels, cb, cbError) {
            return $.ss.updateSubscriber({ UnsubscribeChannels: channels.join(',') }, cb, cbError);
        };
        $.ss.updateSubscriber = function (data, cb, cbError) {
            if (!$.ss.updateSubscriberUrl) throw new Error("updateSubscriberUrl was not populated");
            return $.ajax({
                type: "POST",
                url: $.ss.updateSubscriberUrl,
                data: data,
                dataType: "json",
                success: function (r) {
                    $.ss.updateSubscriberInfo(data.SubscribeChannels, data.UnsubscribeChannels);
                    r.channels = $.ss.eventChannels;
                    if (cb != null) cb(r);
                },
                error: function (e) {
                    $.ss.reconnectServerEvents({ errorArgs: arguments });
                    if (cbError != null) cbError(e);
                }
            });
        };
        $.ss.reconnectServerEvents = function (opt) {
            if ($.ss.eventSourceStop) return;
            opt = opt || {};
            var hold = $.ss.eventSource;
            var es = new EventSource(opt.url || $.ss.eventSourceUrl || hold.url);
            es.onerror = opt.onerror || hold.onerror;
            es.onmessage = opt.onmessage || hold.onmessage;
            var fn = $.ss.handlers["onReconnect"];
            if (fn != null) fn.apply(es, opt.errorArgs);
            hold.close();
            return $.ss.eventSource = es;
        };
        $.ss.invokeReceiver = function (r, cmd, el, msg, e, name) {
            if (r) {
                if (typeof r[cmd] == "function") {
                    r[cmd].call(el || r[cmd], msg, e);
                } else {
                    r[cmd] = msg;
                }
            }
        };
        $.fn.handleServerEvents = function (opt) {
            $.ss.eventSource = this[0];
            $.ss.eventOptions = opt = opt || {};
            if (opt.handlers) {
                $.extend($.ss.handlers, opt.handlers);
            }
            function onMessage(e) {
                var parts = $.ss.splitOnFirst(e.data, ' ');
                var selector = parts[0];
                var selParts = $.ss.splitOnFirst(selector, '@');
                if (selParts.length > 1) {
                    e.channel = selParts[0];
                    selector = selParts[1];
                }
                var json = parts[1];
                var msg = json ? JSON.parse(json) : null;

                parts = $.ss.splitOnFirst(selector, '.');
                if (parts.length <= 1) throw "invalid selector format: " + selector;

                var op = parts[0],
                    target = parts[1].replace(new RegExp("%20", 'g'), " ");

                if (opt.validate && opt.validate(op, target, msg, json) === false) return;

                var tokens = $.ss.splitOnFirst(target, '$'),
                    cmd = tokens[0],
                    cssSel = tokens[1],
                    $els = cssSel && $(cssSel),
                    el = $els && $els[0];
                if (op == "cmd") {
                    if (cmd == "onConnect") {
                        $.extend(opt, msg);
                        if (opt.heartbeatUrl) {
                            if (opt.heartbeat) {
                                window.clearInterval(opt.heartbeat);
                            }
                            opt.heartbeat = window.setInterval(function () {
                                if ($.ss.eventSource.readyState == 2) //CLOSED
                                    {
                                        window.clearInterval(opt.heartbeat);
                                        var stopFn = $.ss.handlers["onStop"];
                                        if (stopFn != null) stopFn.apply($.ss.eventSource);
                                        $.ss.reconnectServerEvents({ errorArgs: { error: 'CLOSED' } });
                                        return;
                                    }
                                $.ajax({
                                    type: "POST",
                                    url: opt.heartbeatUrl,
                                    data: null,
                                    dataType: "text",
                                    success: function (r) {},
                                    error: function () {
                                        $.ss.reconnectServerEvents({ errorArgs: arguments });
                                    }
                                });
                            }, parseInt(opt.heartbeatIntervalMs) || 10000);
                        }
                        if (opt.unRegisterUrl) {
                            $(window).unload(function () {
                                $.post(opt.unRegisterUrl, null, function (r) {});
                            });
                        }
                        $.ss.updateSubscriberUrl = opt.updateSubscriberUrl;
                        $.ss.updateChannels((opt.channels || "").split(','));
                    }
                    var fn = $.ss.handlers[cmd];
                    if (fn) {
                        fn.call(el || document.body, msg, e);
                    }
                } else if (op == "trigger") {
                    $(el || document).trigger(cmd, [msg, e]);
                } else if (op == "css") {
                    $($els || document.body).css(cmd, msg, e);
                } else {
                    var r = opt.receivers && opt.receivers[op] || $.ss.eventReceivers[op];
                    $.ss.invokeReceiver(r, cmd, el, msg, e, op);
                }

                if (opt.success) {
                    opt.success(selector, msg, e);
                }
            }
            $.ss.eventSource.onmessage = onMessage;
        };
    });
    return module.exports;
});
//# sourceMappingURL=deps.lib.js.map